/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/composio-core";
exports.ids = ["vendor-chunks/composio-core"];
exports.modules = {

/***/ "(action-browser)/./node_modules/composio-core/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/composio-core/constants.js ***!
  \*************************************************/
/***/ ((module) => {

eval("const APPS = {\n  // apps list start here\n  // apps list end here\n};\n\nconst ACTIONS = {\n  // actions list start here\n  // actions list end here\n};\n\nconst COMPOSIO_VERSION = `0.5.39`;\n\nmodule.exports = {\n  APPS,\n  ACTIONS,\n  COMPOSIO_VERSION,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JiaXRhbC1haS1hZ2VudC8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL2NvbnN0YW50cy5qcz9lOTc1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEFQUFMgPSB7XG4gIC8vIGFwcHMgbGlzdCBzdGFydCBoZXJlXG4gIC8vIGFwcHMgbGlzdCBlbmQgaGVyZVxufTtcblxuY29uc3QgQUNUSU9OUyA9IHtcbiAgLy8gYWN0aW9ucyBsaXN0IHN0YXJ0IGhlcmVcbiAgLy8gYWN0aW9ucyBsaXN0IGVuZCBoZXJlXG59O1xuXG5jb25zdCBDT01QT1NJT19WRVJTSU9OID0gYDAuNS4zOWA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBUFBTLFxuICBBQ1RJT05TLFxuICBDT01QT1NJT19WRVJTSU9OLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/constants.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/index.js":
/*!*********************************************!*\
  !*** ./node_modules/composio-core/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar axios = __webpack_require__(/*! axios */ \"(action-browser)/./node_modules/axios/dist/node/axios.cjs\");\nvar uuid = __webpack_require__(/*! uuid */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/index.js\");\nvar z = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/zod/index.cjs\");\nvar clientAxios = __webpack_require__(/*! @hey-api/client-axios */ \"(action-browser)/./node_modules/@hey-api/client-axios/dist/index.cjs\");\nvar zodToJsonSchema = __webpack_require__(/*! zod-to-json-schema */ \"(action-browser)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar tools = __webpack_require__(/*! @langchain/core/tools */ \"(action-browser)/./node_modules/@langchain/core/dist/tools/index.cjs\");\nvar ai = __webpack_require__(/*! ai */ \"(action-browser)/./node_modules/ai/dist/index.js\");\n\nconst COMPOSIO_VERSION = `0.5.39`;\n\nconst getUUID = () => {\n    return uuid.v4();\n};\n\nfunction jsonSchemaPropertiesToTSTypes(value) {\n    if (!value.type) {\n        return z.object({});\n    }\n    let zodType;\n    switch (value.type) {\n        case \"string\":\n            zodType = z\n                .string()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"number\":\n            zodType = z\n                .number()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"integer\":\n            zodType = z\n                .number()\n                .int()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"boolean\":\n            zodType = z\n                .boolean()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"array\":\n            zodType = z\n                .array(jsonSchemaPropertiesToTSTypes(value.items))\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"object\":\n            zodType = jsonSchemaToModel(value).describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"null\":\n            zodType = z.null().describe(value.description || \"\");\n            break;\n        default:\n            throw new Error(`Unsupported JSON schema type: ${value.type}`);\n    }\n    return zodType;\n}\nfunction jsonSchemaToModel(jsonSchema) {\n    const properties = jsonSchema.properties;\n    const requiredFields = jsonSchema.required || [];\n    if (!properties) {\n        return z.object({});\n    }\n    const zodSchema = {};\n    for (const [key, _] of Object.entries(properties)) {\n        const value = _;\n        let zodType;\n        if (value.anyOf) {\n            const anyOfTypes = value.anyOf.map((schema) => jsonSchemaPropertiesToTSTypes(schema));\n            zodType = z\n                .union(anyOfTypes)\n                .describe((value.description || \"\") +\n                (value.examples\n                    ? `\\nExamples: ${value.examples.join(\", \")}`\n                    : \"\"));\n        }\n        else if (value.allOf) {\n            const allOfTypes = value.allOf.map((schema) => jsonSchemaPropertiesToTSTypes(schema));\n            zodType = z\n                .intersection(allOfTypes[0], allOfTypes\n                .slice(1)\n                .reduce((acc, schema) => acc.and(schema), allOfTypes[0]))\n                .describe((value.description || \"\") +\n                (value.examples\n                    ? `\\nExamples: ${value.examples.join(\", \")}`\n                    : \"\"));\n        }\n        else {\n            if (!value.type) {\n                value.type = \"string\";\n            }\n            zodType = jsonSchemaPropertiesToTSTypes(value);\n        }\n        if (value.description) {\n            zodType = zodType.describe(value.description);\n        }\n        if (requiredFields.includes(key)) {\n            zodSchema[key] = zodType;\n        }\n        else {\n            zodSchema[key] = zodType.optional();\n        }\n    }\n    return z.object(zodSchema);\n}\nconst getEnvVariable = (name, defaultValue = undefined) => {\n    try {\n        return process.env[name] || defaultValue;\n    }\n    catch (_e) {\n        return defaultValue;\n    }\n};\n\n// Define log levels with corresponding priorities\nconst LOG_LEVELS = {\n    silent: -1, // No logs\n    error: 0, // Highest priority - critical errors\n    warn: 1, // Warning messages\n    info: 2, // General information\n    debug: 3, // Debug information\n};\n/**\n * Get the current log level from environment variables.\n * Defaults to 'info' if not set or invalid.\n * @returns {keyof typeof LOG_LEVELS} The current log level\n */\nconst getLogLevel = () => {\n    var _a;\n    const envLevel = (_a = getEnvVariable(\"COMPOSIO_LOGGING_LEVEL\", \"info\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    return envLevel && envLevel in LOG_LEVELS\n        ? envLevel\n        : \"info\";\n};\nconst addTimestampToMessage = (message) => {\n    const timestamp = new Date().toISOString();\n    return `${timestamp} - ${message}`;\n};\nconst formatErrorMessage = (args) => {\n    return args\n        .map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg))\n        .join(\" \");\n};\nconst getLogger = () => {\n    const logger = console;\n    const loggingLevel = getLogLevel();\n    const logLevelValue = LOG_LEVELS[loggingLevel];\n    const noop = () => { };\n    return {\n        error: logLevelValue >= LOG_LEVELS.error\n            ? (...args) => logger.error(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        warn: logLevelValue >= LOG_LEVELS.warn\n            ? (...args) => logger.warn(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        info: logLevelValue >= LOG_LEVELS.info\n            ? (...args) => logger.info(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        debug: logLevelValue >= LOG_LEVELS.debug\n            ? (...args) => logger.debug(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n    };\n};\nvar logger = getLogger();\n\nconst ZAuthMode = z.z.enum([\n    \"OAUTH2\",\n    \"OAUTH1\",\n    \"OAUTH1A\",\n    \"API_KEY\",\n    \"BASIC\",\n    \"BEARER_TOKEN\",\n    \"GOOGLE_SERVICE_ACCOUNT\",\n    \"NO_AUTH\",\n    \"BASIC_WITH_JWT\",\n]);\nconst ZCreateIntegrationParams = z.z.object({\n    name: z.z.string(),\n    authScheme: ZAuthMode.optional(),\n    appUniqueKey: z.z.string().optional(),\n    appId: z.z.string().optional(),\n    forceNewIntegration: z.z.boolean().optional(),\n    authConfig: z.z\n        .union([\n        z.z.record(z.z.unknown()),\n        z.z.object({\n            client_id: z.z.string(),\n            client_secret: z.z.string(),\n            api_key: z.z.string(),\n            consumer_key: z.z.string(),\n            consumer_secret: z.z.string(),\n            base_url: z.z.string(),\n        }),\n    ])\n        .optional(),\n    useComposioAuth: z.z.boolean().optional(),\n});\nconst ZSingleIntegrationParams = z.z.object({\n    integrationId: z.z.string(),\n});\nconst ZListIntegrationsParams = z.z.object({\n    page: z.z.number().optional(),\n    pageSize: z.z.number().optional(),\n    appName: z.z.string().optional(),\n    appUniqueKey: z.z.string().optional(),\n    showDisabled: z.z.boolean().optional(),\n});\n\nconst ZExecuteActionParams$1 = z.z.object({\n    actionName: z.z.string(),\n    params: z.z.record(z.z.any()).optional(),\n    text: z.z.string().optional(),\n    connectedAccountId: z.z.string().optional(),\n});\nconst ZInitiateConnectionParams = z.z.object({\n    appName: z.z.string().optional(),\n    authConfig: z.z.record(z.z.any()).optional(),\n    integrationId: z.z.string().optional(),\n    authMode: ZAuthMode.optional(),\n    connectionParams: z.z.record(z.z.any()).optional(),\n    config: z.z\n        .object({\n        labels: z.z.array(z.z.string()).optional(),\n        redirectUrl: z.z.string().optional(),\n    })\n        .optional(),\n    redirectUri: z.z.string().optional(),\n    labels: z.z.array(z.z.string()).optional(),\n});\nconst ZConnectionParams = z.z.object({\n    connectedAccountId: z.z.string().optional(),\n    app: z.z.string().optional(),\n});\nconst ZTriggerSubscribeParam = z.z.object({\n    app: z.z.string().optional(),\n    appName: z.z.string().optional(),\n    triggerName: z.z.string(),\n    config: z.z.record(z.z.any()),\n});\n\n// Helper function to stringify objects if needed\nconst serializeValue = (obj) => {\n    return typeof obj === \"object\" ? JSON.stringify(obj) : obj;\n};\n\n// Constants\nconst COMPOSIO_DIR = \".composio\";\nconst USER_DATA_FILE_NAME = \"user_data.json\";\nconst TEMP_FILES_DIRECTORY_NAME = \"files\";\nconst DEFAULT_BASE_URL = \"https://backend.composio.dev\";\nconst TELEMETRY_URL = \"https://app.composio.dev\";\nconst IS_DEVELOPMENT_OR_CI = process.env.DEVELOPMENT || process.env.CI || false;\n\n/**\n * Sends a reporting payload to the telemetry server using a child process.\n * This function is intended for use in Node.js environments.\n *\n * @param {any} reportingPayload - The payload to be sent to the telemetry server.\n */\nfunction sendProcessReq(info) {\n    if (IS_DEVELOPMENT_OR_CI) {\n        logger.debug(`Hitting ${info.url}[${info.method}] with ${serializeValue(info.data)}`);\n        return true;\n    }\n    try {\n        const url = new URL(info.url);\n        const protocol = url.protocol === \"https:\" ? \"https\" : \"http\";\n        const port = url.port || (url.protocol === \"https:\" ? 443 : 80);\n        const args = [\n            \"-e\",\n            `\n      const http = require('${protocol}');\n      const options = {\n        hostname: '${url.hostname}',\n        path: '${url.pathname}${url.search}',\n        port: ${port},\n        method: '${info.method}',\n        headers: ${JSON.stringify(info.headers)}\n      };\n\n      const req = http.request(options, (res) => {\n        res.on('data', () => {});\n        res.on('end', () => {\n          process.exit(0);\n        });\n      });\n\n      req.on('error', () => {\n        process.exit(0);\n      });\n\n      req.write(JSON.stringify(${JSON.stringify(info.data)}));\n      req.end();\n      `,\n        ];\n        // Use spawn with detached option instead of spawnSync to make it non-blocking\n        const { spawn } = __webpack_require__(/*! child_process */ \"child_process\");\n        spawn(\"node\", args, {\n            stdio: \"ignore\",\n            detached: true,\n            shell: false,\n        }).unref();\n        return true;\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\n/**\n * Sends a reporting payload to the telemetry server using XMLHttpRequest.\n * This function is intended for use in browser environments.\n *\n * @param {any} reportingPayload - The payload to be sent to the telemetry server.\n */\nfunction sendBrowserReq(info) {\n    if (IS_DEVELOPMENT_OR_CI) {\n        logger.debug(`Hitting ${info.url}[${info.method}] with ${serializeValue(info.data)}`);\n        return true;\n    }\n    try {\n        // Create a new XMLHttpRequest object\n        const xhr = new XMLHttpRequest();\n        // Open a new POST request to the telemetry server\n        xhr.open(info.method, info.url, true);\n        // Set the request header to indicate JSON content\n        xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n        Object.entries(info.headers || {}).forEach(([key, value]) => {\n            xhr.setRequestHeader(key, value);\n        });\n        // Define the onload event handler\n        xhr.onload = function () {\n            // Log the response if the request was successful\n            if (xhr.status === 200) {\n                logger.debug(xhr.response);\n            }\n        };\n        // Send the reporting payload as a JSON string\n        xhr.send(JSON.stringify(info.data));\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\n\n/*\n    ComposioContext class provides a global context for storing SDK configuration.\n    This singleton class maintains essential SDK settings like API key and base URL.\n    It is used to store the API key and base URL in a global context so that it can be accessed by other modules without having to pass the configuration around.\n\n    Warning: Can cause problems if there are multiple instances of the SDK running in the same process.\n*/\nclass ComposioSDKContext {\n}\nComposioSDKContext.source = \"javascript\";\n\nasync function logError(payload) {\n    const isTelemetryDisabled = getEnvVariable(\"TELEMETRY_DISABLED\", \"false\") === \"true\";\n    if (isTelemetryDisabled) {\n        return;\n    }\n    try {\n        const isBrowser = typeof window !== \"undefined\";\n        const reportingPayload = generateReportingPayload(payload);\n        const reqPayload = {\n            data: reportingPayload,\n            url: `${TELEMETRY_URL}/api/sdk_metrics/error`,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n        };\n        if (isBrowser) {\n            await sendBrowserReq(reqPayload);\n        }\n        else {\n            await sendProcessReq(reqPayload);\n        }\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\nfunction generateReportingPayload(payload) {\n    const { apiKey, baseURL, composioVersion, frameworkRuntime, source } = ComposioSDKContext;\n    const { error_id, error_code, description, message, possible_fix, original_error, current_stack, } = payload;\n    return {\n        error_id,\n        error_code,\n        description,\n        error_message: message,\n        possible_fix,\n        original_error,\n        current_stack,\n        sdk_meta: {\n            platform: process.platform,\n            version: composioVersion,\n            baseURL,\n            apiKey,\n            frameworkRuntime,\n            source,\n        },\n    };\n}\n\n/**\n * Custom error class for Composio that provides rich error details, tracking, and improved debugging\n */\nclass ComposioError extends Error {\n    constructor(errCode, message, description, possibleFix, metadata, originalError) {\n        var _a;\n        // Ensure message is never empty\n        super(message || \"An unknown error occurred\");\n        // additional metadata about the error\n        this.metadata = {};\n        // Ensure proper prototype chain for instanceof checks\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = \"ComposioError\";\n        this.errCode = errCode;\n        this.description = description;\n        this.possibleFix = possibleFix;\n        this.timestamp = new Date().toISOString();\n        this.metadata = metadata;\n        this.errorId = getUUID();\n        let originalErrorString = \"\";\n        // Only print original error if COMPOSIO_LOGGING_LEVEL is debug\n        if (originalError) {\n            try {\n                originalErrorString =\n                    typeof originalError === \"object\"\n                        ? JSON.parse(JSON.stringify(originalError))\n                        : originalError;\n            }\n            catch (_e) {\n                originalErrorString = String(originalError);\n            }\n            if (getLogLevel() === \"debug\") {\n                this._originalError = originalErrorString;\n            }\n        }\n        // Only in case of info or debug, we will log the error\n        if (LOG_LEVELS[getLogLevel()] >= 2) {\n            logger.info(`ðŸš€ [Info] Give Feedback / Get Help: https://dub.composio.dev/discord `);\n            logger.info(`ðŸ› [Info] Create a new issue: https://github.com/ComposioHQ/composio/issues `);\n            if (getLogLevel() !== \"debug\") {\n                logger.info(`â›” [Info] If you need to debug this error, set env variable COMPOSIO_LOGGING_LEVEL=debug`);\n            }\n        }\n        logError({\n            error_id: this.errorId,\n            error_code: this.errCode,\n            original_error: originalErrorString,\n            description: this.description || \"\",\n            metadata: this.metadata || {},\n            message: this.message,\n            possible_fix: this.possibleFix || \"\",\n            current_stack: ((_a = this.stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\")) || [],\n        });\n        // Capture stack trace, excluding constructor call\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get originalError() {\n        return this._originalError;\n    }\n    /**\n     * Returns a complete object representation for logging/serialization\n     * Includes all error details and metadata\n     */\n    toJSON() {\n        var _a, _b, _c;\n        const errorObj = {\n            name: this.name,\n            errorId: this.errorId,\n            code: this.errCode,\n            message: this.message,\n            description: this.description,\n            possibleFix: this.possibleFix,\n            timestamp: this.timestamp,\n            stack: (_a = this.stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\"),\n            originalStack: (_c = (_b = this.originalError) === null || _b === void 0 ? void 0 : _b.stack) === null || _c === void 0 ? void 0 : _c.split(\"\\n\"),\n        };\n        // Remove undefined/null properties\n        return Object.entries(errorObj).reduce((acc, [key, value]) => {\n            if (value !== undefined && value !== null) {\n                acc[key] = value;\n            }\n            return acc;\n        }, {});\n    }\n}\n\nconst COMPOSIO_SDK_ERROR_CODES = {\n    BACKEND: {\n        NOT_FOUND: \"BACKEND::NOT_FOUND\",\n        RATE_LIMIT: \"BACKEND::RATE_LIMIT\",\n        BAD_REQUEST: \"BACKEND::BAD_REQUEST\",\n        UNAUTHORIZED: \"BACKEND::UNAUTHORIZED\",\n        SERVER_ERROR: \"BACKEND::SERVER_ERROR\",\n        SERVER_UNAVAILABLE: \"BACKEND::SERVER_UNAVAILABLE\",\n        SERVER_UNREACHABLE: \"BACKEND::SERVER_UNREACHABLE\",\n        UNKNOWN: \"BACKEND::UNKNOWN\",\n    },\n    COMMON: {\n        API_KEY_UNAVAILABLE: \"COMMON::API_KEY_INVALID\",\n        BASE_URL_NOT_REACHABLE: \"COMMON::BASE_URL_NOT_REACHABLE\",\n        UNKNOWN: \"COMMON::ERROR_CODE_NOT_DEFINED\",\n        SERVER_UNAVAILABLE: \"COMMON::SERVER_UNAVAILABLE\",\n        REQUEST_TIMEOUT: \"COMMON::REQUEST_TIMEOUT\",\n        REQUEST_ABORTED: \"COMMON::REQUEST_ABORTED\",\n        INVALID_PARAMS_PASSED: \"COMMON::INVALID_PARAMS_PASSED\",\n    },\n    SDK: {\n        NO_CONNECTED_ACCOUNT_FOUND: \"SDK::NO_CONNECTED_ACCOUNT_FOUND\",\n        FAILED_TO_INITIATE_CONNECTION: \"SDK::FAILED_TO_INITIATE_CONNECTION\",\n        INVALID_PARAMETER: \"SDK::INVALID_PARAMETER\",\n    },\n};\nconst BASE_ERROR_CODE_INFO = {\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND]: {\n        message: \"ðŸ” API not found\",\n        description: \"The requested resource is missing\",\n        possibleFix: \"Ensure the resource id or resource identifier is correct and valid as backend returned 404\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST]: {\n        message: \"ðŸš« Bad Request. The request was malformed or incorrect\",\n        description: null,\n        possibleFix: \"Check your parameters and request format, as the backend returned a 400 error.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED]: {\n        message: \"ðŸ”‘ Access Denied\",\n        description: \"You do not have the necessary credentials.\",\n        possibleFix: \"Ensure your API key is correct and has the required permissions.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT]: {\n        message: \"ðŸ•’ Request Timeout\",\n        description: \"The request timed out while waiting for a response.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support or check your network connection.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR]: {\n        message: \"ðŸ’¥ Oops! Internal server error\",\n        description: \"Your request could not be processed due to an internal server error.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT]: {\n        message: \"â±ï¸ API Rate Limit Exceeded\",\n        description: \"You have exceeded the rate limit for requests.\",\n        possibleFix: \"Please wait a bit before trying your request again.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE]: {\n        message: \"ðŸ”‘ API Key Missing or Invalid\",\n        description: \"The API key provided is missing or incorrect.\",\n        possibleFix: \"Ensure that your API key is passed to client or set in COMPOSIO_API_KEY environment variable.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE]: {\n        message: \"ðŸš« Server Unavailable\",\n        description: \"The server is currently unable to handle the request.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE]: {\n        message: \"ðŸ”— Base URL is not valid\",\n        description: \"The base URL provided is not valid.\",\n        possibleFix: \"Ensure that the base URL is correct and accessible.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED]: {\n        message: \"ðŸ•’ Invalid parameters passed\",\n        description: \"The parameters passed are invalid\",\n        possibleFix: \"Please check the error message for more details\",\n    },\n    UNKNOWN: {\n        message: null,\n        description: null,\n        possibleFix: \"Contact our support team with the error details for further assistance.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN]: {\n        message: null,\n        description: null,\n        possibleFix: \"Contact our support team with the error details for further assistance.\",\n    },\n};\nconst API_TO_SDK_ERROR_CODE = {\n    400: COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST,\n    401: COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED,\n    404: COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND,\n    408: COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT,\n    429: COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT,\n    500: COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR,\n    502: COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE,\n};\n\nconst getAPIErrorDetails = (axiosError) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    const statusCode = (_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.status;\n    const errorCode = statusCode\n        ? API_TO_SDK_ERROR_CODE[statusCode]\n        : COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN;\n    const predefinedError = BASE_ERROR_CODE_INFO[errorCode];\n    const defaultErrorDetails = {\n        message: axiosError.message,\n        description: ((_c = (_b = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.message) || axiosError.message,\n        possibleFix: \"Please check the parameters you are passing to the API\",\n    };\n    const metadata = generateMetadataFromAxiosError(axiosError);\n    const errorNameFromBE = (_e = (_d = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.name;\n    const errorTypeFromBE = (_g = (_f = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.type;\n    const errorMessage = (_j = (_h = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.message;\n    let genericMessage = \"\";\n    const hasNotReceivedResponseFromBE = errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNREACHABLE;\n    if (hasNotReceivedResponseFromBE) {\n        genericMessage = predefinedError.message;\n    }\n    else if (((_k = axiosError.config) === null || _k === void 0 ? void 0 : _k.baseURL) && ((_l = axiosError.config) === null || _l === void 0 ? void 0 : _l.url)) {\n        genericMessage = `${errorNameFromBE || predefinedError.message} ${errorTypeFromBE ? `- ${errorTypeFromBE}` : \"\"} on ${((_m = axiosError.config) === null || _m === void 0 ? void 0 : _m.baseURL) + ((_o = axiosError.config) === null || _o === void 0 ? void 0 : _o.url)}`;\n    }\n    switch (errorCode) {\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST:\n            const validationErrors = (_q = (_p = axiosError.response) === null || _p === void 0 ? void 0 : _p.data) === null || _q === void 0 ? void 0 : _q.details;\n            const formattedErrors = Array.isArray(validationErrors)\n                ? validationErrors.map((err) => JSON.stringify(err)).join(\", \")\n                : JSON.stringify(validationErrors);\n            return {\n                message: genericMessage,\n                description: `Validation Errors: ${formattedErrors}`,\n                possibleFix: \"Please check the request parameters and ensure they are correct.\",\n                metadata,\n            };\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN:\n            return {\n                message: genericMessage,\n                description: errorMessage || predefinedError.description,\n                possibleFix: predefinedError.possibleFix ||\n                    defaultErrorDetails.possibleFix,\n                metadata,\n            };\n        default:\n            const message = genericMessage || axiosError.message;\n            const description = errorMessage || predefinedError.description;\n            const possibleFix = predefinedError.possibleFix ||\n                defaultErrorDetails.possibleFix ||\n                \"\";\n            return {\n                message,\n                description,\n                possibleFix,\n                metadata,\n            };\n    }\n};\nconst generateMetadataFromAxiosError = (axiosError) => {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { requestId, ...restMetadata } = axiosError.metadata || {};\n    return {\n        fullUrl: ((_b = (_a = axiosError.config) === null || _a === void 0 ? void 0 : _a.baseURL) !== null && _b !== void 0 ? _b : \"\") + ((_d = (_c = axiosError.config) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : \"\"),\n        method: ((_f = (_e = axiosError.config) === null || _e === void 0 ? void 0 : _e.method) !== null && _f !== void 0 ? _f : \"\").toUpperCase(),\n        statusCode: (_g = axiosError.response) === null || _g === void 0 ? void 0 : _g.status,\n        requestId: requestId ? `${requestId}` : undefined,\n        metadata: restMetadata,\n    };\n};\n\nclass CEG {\n    static handleAllError(error, shouldThrow = false) {\n        if (error instanceof ComposioError) {\n            if (shouldThrow) {\n                throw error;\n            }\n            return error;\n        }\n        if (!(error instanceof Error)) {\n            const error = new Error(\"Passed error is not an instance of Error\");\n            if (shouldThrow) {\n                throw error;\n            }\n            return error;\n        }\n        if (error instanceof z.ZodError) {\n            const zodError = this.returnZodError(error);\n            if (shouldThrow) {\n                throw zodError;\n            }\n            return zodError;\n        }\n        const isAxiosError = error.isAxiosError;\n        if (!isAxiosError) {\n            const customError = this.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.UNKNOWN, {\n                message: error.message,\n                description: \"\",\n                possibleFix: \"Please check error message and stack trace\",\n                originalError: error,\n                metadata: {},\n            });\n            if (shouldThrow) {\n                throw customError;\n            }\n            return customError;\n        }\n        else {\n            const isResponseNotPresent = !(\"response\" in error);\n            if (isResponseNotPresent) {\n                const nonResponseError = this.handleNonResponseAxiosError(error);\n                if (shouldThrow) {\n                    throw nonResponseError;\n                }\n                return nonResponseError;\n            }\n            const apiError = this.throwAPIError(error);\n            if (shouldThrow) {\n                throw apiError;\n            }\n            return apiError;\n        }\n    }\n    static handleNonResponseAxiosError(error) {\n        var _a, _b;\n        const fullUrl = (((_a = error.config) === null || _a === void 0 ? void 0 : _a.baseURL) || \"\") + (((_b = error.config) === null || _b === void 0 ? void 0 : _b.url) || \"\");\n        const metadata = generateMetadataFromAxiosError(error);\n        if (error.code === \"ECONNREFUSED\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE, `ECONNREFUSED for ${fullUrl}`, \"\", \"Make sure:\\n1. The base URL is correct and is accessible\\n2. Your network connection is stable\\n3. There are no firewall rules blocking the connection\", metadata, error);\n        }\n        if (error.code === \"ETIMEDOUT\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT, `ECONNABORTED for ${fullUrl}`, `Request to ${fullUrl} timed out after the configured timeout period. This could be due to slow network conditions, server performance issues, or the request being too large. Error code: ETIMEDOUT`, \"Try:\\n1. Checking your network speed and stability\\n2. Increasing the request timeout setting if needed\\n3. Breaking up large requests into smaller chunks\\n4. Retrying the request when network conditions improve\\n5. Contact tech@composio.dev if the issue persists\", metadata, error);\n        }\n        if (error.code === \"ECONNABORTED\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_ABORTED, error.message, \"The request was aborted due to a timeout or other network-related issues. This could be due to network instability, server issues, or the request being too large. Error code: ECONNABORTED\", \"Try:\\n1. Checking your network speed and stability\\n2. Increasing the request timeout setting if needed\\n3. Breaking up large requests into smaller chunks\\n4. Retrying the request when network conditions improve\\n5. Contact tech@composio.dev if the issue persists\", metadata, error);\n        }\n        throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNREACHABLE, error.message ||\n            \"Server is unreachable. Please contact tech@composio.dev with the error details.\", \"Server is unreachable. Please contact tech@composio.dev with the error details.\", \"Please contact tech@composio.dev with the error details.\", metadata, error);\n    }\n    static throwAPIError(error) {\n        var _a;\n        const statusCode = ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) || null;\n        const errorCode = statusCode\n            ? API_TO_SDK_ERROR_CODE[statusCode] ||\n                COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN\n            : COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN;\n        const errorDetails = getAPIErrorDetails(error);\n        const metadata = generateMetadataFromAxiosError(error);\n        throw new ComposioError(errorCode, errorDetails.message, errorDetails.description, errorDetails.possibleFix, metadata, error);\n    }\n    static returnZodError(error) {\n        const errorCode = COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED;\n        const errorMessage = error.message;\n        const errorDescription = \"The parameters passed are invalid\";\n        const possibleFix = \"Please check error message for more details\";\n        const metadata = {\n            issues: error.issues,\n        };\n        return new ComposioError(errorCode, errorMessage, errorDescription, possibleFix, metadata, error);\n    }\n    static getCustomError(messageCode, { message, type, subtype, description, possibleFix, originalError, metadata, }) {\n        const finalErrorCode = !!messageCode ? messageCode : `${type}::${subtype}`;\n        const errorDetails = BASE_ERROR_CODE_INFO[finalErrorCode] || BASE_ERROR_CODE_INFO.UNKNOWN;\n        const finalMessage = message || errorDetails.message || \"\";\n        const finalDescription = description || errorDetails.description || undefined;\n        const finalPossibleFix = possibleFix || errorDetails.possibleFix || \"\";\n        throw new ComposioError(messageCode, finalMessage, finalDescription, finalPossibleFix, metadata, originalError);\n    }\n}\n\nclass BatchProcessor {\n    constructor(time = 2000, batchSize = 100, processBatchCallback) {\n        this.batch = [];\n        this.timer = null;\n        this.batch = [];\n        this.time = time;\n        this.batchSize = batchSize;\n        this.processBatchCallback = processBatchCallback;\n    }\n    pushItem(item) {\n        this.batch.push(item);\n        if (this.batch.length >= this.batchSize) {\n            this.processBatch();\n        }\n        else if (!this.timer) {\n            this.timer = setTimeout(() => this.processBatch(), this.time);\n        }\n    }\n    processBatch() {\n        if (this.batch.length > 0) {\n            this.processBatchCallback(this.batch);\n            this.batch = [];\n        }\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    }\n}\n\nvar _a;\nclass TELEMETRY_LOGGER {\n    static createTelemetryWrapper(method, className) {\n        return async (...args) => {\n            const payload = {\n                eventName: method.name,\n                data: { className, args },\n                sdk_meta: {\n                    apiKey: ComposioSDKContext.apiKey,\n                    baseURL: ComposioSDKContext.baseURL,\n                    composioVersion: ComposioSDKContext.composioVersion,\n                    frameworkRuntime: ComposioSDKContext.frameworkRuntime,\n                    source: ComposioSDKContext.source,\n                    sessionId: ComposioSDKContext.sessionId,\n                    isBrowser: typeof window !== \"undefined\",\n                },\n            };\n            _a.batchProcessor.pushItem(payload);\n            return method(...args);\n        };\n    }\n    static async sendTelemetry(payload) {\n        const isTelemetryDisabled = getEnvVariable(\"TELEMETRY_DISABLED\", \"false\") === \"true\";\n        if (isTelemetryDisabled) {\n            return;\n        }\n        const url = `${TELEMETRY_URL}/api/sdk_metrics/telemetry`;\n        const reqPayload = {\n            data: payload,\n            url,\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n        };\n        const isBrowser = typeof window !== \"undefined\";\n        if (isBrowser) {\n            await sendBrowserReq(reqPayload);\n        }\n        else {\n            await sendProcessReq(reqPayload);\n        }\n    }\n    static manualTelemetry(eventName, data) {\n        const payload = {\n            eventName,\n            data,\n            sdk_meta: {\n                apiKey: ComposioSDKContext.apiKey,\n                baseURL: ComposioSDKContext.baseURL,\n                composioVersion: ComposioSDKContext.composioVersion,\n                frameworkRuntime: ComposioSDKContext.frameworkRuntime,\n                source: ComposioSDKContext.source,\n                isBrowser: typeof window !== \"undefined\",\n            },\n        };\n        _a.batchProcessor.pushItem(payload);\n    }\n    static wrapFunctionForTelemetry(func, className) {\n        return _a.createTelemetryWrapper(func, className);\n    }\n}\n_a = TELEMETRY_LOGGER;\nTELEMETRY_LOGGER.batchProcessor = new BatchProcessor(100, 10, async (data) => {\n    await _a.sendTelemetry(data);\n});\n\nvar TELEMETRY_EVENTS;\n(function (TELEMETRY_EVENTS) {\n    TELEMETRY_EVENTS[\"SDK_INITIALIZED\"] = \"SDK_INITIALIZED\";\n    TELEMETRY_EVENTS[\"SDK_METHOD_INVOKED\"] = \"SDK_METHOD_INVOKED\";\n    TELEMETRY_EVENTS[\"CLI_INVOKED\"] = \"CLI_INVOKED\";\n})(TELEMETRY_EVENTS || (TELEMETRY_EVENTS = {}));\n\n// This file is auto-generated by @hey-api/openapi-ts\nconst client = clientAxios.createClient(clientAxios.createConfig());\nclass ClientService {\n    /**\n     * Get user info\n     * Get client info\n     */\n    static getUserInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/client_info\",\n        });\n    }\n    /**\n     * Add new project\n     * Add a new project to the client's organization\n     */\n    static addProject(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/client/auth/project/add\",\n        });\n    }\n    /**\n     * Delete project\n     * Delete a project from the client's organization\n     */\n    static deleteProject(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/client/auth/project/delete/{projectId}\",\n        });\n    }\n    /**\n     * Get projects\n     */\n    static getProjects(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/projects\",\n        });\n    }\n    /**\n     * Get org api key\n     */\n    static getOrgApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/org/api_key\",\n        });\n    }\n    /**\n     * Regenerate org api key\n     */\n    static regenerateOrgApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/client/auth/org/api_key/regenerate\",\n        });\n    }\n}\nclass ApiKeysService {\n    /**\n     * Generate api key\n     */\n    static generateApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/api_keys\",\n        });\n    }\n    /**\n     * List api keys\n     */\n    static listApiKeys(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/api_keys\",\n        });\n    }\n    /**\n     * Delete api key\n     */\n    static deleteApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/api_keys/{id}\",\n        });\n    }\n}\nclass AppsService {\n    /**\n     * List app categories\n     * List of available app categories, can be used to filter apps.\n     */\n    static listAppCategories(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/list/categories\",\n        });\n    }\n    /**\n     * List app enums\n     * List app enums\n     */\n    static listAppEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/list/enums\",\n        });\n    }\n    /**\n     * List apps\n     * List all apps based on the given filters, if any. This will return all available apps if no filters are provided.\n     */\n    static getApps(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps\",\n        });\n    }\n    /**\n     * Get single app\n     * Get app details\n     */\n    static getApp(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/{appName}\",\n        });\n    }\n}\nclass IntegrationsService {\n    /**\n     * Create connector\n     * Create a new connector\n     */\n    static createConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/integrations\",\n        });\n    }\n    /**\n     * List all connectors\n     * List all connectors\n     */\n    static listAllConnectors(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/integrations\",\n        });\n    }\n    /**\n     * Get connector info\n     * Get connector info\n     */\n    static getConnectorInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n    /**\n     * Modify connector\n     * Modify a connector\n     */\n    static modifyConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n    /**\n     * Delete connector\n     * Delete a connector\n     */\n    static deleteConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n}\nclass ActionsService {\n    /**\n     * List action enums\n     * List action enums\n     */\n    static listActionEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/actions/list/enums\",\n        });\n    }\n    /**\n     * List action tags\n     * List all the action tags available in composio\n     */\n    static listActionTags(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/tags\",\n        });\n    }\n    /**\n     * List action enums\n     * List action enums\n     */\n    static listActionEnums1(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/enums\",\n        });\n    }\n    /**\n     * List actions with complete details\n     * List and filter all the actions available in composio, with all the details needed for manual action execution or through function-calling.\n     */\n    static listActionsV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions\",\n        });\n    }\n    /**\n     * List actions\n     * Retrieve a list of all actions based on query parameters.\n     */\n    static listActionsMinimalV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/all\",\n        });\n    }\n    /**\n     * Execute an action\n     * Execute an action. Support both connected account and no auth auth.\n     */\n    static executeActionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/{actionId}/execute\",\n        });\n    }\n    /**\n     * Get action inputs\n     * Get the inputs for an action with NLA\n     */\n    static getActionInputsV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/{actionId}/execute/get.inputs\",\n        });\n    }\n    /**\n     * Get single action\n     * Get action details, including the input and response schema. This is very useful for setting upfunction/tool calling with composio actions.\n     */\n    static getActionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/{actionId}\",\n        });\n    }\n    /**\n     * Execute with HTTP Client\n     * Use composio as a http client to make request to the connected account service on your behalf, without managing authentication on your side.\n     */\n    static executeWithHttpClient(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/proxy\",\n        });\n    }\n    /**\n     * Advanced use case search\n     * Perform use case search.\n     */\n    static advancedUseCaseSearch(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/search/advanced\",\n        });\n    }\n    /**\n     * List user files\n     */\n    static v2ListUserFiles(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/files/list\",\n        });\n    }\n    /**\n     * Create file upload url\n     * Create file upload URL for action execution.\n     */\n    static createFileUploadUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/files/upload/{fileType}\",\n        });\n    }\n}\nclass ConnectionsService {\n    /**\n     * List connections\n     * Get all connections in the current project.\n     */\n    static listConnections(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts\",\n        });\n    }\n    /**\n     * Initiate connection\n     */\n    static initiateConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts\",\n        });\n    }\n    /**\n     * Update connection data\n     * Update connection data\n     */\n    static updateConnectionData(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/data\",\n        });\n    }\n    /**\n     * Reinitiate connection\n     * Reinitiate an existing connection to get new credentials\n     */\n    static reinitiateConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/reinitiate\",\n        });\n    }\n    /**\n     * Get single connection\n     */\n    static getConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}\",\n        });\n    }\n    /**\n     * Delete connection\n     * Delete a connection\n     */\n    static deleteConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}\",\n        });\n    }\n    /**\n     * Get Auth credentials\n     * Get authentication crdentials for the connected account, i.e all the headers, query parameters, etc. that are required to make requests to the third-party service directly.\n     */\n    static getConnectionInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/info\",\n        });\n    }\n    /**\n     * Disable connection\n     * Disable a connection\n     */\n    static disableConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/disable\",\n        });\n    }\n    /**\n     * Enable connection\n     * Enable a connection\n     */\n    static enableConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/enable\",\n        });\n    }\n}\nclass TriggersService {\n    /**\n     * List triggers\n     * List triggers\n     */\n    static listTriggers(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers\",\n        });\n    }\n    /**\n     * List trigger enums\n     * List trigger enums\n     */\n    static listTriggerEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/list/enums\",\n        });\n    }\n    /**\n     * Update new webhook\n     * Update isNewWebhook\n     */\n    static updateNewWebhook(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/update_webhook_format\",\n        });\n    }\n    /**\n     * Enable trigger\n     * Enables a trigger for a connected account and specific trigger name.\n     */\n    static enableTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/enable/{connectedAccountId}/{triggerName}\",\n        });\n    }\n    /**\n     * Get active triggers\n     * Lists active triggers based on query parameters.\n     */\n    static getActiveTriggers(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/active_triggers\",\n        });\n    }\n    /**\n     * Switch trigger instance status\n     * Switches the status of a trigger instance.\n     */\n    static switchTriggerInstanceStatus(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/triggers/instance/{triggerId}/status\",\n        });\n    }\n    /**\n     * Disable trigger\n     * Disables a specified trigger instance.\n     */\n    static disableTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/disable/{triggerInstanceId}\",\n        });\n    }\n    /**\n     * Delete trigger\n     * Deletes a specified trigger instance.\n     */\n    static deleteTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/triggers/instance/{triggerInstanceId}\",\n        });\n    }\n    /**\n     * Set callback url\n     * Sets a universal callback URL for the client.\n     */\n    static setCallbackUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/set_callback_url\",\n        });\n    }\n    /**\n     * Get webhook url\n     * Retrieves the universal callback URL set for the client.\n     */\n    static getWebhookUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/callback_url\",\n        });\n    }\n    /**\n     * Get logs\n     * Fetches logs based on connection and integration details.\n     */\n    static getTriggerLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/logs\",\n        });\n    }\n    /**\n     * Get trigger info\n     * Get Trigger Info\n     */\n    static getTriggerInfoV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/triggers/{triggerName}\",\n        });\n    }\n}\nclass CliService {\n    /**\n     * Handle cli code exchange\n     */\n    static generateCliSession(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/generate-cli-session\",\n        });\n    }\n    /**\n     * Get cli code\n     */\n    static getCliCode(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/get-cli-code\",\n        });\n    }\n    /**\n     * Handle cli code verification\n     */\n    static verifyCliCode(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/verify-cli-code\",\n        });\n    }\n}\nclass LogsService {\n    /**\n     * Get logs\n     * List logs\n     */\n    static getLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/logs/\",\n        });\n    }\n    /**\n     * Post logs\n     * Add new logs\n     */\n    static postLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/logs/\",\n        });\n    }\n}\nclass IntegrationsV2Service {\n    /**\n     * Search connector\n     * Search for a connector\n     */\n    static searchConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/search-by-filters\",\n        });\n    }\n    /**\n     * Create connector\n     * Create a new connector\n     */\n    static createConnectorV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/create\",\n        });\n    }\n    /**\n     * Get or create connector\n     * Get or create a connector\n     */\n    static getOrCreateConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/get-or-create\",\n        });\n    }\n}\nclass Connectionsv2Service {\n    /**\n     * Initiate connection\n     */\n    static initiateConnectionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/connectedAccounts/initiateConnection\",\n        });\n    }\n}\n\nvar apiClient = {\n    logs: LogsService,\n    actionsV1: ActionsService,\n    actionsV2: ActionsService,\n    apiKeys: ApiKeysService,\n    clientAuth: ClientService,\n    cli: CliService,\n    appConnector: IntegrationsService,\n    appConnectorV2: IntegrationsV2Service,\n    apps: AppsService,\n    connections: ConnectionsService,\n    connectionsV2: Connectionsv2Service,\n    triggers: TriggersService,\n};\n\nconst ZActionGetParams = z.z.object({\n    actionName: z.z.string(),\n});\nconst ZGetListActionsParams = z.z.object({\n    apps: z.z.string().optional().describe(\"Comma separated app names\"),\n    actions: z.z.string().optional().describe(\"Comma separated action names\"),\n    tags: z.z.string().optional().describe(\"Comma separated tag names\"),\n    useCase: z.z.string().nullable().optional().describe(\"Use case name\"),\n    usecaseLimit: z.z.number().optional().describe(\"Limit for use case\"),\n    showAll: z.z.boolean().optional().describe(\"Show all actions\"),\n    showEnabledOnly: z.z.boolean().optional().describe(\"Show enabled actions\"),\n    filterImportantActions: z.z\n        .boolean()\n        .optional()\n        .describe(\"Filter important actions\"),\n    filterByAvailableApps: z.z\n        .boolean()\n        .optional()\n        .describe(\"Filter actions by available apps\"),\n});\nconst ZParameter = z.z.object({\n    name: z.z.string(),\n    in: z.z.enum([\"query\", \"header\"]),\n    value: z.z.string(),\n});\nconst ZCustomAuthParams = z.z.object({\n    base_url: z.z.string().optional(),\n    parameters: z.z.array(ZParameter),\n    body: z.z.record(z.z.unknown()).optional(),\n});\nconst ZExecuteParams = z.z.object({\n    actionName: z.z.string(),\n    requestBody: z.z.object({\n        connectedAccountId: z.z.string().optional(),\n        input: z.z.record(z.z.unknown()).optional(),\n        appName: z.z.string().optional(),\n        text: z.z.string().optional(),\n        authConfig: ZCustomAuthParams.optional(),\n        allowTracing: z.z.boolean().optional(),\n        sessionInfo: z.z\n            .object({\n            sessionId: z.z.string().optional(),\n        })\n            .optional(),\n    }),\n});\nconst ZFindActionEnumsByUseCaseParams = z.z.object({\n    apps: z.z.array(z.z.string()),\n    useCase: z.z.string(),\n    limit: z.z.number().optional(),\n    filterByAvailableApps: z.z.boolean().optional(),\n});\nconst ZExecuteRequestParams = z.z.object({\n    connectedAccountId: z.z.string(),\n    endpoint: z.z.string(),\n    method: z.z.enum([\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]),\n    parameters: z.z.array(ZParameter),\n    body: z.z.record(z.z.unknown()).optional(),\n});\n\nclass Actions {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/actions.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves details of a specific action in the Composio platform by providing its action name.\n     *\n     * The response includes the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetActionData} data The data for the request.\n     * @returns {Promise<ActionItemGetRes[0]>} A promise that resolves to the details of the action.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZActionGetParams.parse(data);\n            const actions = await apiClient.actionsV2.getActionV2({\n                client: this.client,\n                path: {\n                    actionId: parsedData.actionName,\n                },\n            });\n            return actions.data;\n        }\n        catch (e) {\n            throw CEG.handleAllError(e);\n        }\n    }\n    /**\n     * Retrieves a list of all actions in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available actions. It supports pagination to handle large numbers of actions. The response includes an array of action objects, each containing information such as the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetListActionsData} data The data for the request.\n     * @returns {Promise<ActionsListResponseDTO>} A promise that resolves to the list of all actions.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZGetListActionsParams.parse(data);\n            let apps = parsedData.apps;\n            // Throw error if user has provided both filterByAvailableApps and apps\n            if ((data === null || data === void 0 ? void 0 : data.filterByAvailableApps) && (data === null || data === void 0 ? void 0 : data.apps)) {\n                throw new Error(\"Both filterByAvailableApps and apps cannot be provided together\");\n            }\n            if (data === null || data === void 0 ? void 0 : data.filterByAvailableApps) {\n                // Todo: To create a new API to get all integrated apps for a user instead of fetching all apps\n                const integratedApps = await apiClient.appConnector.listAllConnectors();\n                apps = (_a = integratedApps.data) === null || _a === void 0 ? void 0 : _a.items.map((app) => app === null || app === void 0 ? void 0 : app.appName).join(\",\");\n            }\n            const response = await apiClient.actionsV2.listActionsV2({\n                client: this.client,\n                query: {\n                    actions: data.actions,\n                    apps: apps,\n                    showAll: data.showAll,\n                    tags: data.tags,\n                    filterImportantActions: data.filterImportantActions,\n                    showEnabledOnly: data.showEnabledOnly,\n                    usecaseLimit: data.usecaseLimit || undefined,\n                    useCase: data.useCase,\n                },\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Executes a specific action in the Composio platform.\n     * This doesn't execute the local action and is wrapper over backend. Try to call this method directly from toolset\n     *\n     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.\n     *\n     * @param {ExecuteActionData} data The data for the request.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.\n     * @throws {ComposioError} If the request fails.\n     */\n    async execute(data) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"execute\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZExecuteParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.executeActionV2({\n                client: this.client,\n                body: {\n                    ...parsedData.requestBody,\n                    sessionInfo: {\n                        ...(((_a = parsedData.requestBody) === null || _a === void 0 ? void 0 : _a.sessionInfo) || {}),\n                        sessionId: ((_c = (_b = parsedData.requestBody) === null || _b === void 0 ? void 0 : _b.sessionInfo) === null || _c === void 0 ? void 0 : _c.sessionId) ||\n                            ComposioSDKContext.sessionId,\n                    },\n                    allowTracing: Boolean(ComposioSDKContext === null || ComposioSDKContext === void 0 ? void 0 : ComposioSDKContext.allowTracing),\n                },\n                path: {\n                    actionId: parsedData.actionName,\n                },\n            });\n            return res;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Finds all action enums by use case.\n     *\n     * @param {FindActionEnumsByUseCaseParam} data The data for the request.\n     * @returns {Promise<ActionFindActionEnumsByUseCaseRes>} A promise that resolves to the list of action enums.\n     * @throws {ComposioError} If the request fails.\n     */\n    async findActionEnumsByUseCase(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"findActionEnumsByUseCase\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZFindActionEnumsByUseCaseParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.advancedUseCaseSearch({\n                client: this.client,\n                query: {\n                    apps: (_a = parsedData.apps) === null || _a === void 0 ? void 0 : _a.join(\",\"),\n                    limit: parsedData.limit || undefined,\n                    filterByAvailableApps: parsedData.filterByAvailableApps,\n                },\n                body: {\n                    useCase: parsedData.useCase,\n                },\n            });\n            return res.items.map((item) => item.actions).flat() || [];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Executes a action using Composio Proxy\n     *\n     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.\n     *\n     * @param {ExecuteActionData} data The data for the request.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.\n     * @throws {ComposioError} If the request fails.\n     */\n    async executeRequest(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeRequest\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZExecuteRequestParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.executeWithHttpClient({\n                client: this.client,\n                body: {\n                    connectedAccountId: parsedData.connectedAccountId,\n                    endpoint: parsedData.endpoint,\n                    method: parsedData.method,\n                    parameters: parsedData.parameters,\n                    body: parsedData.body,\n                },\n            });\n            return res;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst ZTriggerItemParam = z.z.object({\n    triggerId: z.z.string(),\n});\nconst ZActiveTriggersQuery = z.z.object({\n    triggerIds: z.z.string().optional(),\n    triggerNames: z.z.string().optional(),\n    connectedAccountIds: z.z.string().optional(),\n    integrationIds: z.z.string().optional(),\n    limit: z.z.number().optional(),\n    page: z.z.number().optional(),\n    showDisabled: z.z.boolean().optional(),\n});\nconst ZConnection = z.z.object({\n    id: z.z.string(),\n    integrationId: z.z.string(),\n    memberId: z.z.string(),\n    clientUniqueUserId: z.z.string(),\n    status: z.z.string(),\n    data: z.z.record(z.z.unknown()),\n    deleted: z.z.boolean().optional(),\n    enabled: z.z.boolean(),\n    labels: z.z.array(z.z.unknown()),\n    createdAt: z.z.string(),\n    updatedAt: z.z.string(),\n});\nz.z.object({\n    id: z.z.string(),\n    connectionId: z.z.string(),\n    triggerName: z.z.string(),\n    triggerData: z.z.string(),\n    triggerConfig: z.z.record(z.z.unknown()),\n    state: z.z.record(z.z.unknown()),\n    createdAt: z.z.string(),\n    updatedAt: z.z.string(),\n    disabledAt: z.z.string().nullable(),\n    disabledReason: z.z.string().nullable(),\n    connection: ZConnection,\n});\n\nclass ActiveTriggers {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/activeTriggers.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /** Missing type */\n    /**\n     * Retrieves details of a specific active trigger in the Composio platform by providing its trigger name.\n     *\n     * The response includes the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<TriggerItemRes>} A promise that resolves to the details of the active trigger.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get({ triggerId }) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { triggerId },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse({ triggerId });\n            const { data } = await apiClient.triggers.getActiveTriggers({\n                client: this.client,\n                query: {\n                    triggerIds: `${parsedData.triggerId}`,\n                },\n            });\n            return (_a = data === null || data === void 0 ? void 0 : data.triggers) === null || _a === void 0 ? void 0 : _a[0];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves a list of all active triggers in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available active triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetActiveTriggersData} data The data for the request.\n     * @returns {Promise<ZActiveTriggerItemRes[]>} A promise that resolves to the list of all active triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZActiveTriggersQuery.parse(data);\n            const { data: response } = await apiClient.triggers.getActiveTriggers({\n                client: this.client,\n                query: parsedData,\n            });\n            return response === null || response === void 0 ? void 0 : response.triggers;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enables the previously disabled trigger.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<{status: string}>} A promise that resolves to the response of the enable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse(data);\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: { triggerId: parsedData.triggerId },\n                body: {\n                    enabled: true,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disables the previously enabled trigger.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<{status: string}>} A promise that resolves to the response of the disable request.\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse(data);\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: parsedData,\n                body: {\n                    enabled: false,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nz.z.object({\n    appKey: z.z.string(),\n});\nconst ZGetRequiredParams = z.z.object({\n    appId: z.z.string(),\n});\nconst ZGetRequiredParamsForAuthScheme = z.z.object({\n    appId: z.z.string(),\n    authScheme: z.z.string(),\n});\nconst ZRequiredParamsResponse = z.z.object({\n    required_fields: z.z.array(z.z.string()),\n    expected_from_user: z.z.array(z.z.string()),\n    optional_fields: z.z.array(z.z.string()),\n});\nz.z.object({\n    availableAuthSchemes: z.z.array(z.z.string()),\n    authSchemes: z.z.record(z.z.string(), ZRequiredParamsResponse),\n});\n\nclass Apps {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/apps.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all available apps in the Composio platform.\n     *\n     * This method allows clients to explore and discover the supported apps. It returns an array of app objects, each containing essential details such as the app's key, name, description, logo, categories, and unique identifier.\n     *\n     * @returns {Promise<AppItemListResponse[]>} A promise that resolves to the list of all apps.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list() {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const { data } = await apiClient.apps.getApps({\n                client: this.client,\n                query: {\n                    additionalFields: \"auth_schemes\",\n                },\n            });\n            return (data === null || data === void 0 ? void 0 : data.items) || [];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves details of a specific app in the Composio platform.\n     *\n     * This method allows clients to fetch detailed information about a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.\n     *\n     * @param {AppGetDataParams} data The data for the request, including the app's unique key.\n     * @returns {Promise<AppItemResponse>} A promise that resolves to the details of the app.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { data: response } = await apiClient.apps.getApp({\n                client: this.client,\n                path: {\n                    appName: data.appKey,\n                },\n            });\n            if (!response)\n                throw new Error(\"App not found\");\n            return response;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.\n     *\n     * @param {string} appId The unique key of the app.\n     * @returns {Promise<AppRequiredParamsFullResponse>} A promise that resolves to the required parameters for the app.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParams(appId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParams\",\n            file: this.fileName,\n            params: { appId },\n        });\n        try {\n            ZGetRequiredParams.parse({ appId });\n            const appData = await this.get({ appKey: appId });\n            if (!appData)\n                throw new Error(\"App not found\");\n            const authSchemes = appData.auth_schemes;\n            const availableAuthSchemes = authSchemes === null || authSchemes === void 0 ? void 0 : authSchemes.map((scheme) => scheme === null || scheme === void 0 ? void 0 : scheme.mode);\n            const authSchemesObject = {};\n            for (const scheme of authSchemes) {\n                const name = scheme.mode;\n                authSchemesObject[name] = {\n                    required_fields: [],\n                    optional_fields: [],\n                    expected_from_user: [],\n                };\n                scheme.fields.forEach((field) => {\n                    const isExpectedForIntegrationSetup = field.expected_from_customer === false;\n                    const isRequired = field.required;\n                    if (isExpectedForIntegrationSetup) {\n                        if (isRequired) {\n                            authSchemesObject[name].expected_from_user.push(field.name);\n                        }\n                        else {\n                            authSchemesObject[name].optional_fields.push(field.name);\n                        }\n                    }\n                    else {\n                        authSchemesObject[name].required_fields.push(field.name);\n                    }\n                });\n            }\n            return {\n                availableAuthSchemes,\n                authSchemes: authSchemesObject,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.\n     *\n     * @param {AppGetRequiredParamsForAuthSchemeParam} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<AppRequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParamsForAuthScheme({ appId, appName, authScheme, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParamsForAuthScheme\",\n            file: this.fileName,\n            params: { appId, authScheme },\n        });\n        try {\n            const finalAppId = appName || appId;\n            ZGetRequiredParamsForAuthScheme.parse({ appId: finalAppId, authScheme });\n            const params = await this.getRequiredParams(finalAppId);\n            return params.authSchemes[authScheme];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst ZConnectionStatus = z.z.enum([\"INITIATED\", \"ACTIVE\", \"FAILED\"]);\nconst ZListConnectionsData = z.z.object({\n    appNames: z.z.string().optional(),\n    appUniqueKeys: z.z.string().array().optional(),\n    connectionId: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n    integrationId: z.z.string().optional(),\n    labels: z.z.string().optional(),\n    page: z.z.number().optional(),\n    pageSize: z.z.number().optional(),\n    showActiveOnly: z.z.boolean().optional(),\n    showDisabled: z.z.boolean().optional(),\n    status: ZConnectionStatus.optional(),\n    user_uuid: z.z.string().optional(),\n});\nz.z.object({\n    connectionParams: z.z.record(z.z.string(), z.z.unknown()).optional(),\n    entityId: z.z.string().optional(),\n    labels: z.z.array(z.z.string()).optional(),\n    integrationId: z.z.string().optional(),\n    redirectUri: z.z.string().optional(),\n    authMode: ZAuthMode.optional(),\n    authConfig: z.z.record(z.z.string(), z.z.unknown()).optional(),\n    appName: z.z.string().optional(),\n});\nconst ZSaveUserAccessDataParam = z.z.object({\n    fieldInputs: z.z.record(z.z.string(), z.z.unknown()),\n    redirectUrl: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n});\nconst ZSingleConnectionParams = z.z.object({\n    connectedAccountId: z.z.string(),\n});\nz.z.object({\n    data: z.z.record(z.z.string(), z.z.unknown()),\n    integrationId: z.z.string(),\n    redirectUri: z.z.string().optional(),\n    userUuid: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n    labels: z.z.string().array().optional(),\n});\nconst ZReinitiateConnectionPayloadDto = z.z.object({\n    connectedAccountId: z.z.string(),\n    data: z.z.record(z.z.string(), z.z.unknown()),\n    redirectUri: z.z.string().optional(),\n});\n\n/**\n * Class representing connected accounts in the system.\n */\nclass ConnectedAccounts {\n    /**\n     * Initializes a new instance of the ConnectedAccounts class.\n     * @param {AxiosBackendClient} backendClient - The backend client instance.\n     */\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/connectedAccounts.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * List all connected accounts\n     * @param {ConnectedAccountsListData} data - The data for the connected accounts list\n     * @returns {Promise<ConnectedAccountListResponse>} - A promise that resolves to a list of connected accounts\n     */\n    async list(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appNames, appUniqueKeys } = ZListConnectionsData.parse(data);\n            const finalAppNames = appNames || (appUniqueKeys === null || appUniqueKeys === void 0 ? void 0 : appUniqueKeys.join(\",\"));\n            const res = await apiClient.connections.listConnections({\n                client: this.client,\n                query: {\n                    ...data,\n                    appNames: finalAppNames,\n                },\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Get a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<SingleConnectedAccountResponse>} - A promise that resolves to a single connected account\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.getConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Delete a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<SingleDeleteResponse>} - A promise that resolves when the connected account is deleted\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.deleteConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disable a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is disabled\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.disableConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return {\n                status: \"success\",\n                connectedAccountId: data.connectedAccountId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enable a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is enabled\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            await apiClient.connections.enableConnection({\n                client: this.client,\n                path: {\n                    connectedAccountId: data.connectedAccountId,\n                },\n                throwOnError: true,\n            });\n            return {\n                status: \"success\",\n                connectedAccountId: data.connectedAccountId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initiate a connection\n     * @param {InitiateConnectionDataReq} payload - The payload for the connection initiation\n     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request\n     */\n    async initiate(payload) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"initiate\",\n            file: this.fileName,\n            params: { payload },\n        });\n        try {\n            const connection = await apiClient.connectionsV2.initiateConnectionV2({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey: payload.appName,\n                        integrationId: payload.integrationId,\n                    },\n                    config: {\n                        name: payload.appName,\n                        useComposioAuth: !!payload.authMode && !!payload.authConfig,\n                        authScheme: payload.authMode,\n                        integrationSecrets: payload.authConfig,\n                    },\n                    connection: {\n                        entityId: payload.entityId,\n                        initiateData: payload.connectionParams || {},\n                        extra: {\n                            redirectURL: payload.redirectUri,\n                            labels: payload.labels || [],\n                        },\n                    },\n                },\n            });\n            const connectionResponse = (_a = connection === null || connection === void 0 ? void 0 : connection.data) === null || _a === void 0 ? void 0 : _a.connectionResponse;\n            return new ConnectionRequest({\n                connectionStatus: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.connectionStatus,\n                connectedAccountId: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.connectedAccountId,\n                redirectUri: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.redirectUrl,\n                client: this.client,\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Reinitiate a connection\n     * @param {ReinitiateConnectionPayload} data - The payload for the connection reinitialization\n     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request\n     */\n    async reinitiateConnection(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"reinitiateConnection\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZReinitiateConnectionPayloadDto.parse(data);\n            const connection = await apiClient.connections.reinitiateConnection({\n                client: this.client,\n                path: {\n                    connectedAccountId: data.connectedAccountId,\n                },\n                body: {\n                    data: data.data,\n                    redirectUri: data.redirectUri,\n                },\n            });\n            const res = connection.data;\n            return new ConnectionRequest({\n                connectionStatus: res === null || res === void 0 ? void 0 : res.connectionStatus,\n                connectedAccountId: res === null || res === void 0 ? void 0 : res.connectedAccountId,\n                redirectUri: res === null || res === void 0 ? void 0 : res.redirectUrl,\n                client: this.client,\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\nclass ConnectionRequest {\n    constructor({ connectionStatus, connectedAccountId, redirectUri, client, }) {\n        this.connectionStatus = connectionStatus;\n        this.connectedAccountId = connectedAccountId;\n        this.redirectUrl = redirectUri;\n        this.client = client;\n    }\n    async saveUserAccessData(data) {\n        try {\n            ZSaveUserAccessDataParam.parse(data);\n            const { data: connectedAccount } = await apiClient.connections.getConnection({\n                client: this.client,\n                path: { connectedAccountId: this.connectedAccountId },\n            });\n            if (!connectedAccount)\n                throw new Error(\"Connected account not found\");\n            return await apiClient.connections.initiateConnection({\n                client: this.client,\n                body: {\n                    integrationId: connectedAccount.integrationId,\n                    //@ts-ignore\n                    data: data.fieldInputs,\n                    redirectUri: data.redirectUrl,\n                    userUuid: data.entityId,\n                    entityId: data.entityId,\n                },\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Wait until the connection becomes active\n     * @param {number} timeout - The timeout for the connection to become active\n     * @returns {Promise<Connection>} - A promise that resolves to the connection\n     */\n    async waitUntilActive(timeout = 60) {\n        try {\n            const startTime = Date.now();\n            while (Date.now() - startTime < timeout * 1000) {\n                const connection = await apiClient.connections\n                    .getConnection({\n                    client: this.client,\n                    path: { connectedAccountId: this.connectedAccountId },\n                })\n                    .then((res) => res.data);\n                if (!connection)\n                    throw new Error(\"Connected account not found\");\n                if (connection.status === \"ACTIVE\") {\n                    return connection;\n                }\n                await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n            throw new Error(\"Connection did not become active within the timeout period.\");\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nclass Integrations {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/integrations.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all available integrations in the Composio platform.\n     *\n     * This method allows clients to explore and discover the supported integrations. It returns an array of integration objects, each containing essential details such as the integration's key, name, description, logo, categories, and unique identifier.\n     *\n     * @returns {Promise<IntegrationListRes>} A promise that resolves to the list of all integrations.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appName, appUniqueKey, ...rest } = ZListIntegrationsParams.parse(data);\n            const finalAppName = appName && appName.length > 0 ? appName : appUniqueKey;\n            const response = await apiClient.appConnector.listAllConnectors({\n                client: this.client,\n                query: { ...rest, appName: finalAppName },\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves details of a specific integration in the Composio platform by providing its integration name.\n     *\n     * The response includes the integration's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {IntegrationGetParam} data The data for the request.\n     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the details of the integration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const response = await apiClient.appConnector.getConnectorInfo({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific integration's authentication scheme.\n     *\n     * This method is used to get the necessary input fields for a specific integration's authentication scheme.\n     *\n     * @param {IntegrationGetParam} data The data for the request.\n     * @returns {Promise<IntegrationRequiredParamsRes>} A promise that resolves to the required parameters for the integration's authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParams(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParams\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleIntegrationParams.parse(data);\n            const response = await apiClient.appConnector.getConnectorInfo({\n                client: this.client,\n                path: {\n                    integrationId: data.integrationId,\n                },\n                throwOnError: true,\n            });\n            return (_a = response.data) === null || _a === void 0 ? void 0 : _a.expectedInputFields;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Creates a new integration in the Composio platform.\n     *\n     * This method allows clients to create a new integration by providing the necessary details such as app ID, name, authentication mode, and configuration.\n     *\n     * @param {IntegrationCreateParams} data The data for the request.\n     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the created integration model.\n     * @throws {ComposioError} If the request fails.\n     */\n    async create(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"create\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZCreateIntegrationParams.parse(data);\n            let uniqueKey = data.appUniqueKey;\n            if (!uniqueKey) {\n                const apps = await apiClient.apps.getApps({ client: this.client });\n                const app = (_a = apps.data) === null || _a === void 0 ? void 0 : _a.items.find((app) => app.appId === data.appId);\n                uniqueKey = app.key;\n                if (!uniqueKey) {\n                    throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                        message: `No app was found with the provided appId`,\n                        description: `Please provide an app unique key`,\n                    });\n                }\n            }\n            const response = await apiClient.appConnectorV2.createConnectorV2({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey: uniqueKey,\n                    },\n                    config: {\n                        useComposioAuth: data.useComposioAuth,\n                        name: data.name,\n                        authScheme: data.authScheme,\n                        integrationSecrets: data.authConfig,\n                    },\n                },\n                throwOnError: true,\n            });\n            const integrationId = response.data.integrationId;\n            return this.get({ integrationId });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    async getOrCreateIntegration(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getOrCreateIntegration\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZCreateIntegrationParams.parse(data);\n            let uniqueKey = data.appUniqueKey;\n            if (!uniqueKey) {\n                const apps = await apiClient.apps.getApps({ client: this.client });\n                const app = (_a = apps.data) === null || _a === void 0 ? void 0 : _a.items.find((app) => app.appId === data.appId);\n                uniqueKey = app.key;\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: `No app was found with the provided appId`,\n                    description: `Please provide an app unique key`,\n                });\n            }\n            const response = await apiClient.appConnectorV2.getOrCreateConnector({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey,\n                    },\n                    config: {\n                        useComposioAuth: data.useComposioAuth,\n                        name: data.name,\n                        authScheme: data.authScheme,\n                        integrationSecrets: data.authConfig,\n                    },\n                },\n                throwOnError: true,\n            });\n            const integrationId = response.data.integrationId;\n            return this.get({ integrationId });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Deletes an existing integration in the Composio platform.\n     *\n     * This method allows clients to delete an existing integration by providing its integration ID.\n     *\n     * @param {IntegrationListData} data The data for the request.\n     * @returns {Promise<IntegrationDeleteResponse>} A promise that resolves to the deleted integration model.\n     * @throws {ComposioError} If the request fails.\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleIntegrationParams.parse(data);\n            const response = await apiClient.appConnector.deleteConnector({\n                client: this.client,\n                path: {\n                    integrationId: data.integrationId,\n                },\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst PUSHER_KEY = process.env.CLIENT_PUSHER_KEY || \"8e1b8c92b7f8b2151c15\";\nconst PUSHER_CLUSTER = \"mt1\";\nclass PusherUtils {\n    static getPusherClient(baseURL, apiKey) {\n        if (!PusherUtils.pusherClient) {\n            // Dynamic import not available, using require for now\n            // TODO: Update to use dynamic import when available\n            // eslint-disable-next-line @typescript-eslint/no-require-imports\n            const PusherClient = __webpack_require__(/*! pusher-js */ \"(action-browser)/./node_modules/pusher-js/dist/node/pusher.js\");\n            PusherUtils.pusherClient = new PusherClient(PUSHER_KEY, {\n                cluster: PUSHER_CLUSTER,\n                channelAuthorization: {\n                    endpoint: `${baseURL}/api/v1/client/auth/pusher_auth`,\n                    headers: {\n                        \"x-api-key\": apiKey,\n                    },\n                    transport: \"ajax\",\n                },\n            });\n        }\n        return PusherUtils.pusherClient;\n    }\n    /**\n     * Subscribes to a Pusher channel and binds an event to a callback function.\n     * @param {string} channelName - The name of the channel to subscribe to.\n     * @param {string} event - The event to bind to the channel.\n     * @param {(data: Record<string, unknown>) => void} fn - The callback function to execute when the event is triggered.\n     * @returns {PusherClient} The Pusher client instance.\n     */\n    static async subscribe(channelName, event, fn) {\n        try {\n            await PusherUtils.pusherClient.subscribe(channelName).bind(event, fn);\n        }\n        catch (error) {\n            logger.error(`Error subscribing to ${channelName} with event ${event}: ${error}`);\n        }\n    }\n    /**\n     * Unsubscribes from a Pusher channel.\n     * @param {string} channelName - The name of the channel to unsubscribe from.\n     * @returns {void}\n     */\n    static async unsubscribe(channelName) {\n        PusherUtils.pusherClient.unsubscribe(channelName);\n    }\n    /**\n     * Binds an event to a channel with support for chunked messages.\n     * @param {PusherClient} channel - The Pusher channel to bind the event to.\n     * @param {string} event - The event to bind to the channel.\n     * @param {(data: unknown) => void} callback - The callback function to execute when the event is triggered.\n     */\n    static bindWithChunking(channel, event, callback) {\n        channel.bind(event, callback); // Allow normal unchunked events.\n        // Now the chunked variation. Allows arbitrarily long messages.\n        const events = {};\n        channel.bind(\"chunked-\" + event, (data) => {\n            const typedData = data;\n            if (!events.hasOwnProperty(typedData.id)) {\n                events[typedData.id] = { chunks: [], receivedFinal: false };\n            }\n            const ev = events[typedData.id];\n            ev.chunks[typedData.index] = typedData.chunk;\n            if (typedData.final)\n                ev.receivedFinal = true;\n            if (ev.receivedFinal &&\n                ev.chunks.length === Object.keys(ev.chunks).length) {\n                callback(JSON.parse(ev.chunks.join(\"\")));\n                delete events[typedData.id];\n            }\n        });\n    }\n    /**\n     * Subscribes to a trigger channel for a client and handles chunked data.\n     * @param {string} clientId - The unique identifier for the client subscribing to the events.\n     * @param {(data: TriggerData) => void} fn - The callback function to execute when trigger data is received.\n     */\n    static triggerSubscribe(clientId, fn) {\n        const channel = PusherUtils.pusherClient.subscribe(`private-${clientId}_triggers`);\n        PusherUtils.bindWithChunking(channel, \"trigger_to_client\", fn);\n        logger.info(`Subscribed to triggers. You should start receiving events now.`);\n    }\n    static triggerUnsubscribe(clientId) {\n        PusherUtils.pusherClient.unsubscribe(`${clientId}_triggers`);\n    }\n}\n\nconst ZTriggerQuery = z.z.object({\n    triggerIds: z.z.array(z.z.string()).optional().describe(\"Trigger Instance IDs\"),\n    triggerInstanceIds: z.z\n        .array(z.z.string())\n        .optional()\n        .describe(\"Trigger Instance IDs\"),\n    appNames: z.z.array(z.z.string()).optional().describe(\"App Names in lowercase\"),\n    appUniqueKeys: z.z.array(z.z.string()).optional().describe(\"App Unique Keys\"),\n    connectedAccountIds: z.z\n        .array(z.z.string())\n        .optional()\n        .describe(\"Connected Account UUIDs\"),\n    integrationIds: z.z.array(z.z.string()).optional().describe(\"Integration IDs\"),\n    showEnabledOnly: z.z\n        .boolean()\n        .optional()\n        .describe(\"Show Enabled triggers only\"),\n});\nconst ZTriggerInstanceItems = z.z.object({\n    triggerInstanceId: z.z.string(),\n});\nconst ZTriggerSetupParam = z.z.object({\n    connectedAccountId: z.z.string(),\n    triggerName: z.z.string(),\n    config: z.z.record(z.z.unknown()).optional(),\n});\nz.z.object({\n    appName: z.z.string().optional(),\n    triggerId: z.z.string().optional(),\n    connectionId: z.z.string().optional(),\n    integrationId: z.z.string().optional(),\n    triggerName: z.z.string().optional(),\n    triggerData: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n});\nconst ZSingleTriggerParam = z.z.object({\n    triggerId: z.z.string().optional(),\n    triggerName: z.z.string().optional(),\n});\nz.z.object({\n    triggerInstanceId: z.z.string().optional(),\n    triggerId: z.z.string().optional(),\n});\nz.z.object({\n    name: z.z.string(),\n    displayName: z.z.string(),\n    description: z.z.string(),\n    type: z.z.string(),\n    appId: z.z.string(),\n    appName: z.z.string(),\n    instructions: z.z.string().optional(),\n    payload: z.z.record(z.z.unknown()),\n    config: z.z.record(z.z.unknown()),\n});\n\nclass Triggers {\n    constructor(backendClient, client) {\n        this.trigger_to_client_event = \"trigger_to_client\";\n        this.fileName = \"js/src/sdk/models/triggers.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all triggers in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {ListTriggersData} data The data for the request.\n     * @returns {Promise<ListTriggersResponse>} A promise that resolves to the list of all triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appNames, triggerIds, connectedAccountIds, integrationIds, showEnabledOnly, triggerInstanceIds, appUniqueKeys, } = ZTriggerQuery.parse(data);\n            const finalTriggerInstanceIds = triggerIds && triggerIds.length > 0 ? triggerIds : triggerInstanceIds;\n            const finalAppNames = appNames && appNames.length > 0 ? appNames : appUniqueKeys;\n            const { data: response } = await apiClient.triggers.listTriggers({\n                client: this.client,\n                query: {\n                    appNames: finalAppNames === null || finalAppNames === void 0 ? void 0 : finalAppNames.join(\",\"),\n                    triggerIds: finalTriggerInstanceIds === null || finalTriggerInstanceIds === void 0 ? void 0 : finalTriggerInstanceIds.join(\",\"),\n                    connectedAccountIds: connectedAccountIds === null || connectedAccountIds === void 0 ? void 0 : connectedAccountIds.join(\",\"),\n                    integrationIds: integrationIds === null || integrationIds === void 0 ? void 0 : integrationIds.join(\",\"),\n                    showEnabledOnly: showEnabledOnly || false,\n                },\n            });\n            if (!response || response.length === 0) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger not found with the given params\",\n                    description: \"Trigger not found with the given params\",\n                    possibleFix: \"Pass a check if filter params are correct\",\n                });\n            }\n            return response;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the configuration of a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            client: this.client,\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        return this.getTriggerInfo(data);\n    }\n    /**\n     * @deprecated use trigger.get instead\n     * Retrieves the configuration of a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getTriggerConfig(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getSingleTriggerConfig\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZSingleTriggerParam.parse(data);\n            if (!parsedData.triggerName && !parsedData.triggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger name or trigger id is required\",\n                    description: \"Trigger name or trigger id is required\",\n                    possibleFix: \"Pass either triggerName or triggerId\",\n                });\n            }\n            const res = await apiClient.triggers.getTriggerInfoV2({\n                client: this.client,\n                path: {\n                    triggerName: parsedData.triggerName || parsedData.triggerId || \"\",\n                },\n            });\n            // Bad type inference\n            const triggerInfo = res.data;\n            if (!triggerInfo) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger info not found\",\n                    description: \"Trigger info not found\",\n                    possibleFix: \"Pass a check if trigger exists\",\n                });\n            }\n            return { config: triggerInfo.config };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves information about a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<SingleTriggerRes>} A promise that resolves to the trigger information.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getTriggerInfo(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTriggerInfo\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZSingleTriggerParam.parse(data);\n            const res = await apiClient.triggers.getTriggerInfoV2({\n                client: this.client,\n                path: {\n                    triggerName: parsedData.triggerName || parsedData.triggerId || \"\",\n                },\n            });\n            // Bad type inference\n            const trigger = res.data;\n            if (!trigger) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger info not found\",\n                    description: \"Trigger info not found\",\n                    possibleFix: \"Pass a check if trigger exists\",\n                });\n            }\n            return trigger;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Setup a trigger for a connected account.\n     *\n     * @param {SetupTriggerData} data The data for the request.\n     * @returns {Promise<SetupTriggerResponse>} A promise that resolves to the setup trigger response.\n     * @throws {ComposioError} If the request fails.\n     */\n    async setup(params) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"setup\",\n            file: this.fileName,\n            params: params,\n        });\n        try {\n            const parsedData = ZTriggerSetupParam.parse(params);\n            const response = await apiClient.triggers.enableTrigger({\n                client: this.client,\n                path: {\n                    connectedAccountId: parsedData.connectedAccountId,\n                    triggerName: parsedData.triggerName,\n                },\n                body: {\n                    triggerConfig: parsedData.config || {},\n                },\n                throwOnError: true,\n            });\n            const { triggerId, status } = response.data;\n            return {\n                triggerId: triggerId,\n                triggerName: parsedData.triggerName,\n                status,\n                triggerInstanceId: triggerId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enables a trigger for a connected account.\n     *\n     * @param {triggerId,triggerInstanceId} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the enable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const finalTriggerId = data.triggerId || data.triggerInstanceId;\n            if (!finalTriggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger ID is required\",\n                    description: \"Trigger ID is required\",\n                    possibleFix: \"Pass either triggerId or triggerInstanceId\",\n                });\n            }\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: {\n                    triggerId: finalTriggerId,\n                },\n                body: {\n                    enabled: true,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disables a trigger for a connected account.\n     *\n     * @param {triggerId,triggerInstanceId} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the disable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const finalTriggerId = data.triggerId || data.triggerInstanceId;\n            if (!finalTriggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger ID is required\",\n                    description: \"Trigger ID is required\",\n                    possibleFix: \"Pass either triggerId or triggerInstanceId\",\n                });\n            }\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: {\n                    triggerId: finalTriggerId,\n                },\n                body: {\n                    enabled: false,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Deletes a trigger for a connected account.\n     *\n     * @param {TriggerInstanceItems} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the delete request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerInstanceItems.parse(data);\n            await apiClient.triggers.deleteTrigger({\n                client: this.client,\n                path: {\n                    triggerInstanceId: parsedData.triggerInstanceId,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    async subscribe(fn, filters = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"subscribe\",\n            file: this.fileName,\n            params: { filters },\n        });\n        if (!fn)\n            throw new Error(\"Function is required for trigger subscription\");\n        const clientId = await this.backendClient.getClientId();\n        await PusherUtils.getPusherClient(this.backendClient.baseUrl, this.backendClient.apiKey);\n        const shouldSendTrigger = (data) => {\n            if (Object.keys(filters).length === 0)\n                return true;\n            else {\n                return ((!filters.appName ||\n                    data.appName.toLowerCase() === filters.appName.toLowerCase()) &&\n                    (!filters.triggerId ||\n                        data.metadata.id.toLowerCase() ===\n                            filters.triggerId.toLowerCase()) &&\n                    (!filters.connectionId ||\n                        data.metadata.connectionId.toLowerCase() ===\n                            filters.connectionId.toLowerCase()) &&\n                    (!filters.triggerName ||\n                        data.metadata.triggerName.toLowerCase() ===\n                            filters.triggerName.toLowerCase()) &&\n                    (!filters.entityId ||\n                        data.metadata.connection.clientUniqueUserId.toLowerCase() ===\n                            filters.entityId.toLowerCase()) &&\n                    (!filters.integrationId ||\n                        data.metadata.connection.integrationId.toLowerCase() ===\n                            filters.integrationId.toLowerCase()));\n            }\n        };\n        logger.debug(\"Subscribing to triggers\", filters);\n        PusherUtils.triggerSubscribe(clientId, (data) => {\n            if (shouldSendTrigger(data)) {\n                fn(data);\n            }\n        });\n    }\n    async unsubscribe() {\n        const clientId = await this.backendClient.getClientId();\n        PusherUtils.triggerUnsubscribe(clientId);\n    }\n}\n\nconst LABELS = {\n    PRIMARY: \"primary\",\n};\nclass Entity {\n    constructor(backendClient, id = \"default\") {\n        this.fileName = \"js/src/sdk/models/Entity.ts\";\n        this.backendClient = backendClient;\n        this.id = id;\n        this.triggerModel = new Triggers(this.backendClient, this.backendClient.instance);\n        this.actionsModel = new Actions(this.backendClient, this.backendClient.instance);\n        this.apps = new Apps(this.backendClient, this.backendClient.instance);\n        this.connectedAccounts = new ConnectedAccounts(this.backendClient, this.backendClient.instance);\n        this.integrations = new Integrations(this.backendClient, this.backendClient.instance);\n        this.activeTriggers = new ActiveTriggers(this.backendClient, this.backendClient.instance);\n    }\n    /**\n     * Executes an action for an entity.\n     *\n     * @param {string} actionName The name of the action to execute.\n     * @param {Record<string, unknown>} params The parameters for the action.\n     * @param {string} text The text to pass to the action. This can be to perform NLA execution\n     * @param {string} connectedAccountId The ID of the connected account to use for the action.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the response from the action execution.\n     * @throws {ComposioError} If the request fails.\n     */\n    async execute({ actionName, params, text, connectedAccountId, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"execute\",\n            file: this.fileName,\n            params: { actionName, params, text, connectedAccountId },\n        });\n        try {\n            ZExecuteActionParams$1.parse({\n                actionName,\n                params,\n                text,\n                connectedAccountId,\n            });\n            const action = await this.actionsModel.get({\n                actionName: actionName,\n            });\n            if (!action) {\n                throw new Error(`Could not find action: ${actionName}`);\n            }\n            const app = await this.apps.get({\n                appKey: action.appKey,\n            });\n            if (app.no_auth) {\n                return this.actionsModel.execute({\n                    actionName: actionName,\n                    requestBody: {\n                        input: params,\n                        appName: action.appKey,\n                    },\n                });\n            }\n            const connectedAccount = await this.getConnection({\n                app: action.appKey,\n                connectedAccountId,\n            });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${action.appKey}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${action.appKey}' and entity='${this.id}'`,\n                });\n            }\n            return this.actionsModel.execute({\n                actionName: actionName,\n                requestBody: {\n                    // @ts-ignore\n                    connectedAccountId: connectedAccount === null || connectedAccount === void 0 ? void 0 : connectedAccount.id,\n                    input: params,\n                    appName: action.appKey,\n                    text: text,\n                },\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.\n     *\n     * @param {ConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getConnection({ app, appName, connectedAccountId }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getConnection\",\n            file: this.fileName,\n            params: { app, appName, connectedAccountId },\n        });\n        try {\n            const finalApp = appName || app;\n            ZConnectionParams.parse({ app: finalApp, connectedAccountId });\n            if (!finalApp && !connectedAccountId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"App or connectedAccountId is required\",\n                    description: \"App or connectedAccountId is required\",\n                });\n            }\n            if (connectedAccountId) {\n                return await this.connectedAccounts.get({\n                    connectedAccountId,\n                });\n            }\n            let latestAccount = null;\n            let latestCreationDate = null;\n            const connectedAccounts = await this.connectedAccounts.list({\n                user_uuid: this.id,\n            });\n            for (const account of connectedAccounts.items) {\n                if ((account === null || account === void 0 ? void 0 : account.labels) && (account === null || account === void 0 ? void 0 : account.labels.includes(LABELS.PRIMARY))) {\n                    latestAccount = account;\n                    break;\n                }\n            }\n            if (!latestAccount) {\n                for (const connectedAccount of connectedAccounts.items) {\n                    if ((finalApp === null || finalApp === void 0 ? void 0 : finalApp.toLocaleLowerCase()) ===\n                        connectedAccount.appName.toLocaleLowerCase()) {\n                        const creationDate = new Date(connectedAccount.createdAt);\n                        if ((!latestAccount ||\n                            (latestCreationDate && creationDate > latestCreationDate)) &&\n                            connectedAccount.status === \"ACTIVE\") {\n                            latestCreationDate = creationDate;\n                            latestAccount = connectedAccount;\n                        }\n                    }\n                }\n            }\n            if (!latestAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            const connectedAccount = await this.connectedAccounts.get({\n                connectedAccountId: latestAccount.id,\n            });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            return connectedAccount;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to setup a trigger for an app by providing its unique key and the trigger name.\n     *\n     * @param {TriggerSubscribeParam} data The data for the request, including the app's unique key and the trigger name.\n     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async setupTrigger({ app, appName, triggerName, config, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"setupTrigger\",\n            file: this.fileName,\n            params: { app, appName, triggerName, config },\n        });\n        try {\n            const finalApp = appName || app;\n            ZTriggerSubscribeParam.parse({ app: finalApp, triggerName, config });\n            const connectedAccount = await this.getConnection({ app: finalApp });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            const trigger = await this.triggerModel.setup({\n                connectedAccountId: connectedAccount.id,\n                triggerName,\n                config,\n            });\n            return trigger;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to disable a trigger by providing its trigger ID.\n     *\n     * @param {string} triggerId The ID of the trigger to disable.\n     * @returns {Promise<{ status: string }>} A promise that resolves to the status of the trigger disablement.\n     * @throws {ComposioError} If the request fails.\n     */\n    async disableTrigger(triggerId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disableTrigger\",\n            file: this.fileName,\n            params: { triggerId },\n        });\n        try {\n            await this.activeTriggers.disable({ triggerId: triggerId });\n            return { status: \"success\" };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves all connections for an entity.\n     *\n     * @returns {Promise<ConnectionItem[]>} A promise that resolves to an array of connection items.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getConnections() {\n        /**\n         * Get all connections for an entity.\n         */\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getConnections\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const connectedAccounts = await this.connectedAccounts.list({\n                user_uuid: this.id,\n            });\n            return connectedAccounts.items;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves all active triggers for an entity.\n     *\n     * @returns {Promise<ActiveTrigger[]>} A promise that resolves to an array of active triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getActiveTriggers() {\n        /**\n         * Get all active triggers for an entity.\n         */\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getActiveTriggers\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const connectedAccounts = await this.getConnections();\n            const activeTriggers = await this.activeTriggers.list({\n                // @ts-ignore\n                connectedAccountIds: connectedAccounts\n                    .map((account) => account.id)\n                    .join(\",\"),\n            });\n            return activeTriggers;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initiate a connection for an entity.\n     * @param {InitiateConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<ConnectionRequest>} A promise that resolves to the connection request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async initiateConnection(data) {\n        var _a, _b;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"initiateConnection\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appName, authMode, authConfig, integrationId, connectionParams, redirectUri, labels, } = ZInitiateConnectionParams.parse(data);\n            // Initiate the connection process\n            return this.connectedAccounts.initiate({\n                authMode: authMode,\n                authConfig: authConfig,\n                integrationId: integrationId,\n                appName: appName,\n                entityId: this.id,\n                redirectUri: redirectUri || ((_a = data.config) === null || _a === void 0 ? void 0 : _a.redirectUrl) || \"\",\n                connectionParams: connectionParams,\n                labels: labels || ((_b = data.config) === null || _b === void 0 ? void 0 : _b.labels) || [],\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst removeTrailingSlashIfExists = (str) => str.replace(/\\/+$/, \"\");\n\n/**\n * Class representing the details required to initialize and configure the API client.\n */\nclass AxiosBackendClient {\n    /**\n     * Creates an instance of apiClientDetails.\n     * @param {string} apiKey - The API key for client initialization.\n     * @param {string} baseUrl - The base URL for the API client.\n     * @param {string} runtime - The runtime environment identifier.\n     * @throws Will throw an error if the API key is not provided.\n     */\n    constructor(apiKey, baseUrl, runtime) {\n        this.runtime = runtime || \"\";\n        this.apiKey = apiKey;\n        this.baseUrl = removeTrailingSlashIfExists(baseUrl);\n        this.instance = clientAxios.createClient(clientAxios.createConfig({\n            baseURL: this.baseUrl,\n            headers: {\n                // common: {\n                \"X-API-KEY\": `${this.apiKey}`,\n                \"X-SOURCE\": \"js_sdk\",\n                \"X-RUNTIME\": this.runtime,\n                // }\n            },\n        }));\n        if (!apiKey) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE, {\n                message: \"API key is not available\",\n                description: \"The API key required for authentication is not provided. You can get the API key from the Composio dashboard.\",\n                possibleFix: \"Please provide the API key in the constructor\",\n            });\n        }\n        // Validate baseUrl\n        if (!baseUrl.startsWith(\"http://\") && !baseUrl.startsWith(\"https://\")) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE, {\n                message: `ðŸ”— Base URL ${baseUrl} is not valid`,\n                description: \"The composio backend URL provided is not valid\",\n            });\n        }\n        this.initializeApiClient();\n    }\n    /**\n     * Retrieves the client ID from the user's information.\n     * @returns {Promise<string>} A promise that resolves to the client ID.\n     * @throws Will throw an error if the HTTP request fails.\n     */\n    async getClientId() {\n        var _a;\n        try {\n            const { data } = await apiClient.clientAuth.getUserInfo({\n                client: this.instance,\n            });\n            return ((_a = data === null || data === void 0 ? void 0 : data.client) === null || _a === void 0 ? void 0 : _a.id) || \"\";\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initializes the API client with the provided configuration.\n     * @private\n     */\n    initializeApiClient() {\n        this.instance.setConfig({\n            baseURL: removeTrailingSlashIfExists(this.baseUrl),\n            headers: {\n                common: {\n                    \"X-API-KEY\": `${this.apiKey}`,\n                    \"X-SOURCE\": \"js_sdk\",\n                    \"X-RUNTIME\": this.runtime,\n                },\n            },\n            throwOnError: true,\n        });\n        // setAxiosClientConfig(this.instance.instance);\n    }\n    getAxiosInstance() {\n        return this.instance.instance;\n    }\n}\n\n// File path helpers\nconst userDataPath = () => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        return path.join(os.homedir(), COMPOSIO_DIR, USER_DATA_FILE_NAME);\n    }\n    catch (_error) {\n        return null;\n    }\n};\nconst getUserDataJson = () => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const data = fs.readFileSync(userDataPath(), \"utf8\");\n        return JSON.parse(data);\n    }\n    catch (_error) {\n        return {};\n    }\n};\n// Axios configuration\nconst setAxiosClientConfig = (axiosClientInstance) => {\n    axiosClientInstance.interceptors.request.use((request) => {\n        var _a;\n        const body = request.data ? JSON.stringify(request.data) : \"\";\n        // set x-request-id header\n        const requestId = getUUID();\n        request.headers[\"x-request-id\"] = requestId;\n        request.metadata = {\n            startTime: Date.now(),\n            requestId,\n        };\n        logger.debug(`API Req [${(_a = request.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()}] ${request.url}, x-request-id: ${requestId}`, {\n            ...(body && { body }),\n            query: request.params,\n        });\n        return request;\n    });\n    axiosClientInstance.interceptors.response.use((response) => {\n        var _a, _b, _c;\n        const method = (_a = response.config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();\n        const responseSize = Math.round(JSON.stringify(response.data).length / 1024);\n        const requestStartTime = (_b = response.config\n            .metadata) === null || _b === void 0 ? void 0 : _b.startTime;\n        const responseTime = requestStartTime ? Date.now() - requestStartTime : 0;\n        const status = response.status;\n        const requestId = response.headers[\"x-request-id\"] ||\n            ((_c = response.config.metadata) === null || _c === void 0 ? void 0 : _c.requestId);\n        // @ts-expect-error Error with metadata type\n        response[\"metadata\"] = {\n            responseTime,\n            responseSize,\n            requestId,\n        };\n        logger.debug(`API Res [${method}] ${response.config.url} - ${status} - ${responseSize} KB ${responseTime}ms`);\n        return response;\n    }, (error) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        const requestStartTime = (_b = (_a = error.config) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.startTime;\n        const requestStartTimeId = (_d = (_c = error.config) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.requestId;\n        const responseTime = requestStartTime ? Date.now() - requestStartTime : 0;\n        const status = ((_e = error.response) === null || _e === void 0 ? void 0 : _e.status) || \"Unknown\";\n        const length = ((_g = JSON.stringify((_f = error.response) === null || _f === void 0 ? void 0 : _f.data)) === null || _g === void 0 ? void 0 : _g.length) || 0;\n        const responseSize = Math.round(length / 1024);\n        const requestId = ((_j = (_h = error.response) === null || _h === void 0 ? void 0 : _h.headers) === null || _j === void 0 ? void 0 : _j[\"x-request-id\"]) || requestStartTimeId;\n        const metadata = {\n            responseTime,\n            responseSize,\n            requestId,\n        };\n        // @ts-expect-error Error with metadata type\n        error.metadata = metadata;\n        logger.debug(`API Error [${status}] ${(_l = (_k = error.config) === null || _k === void 0 ? void 0 : _k.method) === null || _l === void 0 ? void 0 : _l.toUpperCase()} ${(_m = error.config) === null || _m === void 0 ? void 0 : _m.url} - ${status} - ${responseTime}ms, x-request-id: ${requestId}`, {\n            headers: (_o = error.response) === null || _o === void 0 ? void 0 : _o.headers,\n            data: (_p = error.response) === null || _p === void 0 ? void 0 : _p.data,\n            error: error.message,\n            responseTime,\n        });\n        return Promise.reject(error);\n    });\n};\n// Client configuration functions\nfunction getSDKConfig(baseUrl, apiKey) {\n    const userData = getUserDataJson();\n    const { api_key: apiKeyFromUserConfig, base_url: baseURLFromUserConfig } = userData;\n    const baseURLParsed = baseUrl ||\n        getEnvVariable(\"COMPOSIO_BASE_URL\") ||\n        baseURLFromUserConfig ||\n        DEFAULT_BASE_URL;\n    const apiKeyParsed = apiKey || getEnvVariable(\"COMPOSIO_API_KEY\") || apiKeyFromUserConfig || \"\";\n    return { baseURL: baseURLParsed, apiKey: apiKeyParsed };\n}\n\nconst isNewerVersion = (v1, v2) => {\n    const parts1 = v1.split(\".\").map(Number);\n    const parts2 = v2.split(\".\").map(Number);\n    for (let i = 0; i < 3; i++) {\n        if (parts1[i] > parts2[i])\n            return true;\n        if (parts1[i] < parts2[i])\n            return false;\n    }\n    return false;\n};\n\nclass Composio {\n    /**\n     * Initializes a new instance of the Composio class.\n     *\n     * @param {Object} config - Configuration object for the Composio SDK\n     * @param {string} [config.apiKey] - The API key for authenticating with the Composio backend. Can also be set locally in an environment variable.\n     * @param {string} [config.baseUrl] - The base URL for the Composio backend. By default, it is set to the production URL.\n     * @param {string} [config.runtime] - The runtime environment for the SDK.\n     * @param {boolean} [config.allowTracing] - Whether to allow tracing for the SDK.\n     */\n    constructor(config = {}) {\n        this.fileName = \"js/src/sdk/index.ts\";\n        // Parse the base URL and API key, falling back to environment variables or defaults if not provided\n        const { baseURL: baseURLParsed, apiKey: apiKeyParsed } = getSDKConfig(config === null || config === void 0 ? void 0 : config.baseUrl, config === null || config === void 0 ? void 0 : config.apiKey);\n        if (IS_DEVELOPMENT_OR_CI) {\n            logger.info(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);\n        }\n        ComposioSDKContext.apiKey = apiKeyParsed;\n        ComposioSDKContext.baseURL = baseURLParsed;\n        ComposioSDKContext.frameworkRuntime = config === null || config === void 0 ? void 0 : config.runtime;\n        ComposioSDKContext.composioVersion = COMPOSIO_VERSION;\n        ComposioSDKContext.allowTracing = config === null || config === void 0 ? void 0 : config.allowTracing;\n        // by default, generate a sessionId unless allowTracing is explicitly set to false\n        ComposioSDKContext.sessionId =\n            (config === null || config === void 0 ? void 0 : config.allowTracing) !== false ? getUUID() : undefined;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_INITIALIZED, {});\n        if (!apiKeyParsed) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE, {\n                message: \"ðŸ”‘ API Key is not provided\",\n                description: \"You need to provide it in the constructor or as an environment variable COMPOSIO_API_KEY\",\n                possibleFix: \"Please provide a valid API Key. You can get it from https://app.composio.dev/settings OR Check if you are passing it as an object in the constructor like - { apiKey: 'your-api-key' }\",\n            });\n        }\n        logger.info(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);\n        // Initialize the BackendClient with the parsed API key and base URL.\n        this.backendClient = new AxiosBackendClient(apiKeyParsed, baseURLParsed, config === null || config === void 0 ? void 0 : config.runtime);\n        setAxiosClientConfig(this.backendClient.getAxiosInstance());\n        // Instantiate models with dependencies as needed.\n        this.connectedAccounts = new ConnectedAccounts(this.backendClient, this.backendClient.instance);\n        this.triggers = new Triggers(this.backendClient, this.backendClient.instance);\n        this.apps = new Apps(this.backendClient, this.backendClient.instance);\n        this.actions = new Actions(this.backendClient, this.backendClient.instance);\n        this.integrations = new Integrations(this.backendClient, this.backendClient.instance);\n        this.activeTriggers = new ActiveTriggers(this.backendClient, this.backendClient.instance);\n        this.checkForLatestVersionFromNPM();\n    }\n    /**\n     * Checks for the latest version of the Composio SDK from NPM.\n     * If a newer version is available, it logs a warning to the console.\n     */\n    async checkForLatestVersionFromNPM() {\n        try {\n            const packageName = \"composio-core\";\n            const currentVersionFromPackageJson = COMPOSIO_VERSION;\n            const response = await axios.get(`https://registry.npmjs.org/${packageName}/latest`);\n            const latestVersion = response.data.version;\n            if (isNewerVersion(latestVersion, currentVersionFromPackageJson) &&\n                !IS_DEVELOPMENT_OR_CI) {\n                logger.info(`ðŸš€ Upgrade available! Your composio-core version (${currentVersionFromPackageJson}) is behind. Latest version: ${latestVersion}.`);\n            }\n        }\n        catch (_error) {\n            // Ignore and do nothing\n        }\n    }\n    /**\n     * Retrieves an Entity instance associated with a given ID.\n     *\n     * @param {string} [id='default'] - The ID of the entity to retrieve.\n     * @returns {Entity} An instance of the Entity class.\n     */\n    getEntity(id = \"default\") {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getEntity\",\n            file: this.fileName,\n            params: { id },\n        });\n        return new Entity(this.backendClient, id);\n    }\n    async getExpectedParamsForUser(params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getExpectedParamsForUser\",\n            file: this.fileName,\n            params: params,\n        });\n        const { app } = params;\n        let { integrationId } = params;\n        if (integrationId === null && app === null) {\n            throw new Error(\"Both `integration_id` and `app` cannot be None\");\n        }\n        if (!integrationId) {\n            try {\n                const integrations = await this.integrations.list({\n                    appName: app,\n                    showDisabled: false,\n                });\n                if (params.authScheme && integrations) {\n                    integrations.items = integrations.items.filter((integration) => integration.authScheme === params.authScheme);\n                }\n                integrationId = (_a = integrations === null || integrations === void 0 ? void 0 : integrations.items[0]) === null || _a === void 0 ? void 0 : _a.id;\n            }\n            catch (_) {\n                // do nothing\n            }\n        }\n        let integration = integrationId\n            ? await this.integrations.get({\n                integrationId: integrationId,\n            })\n            : undefined;\n        if (integration) {\n            return {\n                expectedInputFields: integration.expectedInputFields,\n                integrationId: integration.id,\n                authScheme: integration.authScheme,\n            };\n        }\n        const appInfo = await this.apps.get({\n            appKey: app.toLocaleLowerCase(),\n        });\n        const preferredAuthScheme = [\n            \"OAUTH2\",\n            \"OAUTH1\",\n            \"API_KEY\",\n            \"BASIC\",\n            \"BEARER_TOKEN\",\n            \"BASIC_WITH_JWT\",\n        ];\n        let schema = params.authScheme;\n        if (!schema) {\n            for (const scheme of preferredAuthScheme) {\n                if ((_b = appInfo.auth_schemes) === null || _b === void 0 ? void 0 : _b.map((_authScheme) => _authScheme.mode).includes(scheme)) {\n                    schema = scheme;\n                    break;\n                }\n            }\n        }\n        const hasTestConnectors = ((_d = (_c = appInfo.testConnectors) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n        const authSchemeFields = (_f = (_e = appInfo.auth_schemes) === null || _e === void 0 ? void 0 : _e.find((_authScheme) => _authScheme.mode === schema)) === null || _f === void 0 ? void 0 : _f.fields;\n        const requiredCustomerFields = (_h = (_g = authSchemeFields === null || authSchemeFields === void 0 ? void 0 : authSchemeFields.filter((field) => !field.expected_from_customer)) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0;\n        const areNoFieldsRequiredForIntegration = hasTestConnectors || requiredCustomerFields === 0;\n        if (!areNoFieldsRequiredForIntegration) {\n            throw new Error(`No default credentials available for this app, please create new integration by going to app.composio.dev or through CLI - composio add ${appInfo.key}`);\n        }\n        const timestamp = new Date().toISOString().replace(/[-:.]/g, \"\");\n        const hasRelevantTestConnectors = params.authScheme\n            ? ((_k = (_j = appInfo.testConnectors) === null || _j === void 0 ? void 0 : _j.filter((connector) => connector.authScheme === params.authScheme)) === null || _k === void 0 ? void 0 : _k.length) > 0\n            : ((_l = appInfo.testConnectors) === null || _l === void 0 ? void 0 : _l.length) > 0;\n        if (hasRelevantTestConnectors) {\n            integration = await this.integrations.create({\n                appId: appInfo.appId,\n                name: `integration_${timestamp}`,\n                authScheme: schema,\n                authConfig: {},\n                useComposioAuth: true,\n            });\n            return {\n                expectedInputFields: integration === null || integration === void 0 ? void 0 : integration.expectedInputFields,\n                integrationId: integration === null || integration === void 0 ? void 0 : integration.id,\n                authScheme: integration === null || integration === void 0 ? void 0 : integration.authScheme,\n            };\n        }\n        if (!schema) {\n            throw new Error(`No supported auth scheme found for \\`${String(app)}\\`, ` +\n                \"Please create an integration and use the ID to \" +\n                \"get the expected parameters.\");\n        }\n        integration = await this.integrations.create({\n            appId: appInfo.appId,\n            name: `integration_${timestamp}`,\n            authScheme: schema,\n            authConfig: {},\n            useComposioAuth: false,\n        });\n        if (!integration) {\n            throw new Error(\"An unexpected error occurred while creating the integration, please create an integration manually and use its ID to get the expected parameters\");\n        }\n        return {\n            expectedInputFields: integration.expectedInputFields,\n            integrationId: integration.id,\n            authScheme: integration.authScheme,\n        };\n    }\n}\n\n/*\n    This is the schema for the raw action to be stored locally\n    Also returned by the API\n*/\nz.z.object({\n    name: z.z.string(),\n    display_name: z.z.string(),\n    description: z.z.string(),\n    appKey: z.z.string(),\n    appId: z.z.string(),\n    appName: z.z.string(),\n    logo: z.z.string(),\n    enabled: z.z.boolean(),\n    tags: z.z.array(z.z.string()),\n    parameters: z.z.object({\n        type: z.z.string(),\n        title: z.z.string(),\n        description: z.z.string(),\n        required: z.z.array(z.z.string()),\n        properties: z.z.record(z.z.any()),\n    }),\n    response: z.z.record(z.z.any()),\n    metadata: z.z.object({\n        name: z.z.string(),\n        toolName: z.z.string().optional(),\n    }),\n});\n/*\n    This is the schema for the params object in the ExecuteAction function\n*/\nconst ZExecuteActionParams = z.z.object({\n    action: z.z.string(),\n    params: z.z.record(z.z.any()).optional(),\n    entityId: z.z.string().optional(),\n    nlaText: z.z.string().optional(),\n    connectedAccountId: z.z.string().optional(),\n    config: z.z\n        .object({\n        labels: z.z.array(z.z.string()).optional(),\n    })\n        .optional(),\n});\nconst ZToolSchemaFilter = z.z.object({\n    actions: z.z.array(z.z.string()).optional(),\n    apps: z.z.array(z.z.string()).optional(),\n    tags: z.z.array(z.z.string()).optional(),\n    useCase: z.z.string().optional(),\n    useCaseLimit: z.z.number().optional(),\n    filterByAvailableApps: z.z.boolean().optional(),\n    integrationId: z.z.string().optional(),\n});\n\nclass ActionRegistry {\n    constructor(client) {\n        this.client = client;\n        this.customActions = new Map();\n    }\n    async createAction(options) {\n        var _a;\n        const { callback } = options;\n        if (typeof callback !== \"function\") {\n            throw new Error(\"Callback must be a function\");\n        }\n        if (!options.actionName) {\n            throw new Error(\"You must provide actionName for this action\");\n        }\n        if (!options.inputParams) {\n            options.inputParams = z.z.object({});\n        }\n        const params = options.inputParams;\n        const actionName = options.actionName || callback.name || \"\";\n        const paramsSchema = (await zodToJsonSchema.zodToJsonSchema(params, {\n            name: \"input\",\n        }));\n        const _params = paramsSchema.definitions.input.properties;\n        const composioSchema = {\n            name: actionName,\n            description: options.description,\n            parameters: {\n                title: actionName,\n                type: \"object\",\n                description: options.description,\n                required: paramsSchema.definitions.input.required || [],\n                properties: _params,\n            },\n            response: {\n                type: \"object\",\n                title: \"Response for \" + actionName,\n                properties: [],\n            },\n        };\n        this.customActions.set(((_a = options.actionName) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) || \"\", {\n            metadata: options,\n            schema: composioSchema,\n        });\n        return composioSchema;\n    }\n    async getActions({ actions, }) {\n        const actionsArr = [];\n        for (const name of actions) {\n            const lowerCaseName = name.toLowerCase();\n            if (this.customActions.has(lowerCaseName)) {\n                const action = this.customActions.get(lowerCaseName);\n                actionsArr.push(action.schema);\n            }\n        }\n        return actionsArr;\n    }\n    async getAllActions() {\n        return Array.from(this.customActions.values()).map((action) => action.schema);\n    }\n    async getToolName({ action, }) {\n        var _a;\n        if (!action) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                message: \"Action name is required\",\n                description: \"Please provide an action name to get its tool name\",\n            });\n        }\n        const lowerCaseName = action.toLowerCase();\n        return (_a = this.customActions.get(lowerCaseName)) === null || _a === void 0 ? void 0 : _a.metadata.toolName;\n    }\n    async executeAction(name, inputParams, metadata) {\n        const lowerCaseName = name.toLocaleLowerCase();\n        if (!this.customActions.has(lowerCaseName)) {\n            throw new Error(`Action with name ${name} does not exist`);\n        }\n        const action = this.customActions.get(lowerCaseName);\n        if (!action) {\n            throw new Error(`Action with name ${name} could not be retrieved`);\n        }\n        const { callback, toolName } = action.metadata || {};\n        let authCredentials = {};\n        if (toolName) {\n            const entity = await this.client.getEntity(metadata.entityId);\n            const connection = await entity.getConnection({\n                app: toolName,\n                connectedAccountId: metadata.connectionId,\n            });\n            if (!connection) {\n                throw new Error(`Connection with app name ${toolName} and entityId ${metadata.entityId} not found`);\n            }\n            const connectionParams = connection.connectionParams;\n            authCredentials = {\n                headers: connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.headers,\n                queryParams: connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.queryParams,\n                baseUrl: (connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.baseUrl) || (connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.base_url),\n            };\n        }\n        if (typeof callback !== \"function\") {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                message: \"Callback must be a function\",\n                description: \"Please provide a valid callback function\",\n            });\n        }\n        const executeRequest = async (data) => {\n            try {\n                const { data: res } = await apiClient.actionsV2.executeWithHttpClient({\n                    client: this.client.backendClient.instance,\n                    body: {\n                        ...data,\n                        connectedAccountId: metadata === null || metadata === void 0 ? void 0 : metadata.connectionId,\n                    },\n                });\n                return res;\n            }\n            catch (error) {\n                throw CEG.handleAllError(error);\n            }\n        };\n        return await callback(inputParams, authCredentials, (data) => executeRequest(data));\n    }\n}\n\n/**\n * Gets the Composio directory.\n * @param createDirIfNotExists - Whether to create the directory if it doesn't exist.\n * @returns The path to the Composio directory.\n */\nconst getComposioDir = (createDirIfNotExists = false) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioDir = path.join(os.homedir(), COMPOSIO_DIR);\n        if (createDirIfNotExists && !fs.existsSync(composioDir)) {\n            fs.mkdirSync(composioDir, { recursive: true });\n        }\n        return composioDir;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n/**\n * Gets the Composio temporary files directory.\n * @param createDirIfNotExists - Whether to create the directory if it doesn't exist.\n * @returns The path to the Composio temporary files directory.\n */\nconst getComposioTempFilesDir = (createDirIfNotExists = false) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioFilesDir = path.join(os.homedir(), COMPOSIO_DIR, TEMP_FILES_DIRECTORY_NAME);\n        if (createDirIfNotExists && !fs.existsSync(composioFilesDir)) {\n            fs.mkdirSync(composioFilesDir, { recursive: true });\n        }\n        return composioFilesDir;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n/**\n * Saves a file to the Composio directory.\n * @param file - The name of the file to save.\n * @param content - The content of the file to save. Should be a string.\n * @param isTempFile - Whether the file is a temporary file.\n * @returns The path to the saved file.\n */\nconst saveFile = (file, content, isTempFile = false) => {\n    try {\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioFilesDir = isTempFile\n            ? getComposioTempFilesDir(true)\n            : getComposioDir(true);\n        const filePath = path.join(composioFilesDir, path.basename(file));\n        if (Buffer.isBuffer(content)) {\n            fs.writeFileSync(filePath, content);\n        }\n        else {\n            fs.writeFileSync(filePath, content, \"utf8\");\n        }\n        return filePath;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n\nconst readFileContent = async (path) => {\n    try {\n        const content = (__webpack_require__(/*! fs */ \"fs\").readFileSync)(path);\n        return {\n            content: content.toString(\"base64\"),\n            mimeType: \"application/octet-stream\",\n        };\n    }\n    catch (error) {\n        throw new Error(`Error reading file at ${path}: ${error}`);\n    }\n};\nconst readFileContentFromURL = async (path) => {\n    const response = await axios.get(path, {\n        responseType: \"arraybuffer\",\n    });\n    const content = Buffer.from(response.data);\n    const mimeType = response.headers[\"content-type\"] || \"application/octet-stream\";\n    return {\n        content: content.toString(\"base64\"),\n        mimeType,\n    };\n};\nconst uploadFileToS3 = async (content, actionName, appName, mimeType, client) => {\n    var _a;\n    const extension = mimeType.split(\"/\")[1] || \"bin\";\n    const response = await apiClient.actionsV2.createFileUploadUrl({\n        client: client,\n        body: {\n            action: actionName,\n            app: appName,\n            filename: `${actionName}_${Date.now()}.${extension}`,\n            mimetype: mimeType,\n            md5: crypto\n                .createHash(\"md5\")\n                .update(Buffer.from(content, \"base64\"))\n                .digest(\"hex\"),\n        },\n        path: {\n            fileType: \"request\",\n        },\n    });\n    const data = response.data;\n    const signedURL = data.url;\n    const s3key = data.key;\n    try {\n        const buffer = Buffer.from(content, \"base64\");\n        await axios.put(signedURL, buffer, {\n            headers: {\n                \"Content-Type\": mimeType,\n                \"Content-Length\": buffer.length,\n            },\n        });\n    }\n    catch (e) {\n        const error = e;\n        if (error instanceof axios.AxiosError && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {\n            return signedURL;\n        }\n        throw new Error(`Error uploading file to S3: ${error}`);\n    }\n    return s3key;\n};\nconst getFileDataAfterUploadingToS3 = async (path, actionName, client) => {\n    const isURL = path.startsWith(\"http\");\n    const fileData = isURL\n        ? await readFileContentFromURL(path)\n        : await readFileContent(path);\n    const s3key = await uploadFileToS3(fileData.content, actionName, actionName, fileData.mimeType, client);\n    return {\n        name: pathModule.basename(path) || `${actionName}_${Date.now()}`,\n        mimetype: fileData.mimeType,\n        s3key: s3key,\n    };\n};\nconst downloadFileFromS3 = async ({ actionName, s3Url, mimeType, }) => {\n    const response = await axios.get(s3Url, {\n        responseType: \"arraybuffer\",\n    });\n    const extension = mimeType.split(\"/\")[1] || \"txt\";\n    const fileName = `${actionName}_${Date.now()}.${extension}`;\n    const filePath = saveFile(fileName, response.data, true);\n    return {\n        name: fileName,\n        mimeType: mimeType,\n        s3Key: s3Url,\n        filePath: filePath,\n    };\n};\n\nconst FILE_SUFFIX = \"_schema_parsed_file\";\nconst convertFileSchemaProperty = (key, property) => {\n    if (!property.file_uploadable) {\n        return property;\n    }\n    return {\n        keyName: `${key}${FILE_SUFFIX}`,\n        type: \"string\",\n        description: property.description,\n    };\n};\nconst processFileUpload = async (params, actionName, client) => {\n    const result = { ...params };\n    for (const [key, value] of Object.entries(result)) {\n        if (!key.endsWith(FILE_SUFFIX))\n            continue;\n        const originalKey = key.replace(FILE_SUFFIX, \"\");\n        const fileData = await getFileDataAfterUploadingToS3(value, actionName, client);\n        result[originalKey] = fileData;\n        delete result[key];\n    }\n    return result;\n};\nconst FILE_INPUT_PROCESSOR = async ({ params, actionName, client, }) => {\n    return processFileUpload(params, actionName, client);\n};\nconst FILE_DOWNLOADABLE_PROCESSOR = async ({ actionName, toolResponse, }) => {\n    const result = JSON.parse(JSON.stringify(toolResponse));\n    for (const [key, value] of Object.entries(toolResponse.data)) {\n        const fileData = value;\n        if (!(fileData === null || fileData === void 0 ? void 0 : fileData.s3url))\n            continue;\n        const downloadedFile = await downloadFileFromS3({\n            actionName,\n            s3Url: fileData.s3url,\n            mimeType: fileData.mimetype || \"application/txt\",\n        });\n        result.data[key] = {\n            uri: downloadedFile.filePath,\n            s3url: fileData.s3url,\n            mimeType: downloadedFile.mimeType,\n        };\n    }\n    return result;\n};\nconst FILE_SCHEMA_PROCESSOR = ({ toolSchema }) => {\n    const { properties, required: requiredProps = [] } = toolSchema.parameters;\n    const newProperties = { ...properties };\n    const newRequired = [...requiredProps];\n    for (const [key, property] of Object.entries(newProperties)) {\n        if (!property.file_uploadable)\n            continue;\n        const { type, keyName, description } = convertFileSchemaProperty(key, property);\n        newProperties[keyName] = {\n            title: property.title,\n            type,\n            description,\n        };\n        if (requiredProps.includes(key)) {\n            newRequired[newRequired.indexOf(key)] = keyName;\n        }\n        delete newProperties[key];\n    }\n    return {\n        ...toolSchema,\n        parameters: {\n            ...toolSchema.parameters,\n            properties: newProperties,\n            required: newRequired,\n        },\n    };\n};\n\nclass ComposioToolSet {\n    /**\n     * Creates a new instance of ComposioToolSet\n     * @param {Object} config - Configuration object\n     * @param {string|null} config.apiKey - API key for authentication\n     * @param {string|null} config.baseUrl - Base URL for API requests\n     * @param {string|null} config.runtime - Runtime environment\n     * @param {string} config.entityId - Entity ID for operations\n     * @param {Record<string, string>} config.connectedAccountIds - Map of app names to their connected account IDs\n     * @param {boolean} config.allowTracing - Whether to allow tracing for the SDK\n     */\n    constructor({ apiKey, baseUrl, runtime, entityId, connectedAccountIds, allowTracing, } = {}) {\n        this.entityId = \"default\";\n        this.connectedAccountIds = {};\n        this.internalProcessors = {\n            pre: [FILE_INPUT_PROCESSOR],\n            post: [FILE_DOWNLOADABLE_PROCESSOR],\n            schema: [FILE_SCHEMA_PROCESSOR],\n        };\n        this.userDefinedProcessors = {};\n        const clientApiKey = apiKey ||\n            getEnvVariable(\"COMPOSIO_API_KEY\") ||\n            getUserDataJson().api_key;\n        this.apiKey = clientApiKey;\n        this.client = new Composio({\n            apiKey: this.apiKey,\n            baseUrl: baseUrl || undefined,\n            runtime: runtime,\n            allowTracing: allowTracing || false,\n        });\n        this.runtime = runtime || null;\n        this.backendClient = this.client.backendClient;\n        this.connectedAccounts = this.client.connectedAccounts;\n        this.apps = this.client.apps;\n        this.actions = this.client.actions;\n        this.triggers = this.client.triggers;\n        this.integrations = this.client.integrations;\n        this.activeTriggers = this.client.activeTriggers;\n        this.connectedAccountIds = connectedAccountIds || {};\n        this.userActionRegistry = new ActionRegistry(this.client);\n        if (entityId && connectedAccountIds) {\n            logger.warn(\"When both entity and connectedAccountIds are provided, preference will be given to connectedAccountIds\");\n        }\n        if (connectedAccountIds) {\n            this.connectedAccountIds = connectedAccountIds;\n        }\n        if (entityId) {\n            this.entityId = entityId;\n        }\n    }\n    async getActionsSchema(filters = {}, _entityId) {\n        return this.getToolsSchema({\n            actions: filters.actions || [],\n        }, _entityId);\n    }\n    async getToolsSchema(filters, _entityId, _integrationId) {\n        var _a, _b;\n        const parsedFilters = ZToolSchemaFilter.parse(filters);\n        let actions = parsedFilters.actions;\n        if (_integrationId) {\n            const integration = await this.integrations.get({\n                integrationId: _integrationId,\n            });\n            if (integration === null || integration === void 0 ? void 0 : integration.limitedActions) {\n                if (!actions) {\n                    actions = [...integration.limitedActions];\n                }\n                else {\n                    const limitedActionsUppercase = integration.limitedActions.map((action) => action.toUpperCase());\n                    actions = actions.filter((action) => limitedActionsUppercase.includes(action.toUpperCase()));\n                }\n            }\n        }\n        const appActions = await this.client.actions.list({\n            apps: (_a = parsedFilters.apps) === null || _a === void 0 ? void 0 : _a.join(\",\"),\n            tags: (_b = parsedFilters.tags) === null || _b === void 0 ? void 0 : _b.join(\",\"),\n            useCase: parsedFilters.useCase,\n            actions: actions === null || actions === void 0 ? void 0 : actions.join(\",\"),\n            usecaseLimit: parsedFilters.useCaseLimit,\n            filterByAvailableApps: parsedFilters.filterByAvailableApps,\n        });\n        const customActions = await this.userActionRegistry.getAllActions();\n        const toolsWithCustomActions = customActions.filter((action) => {\n            const { name: actionName } = action || {};\n            return ((!filters.actions ||\n                filters.actions.some((name) => name.toLowerCase() === (actionName === null || actionName === void 0 ? void 0 : actionName.toLowerCase()))) &&\n                (!filters.tags ||\n                    filters.tags.some((tag) => tag.toLowerCase() === \"custom\")));\n        });\n        const toolsActions = [\n            ...((appActions === null || appActions === void 0 ? void 0 : appActions.items) || []),\n            ...toolsWithCustomActions,\n        ];\n        const allSchemaProcessor = [\n            ...this.internalProcessors.schema,\n            ...(this.userDefinedProcessors.schema\n                ? [this.userDefinedProcessors.schema]\n                : []),\n        ];\n        const processedTools = [];\n        // Iterate over the tools and process them\n        for (const tool of toolsActions) {\n            let schema = tool;\n            // Process the schema with all the processors\n            for (const processor of allSchemaProcessor) {\n                schema = await processor({\n                    actionName: schema === null || schema === void 0 ? void 0 : schema.name,\n                    toolSchema: schema,\n                });\n            }\n            processedTools.push(schema);\n        }\n        return processedTools;\n    }\n    async createAction(options) {\n        return this.userActionRegistry.createAction(options);\n    }\n    isCustomAction(action) {\n        return this.userActionRegistry\n            .getActions({ actions: [action] })\n            .then((actions) => actions.length > 0);\n    }\n    async getEntity(entityId) {\n        return this.client.getEntity(entityId);\n    }\n    async executeAction(functionParams) {\n        var _a;\n        const { action, params: inputParams = {}, entityId = this.entityId, nlaText = \"\", connectedAccountId, } = ZExecuteActionParams.parse({\n            action: functionParams.actionName || functionParams.action,\n            params: functionParams.params,\n            entityId: functionParams.entityId,\n            nlaText: functionParams.nlaText,\n            connectedAccountId: functionParams.connectedAccountId,\n        });\n        if (!entityId && !connectedAccountId) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                message: `No entityId or connectedAccountId provided`,\n                description: `Please provide either entityId or connectedAccountId`,\n            });\n        }\n        let params = inputParams || {};\n        const allInputProcessor = [\n            ...this.internalProcessors.pre,\n            ...(this.userDefinedProcessors.pre\n                ? [this.userDefinedProcessors.pre]\n                : []),\n        ];\n        for (const processor of allInputProcessor) {\n            params = await processor({\n                params: params,\n                actionName: action,\n                client: this.client.backendClient.instance,\n            });\n        }\n        // Custom actions are always executed in the host/local environment for JS SDK\n        let accountId = connectedAccountId;\n        if (await this.isCustomAction(action)) {\n            if (!accountId) {\n                const toolName = await this.userActionRegistry.getToolName({ action });\n                const connectedAccounts = await this.client.connectedAccounts.list({\n                    appNames: toolName,\n                    user_uuid: entityId,\n                    status: \"ACTIVE\",\n                    showActiveOnly: true,\n                });\n                accountId = (_a = connectedAccounts === null || connectedAccounts === void 0 ? void 0 : connectedAccounts.items[0]) === null || _a === void 0 ? void 0 : _a.id;\n            }\n            // allows the user to use custom actions and tools without a connected account\n            if (!accountId) {\n                logger.warn(\"No connected account found for the user. If your custom action requires a connected account, please double check if you have active accounts connected to it.\");\n            }\n            return this.userActionRegistry.executeAction(action, params, {\n                entityId: entityId,\n                connectionId: accountId,\n            });\n        }\n        const connectedAccountKeys = Object.keys(this.connectedAccountIds);\n        if (connectedAccountKeys.length > 0) {\n            const actionDetails = await this.actions.get({ actionName: action });\n            const appNameKey = connectedAccountKeys.find((key) => key.toLowerCase() === actionDetails.appName);\n            if (appNameKey) {\n                accountId = this.connectedAccountIds[appNameKey];\n            }\n        }\n        const data = await this.client.getEntity(entityId).execute({\n            actionName: action,\n            params: params,\n            text: nlaText,\n            connectedAccountId: accountId,\n        });\n        return this.processResponse(data, {\n            action: action,\n            entityId: entityId,\n        });\n    }\n    async processResponse(data, meta) {\n        const allOutputProcessor = [\n            ...this.internalProcessors.post,\n            ...(this.userDefinedProcessors.post\n                ? [this.userDefinedProcessors.post]\n                : []),\n        ];\n        // Dirty way to avoid copy\n        let dataToReturn = JSON.parse(JSON.stringify(data));\n        for (const processor of allOutputProcessor) {\n            dataToReturn = await processor({\n                actionName: meta.action,\n                toolResponse: dataToReturn,\n            });\n        }\n        return dataToReturn;\n    }\n    async addSchemaProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.schema = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async addPreProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.pre = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async addPostProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.post = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async removePreProcessor() {\n        delete this.userDefinedProcessors.pre;\n    }\n    async removePostProcessor() {\n        delete this.userDefinedProcessors.post;\n    }\n    async removeSchemaProcessor() {\n        delete this.userDefinedProcessors.schema;\n    }\n}\n\nconst COMPOSIO_BASE_URL = \"https://backend.composio.dev\";\n\n/**\n * CloudflareToolSet provides integration with Cloudflare Workers AI\n * for executing AI tool calls and handling responses\n */\nclass CloudflareToolSet extends ComposioToolSet {\n    /**\n     * Initialize a new CloudflareToolSet instance\n     *\n     * @param config Configuration options including API key, base URL, entity ID and workspace config\n     */\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: null,\n            entityId: config.entityId || CloudflareToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/cloudflare.ts\";\n    }\n    /**\n     * Retrieve available tools based on provided filters\n     *\n     * @param filters Optional filters for actions, apps, tags and use cases\n     * @returns Promise resolving to array of AI text generation tools\n     */\n    async getTools(filters) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const actions = await this.getToolsSchema(filters);\n        return (actions.map((action) => {\n            // Format the action schema for Cloudflare Workers AI\n            const formattedSchema = {\n                name: action.name,\n                description: action.description,\n                parameters: action.parameters,\n            };\n            const tool = {\n                type: \"function\",\n                function: formattedSchema,\n            };\n            return tool;\n        }) || []);\n    }\n    /**\n     * Execute a single tool call\n     *\n     * @param tool The tool to execute with name and arguments\n     * @param entityId Optional entity ID to execute the tool for\n     * @returns Promise resolving to stringified tool execution result\n     */\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.name,\n            params: typeof tool.arguments === \"string\"\n                ? JSON.parse(tool.arguments)\n                : tool.arguments,\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n    /**\n     * Handle tool calls from AI text generation output\n     *\n     * @param result The AI text generation output containing tool calls\n     * @param entityId Optional entity ID to execute the tools for\n     * @returns Promise resolving to array of tool execution results\n     */\n    async handleToolCall(result, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleToolCall\",\n            file: this.fileName,\n            params: { result, entityId },\n        });\n        const outputs = [];\n        if (\"tool_calls\" in result && Array.isArray(result.tool_calls)) {\n            for (const tool_call of result.tool_calls) {\n                if (tool_call.name) {\n                    outputs.push(await this.executeToolCall(tool_call, entityId));\n                }\n            }\n        }\n        return outputs;\n    }\n}\n// Class constants\nCloudflareToolSet.FRAMEWORK_NAME = \"cloudflare\";\nCloudflareToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass LangchainToolSet extends ComposioToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: (config === null || config === void 0 ? void 0 : config.runtime) || LangchainToolSet.FRAMEWORK_NAME,\n            entityId: config.entityId || LangchainToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/langchain.ts\";\n    }\n    _wrapTool(schema, entityId = null) {\n        var _a;\n        const action = schema[\"name\"];\n        const description = schema[\"description\"];\n        const appName = (_a = schema[\"appName\"]) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n        const func = async (...kwargs) => {\n            var _a;\n            const connectedAccountId = appName && ((_a = this.connectedAccountIds) === null || _a === void 0 ? void 0 : _a[appName]);\n            return JSON.stringify(await this.executeAction({\n                action,\n                params: kwargs[0],\n                entityId: entityId || this.entityId,\n                connectedAccountId: connectedAccountId,\n            }));\n        };\n        const parameters = jsonSchemaToModel(schema[\"parameters\"]);\n        // @TODO: Add escriiption an other stuff here\n        return new tools.DynamicStructuredTool({\n            name: action,\n            description,\n            schema: parameters,\n            func: func,\n        });\n    }\n    async getTools(filters = {}, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: { filters, entityId },\n        });\n        const tools = await this.getToolsSchema(filters, entityId, filters.integrationId);\n        return tools.map((tool) => this._wrapTool(tool, entityId || this.entityId));\n    }\n}\n/**\n * Composio toolset for Langchain framework.\n *\n */\nLangchainToolSet.FRAMEWORK_NAME = \"langchain\";\nLangchainToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass LangGraphToolSet extends LangchainToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            entityId: config.entityId || LangGraphToolSet.DEFAULT_ENTITY_ID,\n            runtime: LangGraphToolSet.FRAMEWORK_NAME,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n    }\n}\n/**\n * Composio toolset for Langgraph framework.\n *\n */\nLangGraphToolSet.FRAMEWORK_NAME = \"langGraph\";\nLangGraphToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass OpenAIToolSet extends ComposioToolSet {\n    /**\n     * Composio toolset for OpenAI framework.\n     *\n     * Example:\n     * ```typescript\n     *\n     * ```\n     */\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: OpenAIToolSet.FRAMEWORK_NAME,\n            entityId: config.entityId || OpenAIToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/openai.ts\";\n    }\n    async getTools(filters, entityId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const mainActions = await this.getToolsSchema(filters, entityId, filters.integrationId);\n        return (mainActions.map((action) => {\n            const formattedSchema = {\n                name: action.name,\n                description: action.description,\n                parameters: action.parameters,\n            };\n            const tool = {\n                type: \"function\",\n                function: formattedSchema,\n            };\n            return tool;\n        }) || []);\n    }\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.function.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.function.name,\n            params: JSON.parse(tool.function.arguments),\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n    async handleToolCall(chatCompletion, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleToolCall\",\n            file: this.fileName,\n            params: { chatCompletion, entityId },\n        });\n        const outputs = [];\n        for (const message of chatCompletion.choices) {\n            if (message.message.tool_calls) {\n                outputs.push(await this.executeToolCall(message.message.tool_calls[0], entityId));\n            }\n        }\n        return outputs;\n    }\n    async handleAssistantMessage(run, entityId = null) {\n        var _a, _b;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleAssistantMessage\",\n            file: this.fileName,\n            params: { run, entityId },\n        });\n        const tool_calls = ((_b = (_a = run.required_action) === null || _a === void 0 ? void 0 : _a.submit_tool_outputs) === null || _b === void 0 ? void 0 : _b.tool_calls) || [];\n        const tool_outputs = await Promise.all(tool_calls.map(async (tool_call) => {\n            logger.debug(`Executing tool call with ID: ${tool_call.function.name} and parameters: ${JSON.stringify(tool_call.function.arguments)}`);\n            const tool_response = await this.executeToolCall(tool_call, entityId || this.entityId);\n            logger.debug(`Received tool response: ${JSON.stringify(tool_response)}`);\n            return {\n                tool_call_id: tool_call.id,\n                output: JSON.stringify(tool_response),\n            };\n        }));\n        return tool_outputs;\n    }\n    async *waitAndHandleAssistantStreamToolCalls(client, runStream, thread, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"waitAndHandleAssistantStreamToolCalls\",\n            file: this.fileName,\n            params: { client, runStream, thread, entityId },\n        });\n        let runId = null;\n        // Start processing the runStream events\n        for await (const event of runStream) {\n            yield event; // Yield each event from the stream as it arrives\n            if (event.event === \"thread.run.created\") {\n                const { id } = event.data;\n                runId = id;\n            }\n            if (!runId) {\n                continue;\n            }\n            // Handle the 'requires_action' event\n            if (event.event === \"thread.run.requires_action\") {\n                const toolOutputs = await this.handleAssistantMessage(event.data, entityId);\n                // Submit the tool outputs\n                await client.beta.threads.runs.submitToolOutputs(thread.id, runId, {\n                    tool_outputs: toolOutputs,\n                });\n            }\n            // Break if the run status becomes inactive\n            if ([\n                \"thread.run.completed\",\n                \"thread.run.failed\",\n                \"thread.run.cancelled\",\n                \"thread.run.expired\",\n            ].includes(event.event)) {\n                break;\n            }\n        }\n        if (!runId) {\n            throw new Error(\"No run ID found\");\n        }\n        // Handle any final actions after the stream ends\n        let finalRun = await client.beta.threads.runs.retrieve(thread.id, runId);\n        while ([\"queued\", \"in_progress\", \"requires_action\"].includes(finalRun.status)) {\n            if (finalRun.status === \"requires_action\") {\n                const toolOutputs = await this.handleAssistantMessage(finalRun, entityId);\n                // Submit tool outputs\n                finalRun = await client.beta.threads.runs.submitToolOutputs(thread.id, runId, {\n                    tool_outputs: toolOutputs,\n                });\n            }\n            else {\n                // Update the run status\n                finalRun = await client.beta.threads.runs.retrieve(thread.id, runId);\n                await new Promise((resolve) => setTimeout(resolve, 500)); // Wait before rechecking\n            }\n        }\n    }\n    async waitAndHandleAssistantToolCalls(client, run, thread, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"waitAndHandleAssistantToolCalls\",\n            file: this.fileName,\n            params: { client, run, thread, entityId },\n        });\n        while ([\"queued\", \"in_progress\", \"requires_action\"].includes(run.status)) {\n            logger.debug(`Current run status: ${run.status}`);\n            const tool_outputs = await this.handleAssistantMessage(run, entityId || this.entityId);\n            if (run.status === \"requires_action\") {\n                logger.debug(`Submitting tool outputs for run ID: ${run.id} in thread ID: ${thread.id}`);\n                run = await client.beta.threads.runs.submitToolOutputs(thread.id, run.id, {\n                    tool_outputs: tool_outputs,\n                });\n            }\n            else {\n                run = await client.beta.threads.runs.retrieve(thread.id, run.id);\n                await new Promise((resolve) => setTimeout(resolve, 500));\n            }\n        }\n        return run;\n    }\n}\nOpenAIToolSet.FRAMEWORK_NAME = \"openai\";\nOpenAIToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nconst ZExecuteToolCallParams = z.z.object({\n    actions: z.z.array(z.z.string()).optional(),\n    apps: z.z.array(z.z.string()).optional(),\n    params: z.z.record(z.z.any()).optional(),\n    entityId: z.z.string().optional(),\n    useCase: z.z.string().optional(),\n    usecaseLimit: z.z.number().optional(),\n    connectedAccountId: z.z.string().optional(),\n    tags: z.z.array(z.z.string()).optional(),\n    filterByAvailableApps: z.z.boolean().optional().default(false),\n});\nclass VercelAIToolSet extends ComposioToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || null,\n            runtime: \"vercel-ai\",\n            entityId: config.entityId || \"default\",\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/vercel.ts\";\n    }\n    generateVercelTool(schema, entityId = null) {\n        return ai.tool({\n            description: schema.description,\n            // @ts-ignore the type are JSONSchemV7. Internally it's resolved\n            parameters: ai.jsonSchema(schema.parameters),\n            execute: async (params) => {\n                return await this.executeToolCall({\n                    name: schema.name,\n                    arguments: JSON.stringify(params),\n                }, entityId || this.entityId);\n            },\n        });\n    }\n    // change this implementation\n    async getTools(filters, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const { apps, tags, useCase, usecaseLimit, filterByAvailableApps, actions, } = ZExecuteToolCallParams.parse(filters);\n        const actionsList = await this.getToolsSchema({\n            apps,\n            actions,\n            tags,\n            useCase,\n            useCaseLimit: usecaseLimit,\n            filterByAvailableApps,\n        }, entityId, filters.integrationId);\n        const tools = {};\n        actionsList.forEach((actionSchema) => {\n            tools[actionSchema.name] = this.generateVercelTool(actionSchema, entityId);\n        });\n        return tools;\n    }\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.name,\n            params: typeof tool.arguments === \"string\"\n                ? JSON.parse(tool.arguments)\n                : tool.arguments,\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst { APPS, ACTIONS } = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/composio-core/constants.js\");\n\nexports.ACTIONS = ACTIONS;\nexports.APPS = APPS;\nexports.COMPOSIO_SDK_ERROR_CODES = COMPOSIO_SDK_ERROR_CODES;\nexports.CloudflareToolSet = CloudflareToolSet;\nexports.Composio = Composio;\nexports.ComposioError = ComposioError;\nexports.ComposioToolSet = ComposioToolSet;\nexports.ConnectionRequest = ConnectionRequest;\nexports.LangGraphToolSet = LangGraphToolSet;\nexports.LangchainToolSet = LangchainToolSet;\nexports.OpenAIToolSet = OpenAIToolSet;\nexports.VercelAIToolSet = VercelAIToolSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3RUFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsb0dBQU07QUFDekIsUUFBUSxtQkFBTyxDQUFDLDBEQUFLO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLG1HQUF1QjtBQUNqRCxzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxtR0FBdUI7QUFDM0MsU0FBUyxtQkFBTyxDQUFDLDREQUFJOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLElBQUksUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTLEdBQUcsWUFBWSxTQUFTLDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBLHFCQUFxQixhQUFhO0FBQ2xDLGlCQUFpQixhQUFhLEVBQUUsV0FBVztBQUMzQyxnQkFBZ0IsS0FBSztBQUNyQixtQkFBbUIsWUFBWTtBQUMvQixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGlDQUFpQywwQkFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxFQUFFLG1CQUFPLENBQUMsb0NBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxHQUFHLFlBQVksU0FBUywwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RSxZQUFZLDJGQUEyRjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtB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QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxtQkFBbUIsRUFBRSxZQUFZO0FBQzVFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsUUFBUTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0JBQW9CO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLHFFQUFxRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLCtFQUFhOztBQUUvQyxlQUFlO0FBQ2YsWUFBWTtBQUNaLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL29yYml0YWwtYWktYWdlbnQvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9pbmRleC5qcz82ZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIHogPSByZXF1aXJlKCd6b2QnKTtcbnZhciBjbGllbnRBeGlvcyA9IHJlcXVpcmUoJ0BoZXktYXBpL2NsaWVudC1heGlvcycpO1xudmFyIHpvZFRvSnNvblNjaGVtYSA9IHJlcXVpcmUoJ3pvZC10by1qc29uLXNjaGVtYScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgdG9vbHMgPSByZXF1aXJlKCdAbGFuZ2NoYWluL2NvcmUvdG9vbHMnKTtcbnZhciBhaSA9IHJlcXVpcmUoJ2FpJyk7XG5cbmNvbnN0IENPTVBPU0lPX1ZFUlNJT04gPSBgMC41LjM5YDtcblxuY29uc3QgZ2V0VVVJRCA9ICgpID0+IHtcbiAgICByZXR1cm4gdXVpZC52NCgpO1xufTtcblxuZnVuY3Rpb24ganNvblNjaGVtYVByb3BlcnRpZXNUb1RTVHlwZXModmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHoub2JqZWN0KHt9KTtcbiAgICB9XG4gICAgbGV0IHpvZFR5cGU7XG4gICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6XG4gICAgICAgICAgICAgICAgLnN0cmluZygpXG4gICAgICAgICAgICAgICAgLmRlc2NyaWJlKCh2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHZhbHVlLmV4YW1wbGVzID8gYFxcbkV4YW1wbGVzOiAke3ZhbHVlLmV4YW1wbGVzLmpvaW4oXCIsIFwiKX1gIDogXCJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6XG4gICAgICAgICAgICAgICAgLm51bWJlcigpXG4gICAgICAgICAgICAgICAgLmRlc2NyaWJlKCh2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHZhbHVlLmV4YW1wbGVzID8gYFxcbkV4YW1wbGVzOiAke3ZhbHVlLmV4YW1wbGVzLmpvaW4oXCIsIFwiKX1gIDogXCJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgICAgICB6b2RUeXBlID0gelxuICAgICAgICAgICAgICAgIC5udW1iZXIoKVxuICAgICAgICAgICAgICAgIC5pbnQoKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgem9kVHlwZSA9IHpcbiAgICAgICAgICAgICAgICAuYm9vbGVhbigpXG4gICAgICAgICAgICAgICAgLmRlc2NyaWJlKCh2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHZhbHVlLmV4YW1wbGVzID8gYFxcbkV4YW1wbGVzOiAke3ZhbHVlLmV4YW1wbGVzLmpvaW4oXCIsIFwiKX1gIDogXCJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgem9kVHlwZSA9IHpcbiAgICAgICAgICAgICAgICAuYXJyYXkoanNvblNjaGVtYVByb3BlcnRpZXNUb1RTVHlwZXModmFsdWUuaXRlbXMpKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICB6b2RUeXBlID0ganNvblNjaGVtYVRvTW9kZWwodmFsdWUpLmRlc2NyaWJlKCh2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHZhbHVlLmV4YW1wbGVzID8gYFxcbkV4YW1wbGVzOiAke3ZhbHVlLmV4YW1wbGVzLmpvaW4oXCIsIFwiKX1gIDogXCJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICB6b2RUeXBlID0gei5udWxsKCkuZGVzY3JpYmUodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgSlNPTiBzY2hlbWEgdHlwZTogJHt2YWx1ZS50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gem9kVHlwZTtcbn1cbmZ1bmN0aW9uIGpzb25TY2hlbWFUb01vZGVsKGpzb25TY2hlbWEpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ganNvblNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0ganNvblNjaGVtYS5yZXF1aXJlZCB8fCBbXTtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHoub2JqZWN0KHt9KTtcbiAgICB9XG4gICAgY29uc3Qgem9kU2NoZW1hID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBfXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IF87XG4gICAgICAgIGxldCB6b2RUeXBlO1xuICAgICAgICBpZiAodmFsdWUuYW55T2YpIHtcbiAgICAgICAgICAgIGNvbnN0IGFueU9mVHlwZXMgPSB2YWx1ZS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4ganNvblNjaGVtYVByb3BlcnRpZXNUb1RTVHlwZXMoc2NoZW1hKSk7XG4gICAgICAgICAgICB6b2RUeXBlID0gelxuICAgICAgICAgICAgICAgIC51bmlvbihhbnlPZlR5cGVzKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlc1xuICAgICAgICAgICAgICAgICAgICA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5hbGxPZikge1xuICAgICAgICAgICAgY29uc3QgYWxsT2ZUeXBlcyA9IHZhbHVlLmFsbE9mLm1hcCgoc2NoZW1hKSA9PiBqc29uU2NoZW1hUHJvcGVydGllc1RvVFNUeXBlcyhzY2hlbWEpKTtcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6XG4gICAgICAgICAgICAgICAgLmludGVyc2VjdGlvbihhbGxPZlR5cGVzWzBdLCBhbGxPZlR5cGVzXG4gICAgICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IGFjYy5hbmQoc2NoZW1hKSwgYWxsT2ZUeXBlc1swXSkpXG4gICAgICAgICAgICAgICAgLmRlc2NyaWJlKCh2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHZhbHVlLmV4YW1wbGVzXG4gICAgICAgICAgICAgICAgICAgID8gYFxcbkV4YW1wbGVzOiAke3ZhbHVlLmV4YW1wbGVzLmpvaW4oXCIsIFwiKX1gXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUudHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b2RUeXBlID0ganNvblNjaGVtYVByb3BlcnRpZXNUb1RTVHlwZXModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgem9kVHlwZSA9IHpvZFR5cGUuZGVzY3JpYmUodmFsdWUuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1aXJlZEZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICB6b2RTY2hlbWFba2V5XSA9IHpvZFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB6b2RTY2hlbWFba2V5XSA9IHpvZFR5cGUub3B0aW9uYWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gei5vYmplY3Qoem9kU2NoZW1hKTtcbn1cbmNvbnN0IGdldEVudlZhcmlhYmxlID0gKG5hbWUsIGRlZmF1bHRWYWx1ZSA9IHVuZGVmaW5lZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudltuYW1lXSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChfZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbn07XG5cbi8vIERlZmluZSBsb2cgbGV2ZWxzIHdpdGggY29ycmVzcG9uZGluZyBwcmlvcml0aWVzXG5jb25zdCBMT0dfTEVWRUxTID0ge1xuICAgIHNpbGVudDogLTEsIC8vIE5vIGxvZ3NcbiAgICBlcnJvcjogMCwgLy8gSGlnaGVzdCBwcmlvcml0eSAtIGNyaXRpY2FsIGVycm9yc1xuICAgIHdhcm46IDEsIC8vIFdhcm5pbmcgbWVzc2FnZXNcbiAgICBpbmZvOiAyLCAvLyBHZW5lcmFsIGluZm9ybWF0aW9uXG4gICAgZGVidWc6IDMsIC8vIERlYnVnIGluZm9ybWF0aW9uXG59O1xuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICogRGVmYXVsdHMgdG8gJ2luZm8nIGlmIG5vdCBzZXQgb3IgaW52YWxpZC5cbiAqIEByZXR1cm5zIHtrZXlvZiB0eXBlb2YgTE9HX0xFVkVMU30gVGhlIGN1cnJlbnQgbG9nIGxldmVsXG4gKi9cbmNvbnN0IGdldExvZ0xldmVsID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlbnZMZXZlbCA9IChfYSA9IGdldEVudlZhcmlhYmxlKFwiQ09NUE9TSU9fTE9HR0lOR19MRVZFTFwiLCBcImluZm9cIikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBlbnZMZXZlbCAmJiBlbnZMZXZlbCBpbiBMT0dfTEVWRUxTXG4gICAgICAgID8gZW52TGV2ZWxcbiAgICAgICAgOiBcImluZm9cIjtcbn07XG5jb25zdCBhZGRUaW1lc3RhbXBUb01lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICByZXR1cm4gYCR7dGltZXN0YW1wfSAtICR7bWVzc2FnZX1gO1xufTtcbmNvbnN0IGZvcm1hdEVycm9yTWVzc2FnZSA9IChhcmdzKSA9PiB7XG4gICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgLm1hcCgoYXJnKSA9PiAodHlwZW9mIGFyZyA9PT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KGFyZykgOiBhcmcpKVxuICAgICAgICAuam9pbihcIiBcIik7XG59O1xuY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICAgIGNvbnN0IGxvZ2dlciA9IGNvbnNvbGU7XG4gICAgY29uc3QgbG9nZ2luZ0xldmVsID0gZ2V0TG9nTGV2ZWwoKTtcbiAgICBjb25zdCBsb2dMZXZlbFZhbHVlID0gTE9HX0xFVkVMU1tsb2dnaW5nTGV2ZWxdO1xuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGxvZ0xldmVsVmFsdWUgPj0gTE9HX0xFVkVMUy5lcnJvclxuICAgICAgICAgICAgPyAoLi4uYXJncykgPT4gbG9nZ2VyLmVycm9yKGFkZFRpbWVzdGFtcFRvTWVzc2FnZShmb3JtYXRFcnJvck1lc3NhZ2UoYXJncykpKVxuICAgICAgICAgICAgOiBub29wLFxuICAgICAgICB3YXJuOiBsb2dMZXZlbFZhbHVlID49IExPR19MRVZFTFMud2FyblxuICAgICAgICAgICAgPyAoLi4uYXJncykgPT4gbG9nZ2VyLndhcm4oYWRkVGltZXN0YW1wVG9NZXNzYWdlKGZvcm1hdEVycm9yTWVzc2FnZShhcmdzKSkpXG4gICAgICAgICAgICA6IG5vb3AsXG4gICAgICAgIGluZm86IGxvZ0xldmVsVmFsdWUgPj0gTE9HX0xFVkVMUy5pbmZvXG4gICAgICAgICAgICA/ICguLi5hcmdzKSA9PiBsb2dnZXIuaW5mbyhhZGRUaW1lc3RhbXBUb01lc3NhZ2UoZm9ybWF0RXJyb3JNZXNzYWdlKGFyZ3MpKSlcbiAgICAgICAgICAgIDogbm9vcCxcbiAgICAgICAgZGVidWc6IGxvZ0xldmVsVmFsdWUgPj0gTE9HX0xFVkVMUy5kZWJ1Z1xuICAgICAgICAgICAgPyAoLi4uYXJncykgPT4gbG9nZ2VyLmRlYnVnKGFkZFRpbWVzdGFtcFRvTWVzc2FnZShmb3JtYXRFcnJvck1lc3NhZ2UoYXJncykpKVxuICAgICAgICAgICAgOiBub29wLFxuICAgIH07XG59O1xudmFyIGxvZ2dlciA9IGdldExvZ2dlcigpO1xuXG5jb25zdCBaQXV0aE1vZGUgPSB6LnouZW51bShbXG4gICAgXCJPQVVUSDJcIixcbiAgICBcIk9BVVRIMVwiLFxuICAgIFwiT0FVVEgxQVwiLFxuICAgIFwiQVBJX0tFWVwiLFxuICAgIFwiQkFTSUNcIixcbiAgICBcIkJFQVJFUl9UT0tFTlwiLFxuICAgIFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVFwiLFxuICAgIFwiTk9fQVVUSFwiLFxuICAgIFwiQkFTSUNfV0lUSF9KV1RcIixcbl0pO1xuY29uc3QgWkNyZWF0ZUludGVncmF0aW9uUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgbmFtZTogei56LnN0cmluZygpLFxuICAgIGF1dGhTY2hlbWU6IFpBdXRoTW9kZS5vcHRpb25hbCgpLFxuICAgIGFwcFVuaXF1ZUtleTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXBwSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGZvcmNlTmV3SW50ZWdyYXRpb246IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBhdXRoQ29uZmlnOiB6LnpcbiAgICAgICAgLnVuaW9uKFtcbiAgICAgICAgei56LnJlY29yZCh6LnoudW5rbm93bigpKSxcbiAgICAgICAgei56Lm9iamVjdCh7XG4gICAgICAgICAgICBjbGllbnRfaWQ6IHouei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHouei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGFwaV9rZXk6IHouei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbnN1bWVyX2tleTogei56LnN0cmluZygpLFxuICAgICAgICAgICAgY29uc3VtZXJfc2VjcmV0OiB6Lnouc3RyaW5nKCksXG4gICAgICAgICAgICBiYXNlX3VybDogei56LnN0cmluZygpLFxuICAgICAgICB9KSxcbiAgICBdKVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB1c2VDb21wb3Npb0F1dGg6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlNpbmdsZUludGVncmF0aW9uUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaTGlzdEludGVncmF0aW9uc1BhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIHBhZ2U6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIHBhZ2VTaXplOiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBhcHBVbmlxdWVLZXk6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHNob3dEaXNhYmxlZDogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxufSk7XG5cbmNvbnN0IFpFeGVjdXRlQWN0aW9uUGFyYW1zJDEgPSB6Lnoub2JqZWN0KHtcbiAgICBhY3Rpb25OYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgcGFyYW1zOiB6LnoucmVjb3JkKHouei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICB0ZXh0OiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBaSW5pdGlhdGVDb25uZWN0aW9uUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgYXBwTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXV0aENvbmZpZzogei56LnJlY29yZCh6LnouYW55KCkpLm9wdGlvbmFsKCksXG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXV0aE1vZGU6IFpBdXRoTW9kZS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3Rpb25QYXJhbXM6IHouei5yZWNvcmQoei56LmFueSgpKS5vcHRpb25hbCgpLFxuICAgIGNvbmZpZzogei56XG4gICAgICAgIC5vYmplY3Qoe1xuICAgICAgICBsYWJlbHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlZGlyZWN0VXJsOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICByZWRpcmVjdFVyaTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgbGFiZWxzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBaQ29ubmVjdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXBwOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlRyaWdnZXJTdWJzY3JpYmVQYXJhbSA9IHouei5vYmplY3Qoe1xuICAgIGFwcDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXBwTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdHJpZ2dlck5hbWU6IHouei5zdHJpbmcoKSxcbiAgICBjb25maWc6IHouei5yZWNvcmQoei56LmFueSgpKSxcbn0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc3RyaW5naWZ5IG9iamVjdHMgaWYgbmVlZGVkXG5jb25zdCBzZXJpYWxpemVWYWx1ZSA9IChvYmopID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KG9iaikgOiBvYmo7XG59O1xuXG4vLyBDb25zdGFudHNcbmNvbnN0IENPTVBPU0lPX0RJUiA9IFwiLmNvbXBvc2lvXCI7XG5jb25zdCBVU0VSX0RBVEFfRklMRV9OQU1FID0gXCJ1c2VyX2RhdGEuanNvblwiO1xuY29uc3QgVEVNUF9GSUxFU19ESVJFQ1RPUllfTkFNRSA9IFwiZmlsZXNcIjtcbmNvbnN0IERFRkFVTFRfQkFTRV9VUkwgPSBcImh0dHBzOi8vYmFja2VuZC5jb21wb3Npby5kZXZcIjtcbmNvbnN0IFRFTEVNRVRSWV9VUkwgPSBcImh0dHBzOi8vYXBwLmNvbXBvc2lvLmRldlwiO1xuY29uc3QgSVNfREVWRUxPUE1FTlRfT1JfQ0kgPSBwcm9jZXNzLmVudi5ERVZFTE9QTUVOVCB8fCBwcm9jZXNzLmVudi5DSSB8fCBmYWxzZTtcblxuLyoqXG4gKiBTZW5kcyBhIHJlcG9ydGluZyBwYXlsb2FkIHRvIHRoZSB0ZWxlbWV0cnkgc2VydmVyIHVzaW5nIGEgY2hpbGQgcHJvY2Vzcy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIHVzZSBpbiBOb2RlLmpzIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0ge2FueX0gcmVwb3J0aW5nUGF5bG9hZCAtIFRoZSBwYXlsb2FkIHRvIGJlIHNlbnQgdG8gdGhlIHRlbGVtZXRyeSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIHNlbmRQcm9jZXNzUmVxKGluZm8pIHtcbiAgICBpZiAoSVNfREVWRUxPUE1FTlRfT1JfQ0kpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBIaXR0aW5nICR7aW5mby51cmx9WyR7aW5mby5tZXRob2R9XSB3aXRoICR7c2VyaWFsaXplVmFsdWUoaW5mby5kYXRhKX1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaW5mby51cmwpO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgICAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgfHwgKHVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IDQ0MyA6IDgwKTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgICAgIFwiLWVcIixcbiAgICAgICAgICAgIGBcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKCcke3Byb3RvY29sfScpO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcke3VybC5ob3N0bmFtZX0nLFxuICAgICAgICBwYXRoOiAnJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofScsXG4gICAgICAgIHBvcnQ6ICR7cG9ydH0sXG4gICAgICAgIG1ldGhvZDogJyR7aW5mby5tZXRob2R9JyxcbiAgICAgICAgaGVhZGVyczogJHtKU09OLnN0cmluZ2lmeShpbmZvLmhlYWRlcnMpfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVxID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMsIChyZXMpID0+IHtcbiAgICAgICAgcmVzLm9uKCdkYXRhJywgKCkgPT4ge30pO1xuICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJlcS5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXEud3JpdGUoSlNPTi5zdHJpbmdpZnkoJHtKU09OLnN0cmluZ2lmeShpbmZvLmRhdGEpfSkpO1xuICAgICAgcmVxLmVuZCgpO1xuICAgICAgYCxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gVXNlIHNwYXduIHdpdGggZGV0YWNoZWQgb3B0aW9uIGluc3RlYWQgb2Ygc3Bhd25TeW5jIHRvIG1ha2UgaXQgbm9uLWJsb2NraW5nXG4gICAgICAgIGNvbnN0IHsgc3Bhd24gfSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuICAgICAgICBzcGF3bihcIm5vZGVcIiwgYXJncywge1xuICAgICAgICAgICAgc3RkaW86IFwiaWdub3JlXCIsXG4gICAgICAgICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgIHNoZWxsOiBmYWxzZSxcbiAgICAgICAgfSkudW5yZWYoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFcnJvciBzZW5kaW5nIGVycm9yIHRvIHRlbGVtZXRyeVwiLCBlcnJvcik7XG4gICAgICAgIC8vIERPIE5PVEhJTkdcbiAgICB9XG59XG4vKipcbiAqIFNlbmRzIGEgcmVwb3J0aW5nIHBheWxvYWQgdG8gdGhlIHRlbGVtZXRyeSBzZXJ2ZXIgdXNpbmcgWE1MSHR0cFJlcXVlc3QuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciB1c2UgaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIHthbnl9IHJlcG9ydGluZ1BheWxvYWQgLSBUaGUgcGF5bG9hZCB0byBiZSBzZW50IHRvIHRoZSB0ZWxlbWV0cnkgc2VydmVyLlxuICovXG5mdW5jdGlvbiBzZW5kQnJvd3NlclJlcShpbmZvKSB7XG4gICAgaWYgKElTX0RFVkVMT1BNRU5UX09SX0NJKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgSGl0dGluZyAke2luZm8udXJsfVske2luZm8ubWV0aG9kfV0gd2l0aCAke3NlcmlhbGl6ZVZhbHVlKGluZm8uZGF0YSl9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAvLyBPcGVuIGEgbmV3IFBPU1QgcmVxdWVzdCB0byB0aGUgdGVsZW1ldHJ5IHNlcnZlclxuICAgICAgICB4aHIub3BlbihpbmZvLm1ldGhvZCwgaW5mby51cmwsIHRydWUpO1xuICAgICAgICAvLyBTZXQgdGhlIHJlcXVlc3QgaGVhZGVyIHRvIGluZGljYXRlIEpTT04gY29udGVudFxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGluZm8uaGVhZGVycyB8fCB7fSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERlZmluZSB0aGUgb25sb2FkIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIExvZyB0aGUgcmVzcG9uc2UgaWYgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2VuZCB0aGUgcmVwb3J0aW5nIHBheWxvYWQgYXMgYSBKU09OIHN0cmluZ1xuICAgICAgICB4aHIuc2VuZChKU09OLnN0cmluZ2lmeShpbmZvLmRhdGEpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkVycm9yIHNlbmRpbmcgZXJyb3IgdG8gdGVsZW1ldHJ5XCIsIGVycm9yKTtcbiAgICAgICAgLy8gRE8gTk9USElOR1xuICAgIH1cbn1cblxuLypcbiAgICBDb21wb3Npb0NvbnRleHQgY2xhc3MgcHJvdmlkZXMgYSBnbG9iYWwgY29udGV4dCBmb3Igc3RvcmluZyBTREsgY29uZmlndXJhdGlvbi5cbiAgICBUaGlzIHNpbmdsZXRvbiBjbGFzcyBtYWludGFpbnMgZXNzZW50aWFsIFNESyBzZXR0aW5ncyBsaWtlIEFQSSBrZXkgYW5kIGJhc2UgVVJMLlxuICAgIEl0IGlzIHVzZWQgdG8gc3RvcmUgdGhlIEFQSSBrZXkgYW5kIGJhc2UgVVJMIGluIGEgZ2xvYmFsIGNvbnRleHQgc28gdGhhdCBpdCBjYW4gYmUgYWNjZXNzZWQgYnkgb3RoZXIgbW9kdWxlcyB3aXRob3V0IGhhdmluZyB0byBwYXNzIHRoZSBjb25maWd1cmF0aW9uIGFyb3VuZC5cblxuICAgIFdhcm5pbmc6IENhbiBjYXVzZSBwcm9ibGVtcyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBTREsgcnVubmluZyBpbiB0aGUgc2FtZSBwcm9jZXNzLlxuKi9cbmNsYXNzIENvbXBvc2lvU0RLQ29udGV4dCB7XG59XG5Db21wb3Npb1NES0NvbnRleHQuc291cmNlID0gXCJqYXZhc2NyaXB0XCI7XG5cbmFzeW5jIGZ1bmN0aW9uIGxvZ0Vycm9yKHBheWxvYWQpIHtcbiAgICBjb25zdCBpc1RlbGVtZXRyeURpc2FibGVkID0gZ2V0RW52VmFyaWFibGUoXCJURUxFTUVUUllfRElTQUJMRURcIiwgXCJmYWxzZVwiKSA9PT0gXCJ0cnVlXCI7XG4gICAgaWYgKGlzVGVsZW1ldHJ5RGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICBjb25zdCByZXBvcnRpbmdQYXlsb2FkID0gZ2VuZXJhdGVSZXBvcnRpbmdQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBjb25zdCByZXFQYXlsb2FkID0ge1xuICAgICAgICAgICAgZGF0YTogcmVwb3J0aW5nUGF5bG9hZCxcbiAgICAgICAgICAgIHVybDogYCR7VEVMRU1FVFJZX1VSTH0vYXBpL3Nka19tZXRyaWNzL2Vycm9yYCxcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICBhd2FpdCBzZW5kQnJvd3NlclJlcShyZXFQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHNlbmRQcm9jZXNzUmVxKHJlcVBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFcnJvciBzZW5kaW5nIGVycm9yIHRvIHRlbGVtZXRyeVwiLCBlcnJvcik7XG4gICAgICAgIC8vIERPIE5PVEhJTkdcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVJlcG9ydGluZ1BheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IHsgYXBpS2V5LCBiYXNlVVJMLCBjb21wb3Npb1ZlcnNpb24sIGZyYW1ld29ya1J1bnRpbWUsIHNvdXJjZSB9ID0gQ29tcG9zaW9TREtDb250ZXh0O1xuICAgIGNvbnN0IHsgZXJyb3JfaWQsIGVycm9yX2NvZGUsIGRlc2NyaXB0aW9uLCBtZXNzYWdlLCBwb3NzaWJsZV9maXgsIG9yaWdpbmFsX2Vycm9yLCBjdXJyZW50X3N0YWNrLCB9ID0gcGF5bG9hZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcl9pZCxcbiAgICAgICAgZXJyb3JfY29kZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGVycm9yX21lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHBvc3NpYmxlX2ZpeCxcbiAgICAgICAgb3JpZ2luYWxfZXJyb3IsXG4gICAgICAgIGN1cnJlbnRfc3RhY2ssXG4gICAgICAgIHNka19tZXRhOiB7XG4gICAgICAgICAgICBwbGF0Zm9ybTogcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgIHZlcnNpb246IGNvbXBvc2lvVmVyc2lvbixcbiAgICAgICAgICAgIGJhc2VVUkwsXG4gICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICBmcmFtZXdvcmtSdW50aW1lLFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbi8qKlxuICogQ3VzdG9tIGVycm9yIGNsYXNzIGZvciBDb21wb3NpbyB0aGF0IHByb3ZpZGVzIHJpY2ggZXJyb3IgZGV0YWlscywgdHJhY2tpbmcsIGFuZCBpbXByb3ZlZCBkZWJ1Z2dpbmdcbiAqL1xuY2xhc3MgQ29tcG9zaW9FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJDb2RlLCBtZXNzYWdlLCBkZXNjcmlwdGlvbiwgcG9zc2libGVGaXgsIG1ldGFkYXRhLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gRW5zdXJlIG1lc3NhZ2UgaXMgbmV2ZXIgZW1wdHlcbiAgICAgICAgc3VwZXIobWVzc2FnZSB8fCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIik7XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgbWV0YWRhdGEgYWJvdXQgdGhlIGVycm9yXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB7fTtcbiAgICAgICAgLy8gRW5zdXJlIHByb3BlciBwcm90b3R5cGUgY2hhaW4gZm9yIGluc3RhbmNlb2YgY2hlY2tzXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQ29tcG9zaW9FcnJvclwiO1xuICAgICAgICB0aGlzLmVyckNvZGUgPSBlcnJDb2RlO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMucG9zc2libGVGaXggPSBwb3NzaWJsZUZpeDtcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5lcnJvcklkID0gZ2V0VVVJRCgpO1xuICAgICAgICBsZXQgb3JpZ2luYWxFcnJvclN0cmluZyA9IFwiXCI7XG4gICAgICAgIC8vIE9ubHkgcHJpbnQgb3JpZ2luYWwgZXJyb3IgaWYgQ09NUE9TSU9fTE9HR0lOR19MRVZFTCBpcyBkZWJ1Z1xuICAgICAgICBpZiAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yU3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcmlnaW5hbEVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JTdHJpbmcgPSBTdHJpbmcob3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSA9PT0gXCJkZWJ1Z1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3JTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBpbiBjYXNlIG9mIGluZm8gb3IgZGVidWcsIHdlIHdpbGwgbG9nIHRoZSBlcnJvclxuICAgICAgICBpZiAoTE9HX0xFVkVMU1tnZXRMb2dMZXZlbCgpXSA+PSAyKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhg8J+agCBbSW5mb10gR2l2ZSBGZWVkYmFjayAvIEdldCBIZWxwOiBodHRwczovL2R1Yi5jb21wb3Npby5kZXYvZGlzY29yZCBgKTtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGDwn5CbIFtJbmZvXSBDcmVhdGUgYSBuZXcgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Db21wb3Npb0hRL2NvbXBvc2lvL2lzc3VlcyBgKTtcbiAgICAgICAgICAgIGlmIChnZXRMb2dMZXZlbCgpICE9PSBcImRlYnVnXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhg4puUIFtJbmZvXSBJZiB5b3UgbmVlZCB0byBkZWJ1ZyB0aGlzIGVycm9yLCBzZXQgZW52IHZhcmlhYmxlIENPTVBPU0lPX0xPR0dJTkdfTEVWRUw9ZGVidWdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dFcnJvcih7XG4gICAgICAgICAgICBlcnJvcl9pZDogdGhpcy5lcnJvcklkLFxuICAgICAgICAgICAgZXJyb3JfY29kZTogdGhpcy5lcnJDb2RlLFxuICAgICAgICAgICAgb3JpZ2luYWxfZXJyb3I6IG9yaWdpbmFsRXJyb3JTdHJpbmcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEgfHwge30sXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBwb3NzaWJsZV9maXg6IHRoaXMucG9zc2libGVGaXggfHwgXCJcIixcbiAgICAgICAgICAgIGN1cnJlbnRfc3RhY2s6ICgoX2EgPSB0aGlzLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoXCJcXG5cIikpIHx8IFtdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FwdHVyZSBzdGFjayB0cmFjZSwgZXhjbHVkaW5nIGNvbnN0cnVjdG9yIGNhbGxcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGdldCBvcmlnaW5hbEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxFcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbXBsZXRlIG9iamVjdCByZXByZXNlbnRhdGlvbiBmb3IgbG9nZ2luZy9zZXJpYWxpemF0aW9uXG4gICAgICogSW5jbHVkZXMgYWxsIGVycm9yIGRldGFpbHMgYW5kIG1ldGFkYXRhXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZXJyb3JPYmogPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBlcnJvcklkOiB0aGlzLmVycm9ySWQsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmVyckNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBvc3NpYmxlRml4OiB0aGlzLnBvc3NpYmxlRml4LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHN0YWNrOiAoX2EgPSB0aGlzLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrOiAoX2MgPSAoX2IgPSB0aGlzLm9yaWdpbmFsRXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICB9O1xuICAgICAgICAvLyBSZW1vdmUgdW5kZWZpbmVkL251bGwgcHJvcGVydGllc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZXJyb3JPYmopLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG5cbmNvbnN0IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUyA9IHtcbiAgICBCQUNLRU5EOiB7XG4gICAgICAgIE5PVF9GT1VORDogXCJCQUNLRU5EOjpOT1RfRk9VTkRcIixcbiAgICAgICAgUkFURV9MSU1JVDogXCJCQUNLRU5EOjpSQVRFX0xJTUlUXCIsXG4gICAgICAgIEJBRF9SRVFVRVNUOiBcIkJBQ0tFTkQ6OkJBRF9SRVFVRVNUXCIsXG4gICAgICAgIFVOQVVUSE9SSVpFRDogXCJCQUNLRU5EOjpVTkFVVEhPUklaRURcIixcbiAgICAgICAgU0VSVkVSX0VSUk9SOiBcIkJBQ0tFTkQ6OlNFUlZFUl9FUlJPUlwiLFxuICAgICAgICBTRVJWRVJfVU5BVkFJTEFCTEU6IFwiQkFDS0VORDo6U0VSVkVSX1VOQVZBSUxBQkxFXCIsXG4gICAgICAgIFNFUlZFUl9VTlJFQUNIQUJMRTogXCJCQUNLRU5EOjpTRVJWRVJfVU5SRUFDSEFCTEVcIixcbiAgICAgICAgVU5LTk9XTjogXCJCQUNLRU5EOjpVTktOT1dOXCIsXG4gICAgfSxcbiAgICBDT01NT046IHtcbiAgICAgICAgQVBJX0tFWV9VTkFWQUlMQUJMRTogXCJDT01NT046OkFQSV9LRVlfSU5WQUxJRFwiLFxuICAgICAgICBCQVNFX1VSTF9OT1RfUkVBQ0hBQkxFOiBcIkNPTU1PTjo6QkFTRV9VUkxfTk9UX1JFQUNIQUJMRVwiLFxuICAgICAgICBVTktOT1dOOiBcIkNPTU1PTjo6RVJST1JfQ09ERV9OT1RfREVGSU5FRFwiLFxuICAgICAgICBTRVJWRVJfVU5BVkFJTEFCTEU6IFwiQ09NTU9OOjpTRVJWRVJfVU5BVkFJTEFCTEVcIixcbiAgICAgICAgUkVRVUVTVF9USU1FT1VUOiBcIkNPTU1PTjo6UkVRVUVTVF9USU1FT1VUXCIsXG4gICAgICAgIFJFUVVFU1RfQUJPUlRFRDogXCJDT01NT046OlJFUVVFU1RfQUJPUlRFRFwiLFxuICAgICAgICBJTlZBTElEX1BBUkFNU19QQVNTRUQ6IFwiQ09NTU9OOjpJTlZBTElEX1BBUkFNU19QQVNTRURcIixcbiAgICB9LFxuICAgIFNESzoge1xuICAgICAgICBOT19DT05ORUNURURfQUNDT1VOVF9GT1VORDogXCJTREs6Ok5PX0NPTk5FQ1RFRF9BQ0NPVU5UX0ZPVU5EXCIsXG4gICAgICAgIEZBSUxFRF9UT19JTklUSUFURV9DT05ORUNUSU9OOiBcIlNESzo6RkFJTEVEX1RPX0lOSVRJQVRFX0NPTk5FQ1RJT05cIixcbiAgICAgICAgSU5WQUxJRF9QQVJBTUVURVI6IFwiU0RLOjpJTlZBTElEX1BBUkFNRVRFUlwiLFxuICAgIH0sXG59O1xuY29uc3QgQkFTRV9FUlJPUl9DT0RFX0lORk8gPSB7XG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELk5PVF9GT1VORF06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5SNIEFQSSBub3QgZm91bmRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHJlcXVlc3RlZCByZXNvdXJjZSBpcyBtaXNzaW5nXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIkVuc3VyZSB0aGUgcmVzb3VyY2UgaWQgb3IgcmVzb3VyY2UgaWRlbnRpZmllciBpcyBjb3JyZWN0IGFuZCB2YWxpZCBhcyBiYWNrZW5kIHJldHVybmVkIDQwNFwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELkJBRF9SRVFVRVNUXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCfmqsgQmFkIFJlcXVlc3QuIFRoZSByZXF1ZXN0IHdhcyBtYWxmb3JtZWQgb3IgaW5jb3JyZWN0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJDaGVjayB5b3VyIHBhcmFtZXRlcnMgYW5kIHJlcXVlc3QgZm9ybWF0LCBhcyB0aGUgYmFja2VuZCByZXR1cm5lZCBhIDQwMCBlcnJvci5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTkFVVEhPUklaRURdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+UkSBBY2Nlc3MgRGVuaWVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdSBkbyBub3QgaGF2ZSB0aGUgbmVjZXNzYXJ5IGNyZWRlbnRpYWxzLlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJFbnN1cmUgeW91ciBBUEkga2V5IGlzIGNvcnJlY3QgYW5kIGhhcyB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnMuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5SRVFVRVNUX1RJTUVPVVRdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+VkiBSZXF1ZXN0IFRpbWVvdXRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHJlcXVlc3QgdGltZWQgb3V0IHdoaWxlIHdhaXRpbmcgZm9yIGEgcmVzcG9uc2UuXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuIElmIHRoZSBpc3N1ZSBwZXJzaXN0cywgY29udGFjdCBzdXBwb3J0IG9yIGNoZWNrIHlvdXIgbmV0d29yayBjb25uZWN0aW9uLlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlNFUlZFUl9FUlJPUl06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5KlIE9vcHMhIEludGVybmFsIHNlcnZlciBlcnJvclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIHJlcXVlc3QgY291bGQgbm90IGJlIHByb2Nlc3NlZCBkdWUgdG8gYW4gaW50ZXJuYWwgc2VydmVyIGVycm9yLlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLiBJZiB0aGUgaXNzdWUgcGVyc2lzdHMsIGNvbnRhY3Qgc3VwcG9ydC5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5SQVRFX0xJTUlUXToge1xuICAgICAgICBtZXNzYWdlOiBcIuKPse+4jyBBUEkgUmF0ZSBMaW1pdCBFeGNlZWRlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3UgaGF2ZSBleGNlZWRlZCB0aGUgcmF0ZSBsaW1pdCBmb3IgcmVxdWVzdHMuXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSB3YWl0IGEgYml0IGJlZm9yZSB0cnlpbmcgeW91ciByZXF1ZXN0IGFnYWluLlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQVBJX0tFWV9VTkFWQUlMQUJMRV06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5SRIEFQSSBLZXkgTWlzc2luZyBvciBJbnZhbGlkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBBUEkga2V5IHByb3ZpZGVkIGlzIG1pc3Npbmcgb3IgaW5jb3JyZWN0LlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJFbnN1cmUgdGhhdCB5b3VyIEFQSSBrZXkgaXMgcGFzc2VkIHRvIGNsaWVudCBvciBzZXQgaW4gQ09NUE9TSU9fQVBJX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZS5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfVU5BVkFJTEFCTEVdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+aqyBTZXJ2ZXIgVW5hdmFpbGFibGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHNlcnZlciBpcyBjdXJyZW50bHkgdW5hYmxlIHRvIGhhbmRsZSB0aGUgcmVxdWVzdC5cIixcbiAgICAgICAgcG9zc2libGVGaXg6IFwiUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4gSWYgdGhlIGlzc3VlIHBlcnNpc3RzLCBjb250YWN0IHN1cHBvcnQuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5CQVNFX1VSTF9OT1RfUkVBQ0hBQkxFXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCflJcgQmFzZSBVUkwgaXMgbm90IHZhbGlkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBiYXNlIFVSTCBwcm92aWRlZCBpcyBub3QgdmFsaWQuXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIkVuc3VyZSB0aGF0IHRoZSBiYXNlIFVSTCBpcyBjb3JyZWN0IGFuZCBhY2Nlc3NpYmxlLlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VEXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCflZIgSW52YWxpZCBwYXJhbWV0ZXJzIHBhc3NlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgcGFyYW1ldGVycyBwYXNzZWQgYXJlIGludmFsaWRcIixcbiAgICAgICAgcG9zc2libGVGaXg6IFwiUGxlYXNlIGNoZWNrIHRoZSBlcnJvciBtZXNzYWdlIGZvciBtb3JlIGRldGFpbHNcIixcbiAgICB9LFxuICAgIFVOS05PV046IHtcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIkNvbnRhY3Qgb3VyIHN1cHBvcnQgdGVhbSB3aXRoIHRoZSBlcnJvciBkZXRhaWxzIGZvciBmdXJ0aGVyIGFzc2lzdGFuY2UuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuVU5LTk9XTl06IHtcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIkNvbnRhY3Qgb3VyIHN1cHBvcnQgdGVhbSB3aXRoIHRoZSBlcnJvciBkZXRhaWxzIGZvciBmdXJ0aGVyIGFzc2lzdGFuY2UuXCIsXG4gICAgfSxcbn07XG5jb25zdCBBUElfVE9fU0RLX0VSUk9SX0NPREUgPSB7XG4gICAgNDAwOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5CQURfUkVRVUVTVCxcbiAgICA0MDE6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOQVVUSE9SSVpFRCxcbiAgICA0MDQ6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELk5PVF9GT1VORCxcbiAgICA0MDg6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uUkVRVUVTVF9USU1FT1VULFxuICAgIDQyOTogQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuUkFURV9MSU1JVCxcbiAgICA1MDA6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlNFUlZFUl9FUlJPUixcbiAgICA1MDI6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlNFUlZFUl9VTkFWQUlMQUJMRSxcbn07XG5cbmNvbnN0IGdldEFQSUVycm9yRGV0YWlscyA9IChheGlvc0Vycm9yKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3E7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IChfYSA9IGF4aW9zRXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXM7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gc3RhdHVzQ29kZVxuICAgICAgICA/IEFQSV9UT19TREtfRVJST1JfQ09ERVtzdGF0dXNDb2RlXVxuICAgICAgICA6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOS05PV047XG4gICAgY29uc3QgcHJlZGVmaW5lZEVycm9yID0gQkFTRV9FUlJPUl9DT0RFX0lORk9bZXJyb3JDb2RlXTtcbiAgICBjb25zdCBkZWZhdWx0RXJyb3JEZXRhaWxzID0ge1xuICAgICAgICBtZXNzYWdlOiBheGlvc0Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAoKF9jID0gKF9iID0gYXhpb3NFcnJvciA9PT0gbnVsbCB8fCBheGlvc0Vycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1lc3NhZ2UpIHx8IGF4aW9zRXJyb3IubWVzc2FnZSxcbiAgICAgICAgcG9zc2libGVGaXg6IFwiUGxlYXNlIGNoZWNrIHRoZSBwYXJhbWV0ZXJzIHlvdSBhcmUgcGFzc2luZyB0byB0aGUgQVBJXCIsXG4gICAgfTtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGdlbmVyYXRlTWV0YWRhdGFGcm9tQXhpb3NFcnJvcihheGlvc0Vycm9yKTtcbiAgICBjb25zdCBlcnJvck5hbWVGcm9tQkUgPSAoX2UgPSAoX2QgPSBheGlvc0Vycm9yID09PSBudWxsIHx8IGF4aW9zRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aW9zRXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kYXRhKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubmFtZTtcbiAgICBjb25zdCBlcnJvclR5cGVGcm9tQkUgPSAoX2cgPSAoX2YgPSBheGlvc0Vycm9yID09PSBudWxsIHx8IGF4aW9zRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aW9zRXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kYXRhKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cudHlwZTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoX2ogPSAoX2ggPSBheGlvc0Vycm9yID09PSBudWxsIHx8IGF4aW9zRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4aW9zRXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5kYXRhKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oubWVzc2FnZTtcbiAgICBsZXQgZ2VuZXJpY01lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IGhhc05vdFJlY2VpdmVkUmVzcG9uc2VGcm9tQkUgPSBlcnJvckNvZGUgPT09IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOQVVUSE9SSVpFRCB8fFxuICAgICAgICBlcnJvckNvZGUgPT09IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlJBVEVfTElNSVQgfHxcbiAgICAgICAgZXJyb3JDb2RlID09PSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfVU5BVkFJTEFCTEUgfHxcbiAgICAgICAgZXJyb3JDb2RlID09PSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfVU5SRUFDSEFCTEU7XG4gICAgaWYgKGhhc05vdFJlY2VpdmVkUmVzcG9uc2VGcm9tQkUpIHtcbiAgICAgICAgZ2VuZXJpY01lc3NhZ2UgPSBwcmVkZWZpbmVkRXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKChfayA9IGF4aW9zRXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suYmFzZVVSTCkgJiYgKChfbCA9IGF4aW9zRXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wudXJsKSkge1xuICAgICAgICBnZW5lcmljTWVzc2FnZSA9IGAke2Vycm9yTmFtZUZyb21CRSB8fCBwcmVkZWZpbmVkRXJyb3IubWVzc2FnZX0gJHtlcnJvclR5cGVGcm9tQkUgPyBgLSAke2Vycm9yVHlwZUZyb21CRX1gIDogXCJcIn0gb24gJHsoKF9tID0gYXhpb3NFcnJvci5jb25maWcpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS5iYXNlVVJMKSArICgoX28gPSBheGlvc0Vycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX28gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vLnVybCl9YDtcbiAgICB9XG4gICAgc3dpdGNoIChlcnJvckNvZGUpIHtcbiAgICAgICAgY2FzZSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5CQURfUkVRVUVTVDpcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSAoX3EgPSAoX3AgPSBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AuZGF0YSkgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLmRldGFpbHM7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRFcnJvcnMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25FcnJvcnMpXG4gICAgICAgICAgICAgICAgPyB2YWxpZGF0aW9uRXJyb3JzLm1hcCgoZXJyKSA9PiBKU09OLnN0cmluZ2lmeShlcnIpKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb25FcnJvcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBnZW5lcmljTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFZhbGlkYXRpb24gRXJyb3JzOiAke2Zvcm1hdHRlZEVycm9yc31gLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSBjaGVjayB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGFuZCBlbnN1cmUgdGhleSBhcmUgY29ycmVjdC5cIixcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuTk9UX0ZPVU5EOlxuICAgICAgICBjYXNlIENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOQVVUSE9SSVpFRDpcbiAgICAgICAgY2FzZSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfRVJST1I6XG4gICAgICAgIGNhc2UgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX1VOQVZBSUxBQkxFOlxuICAgICAgICBjYXNlIENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlJBVEVfTElNSVQ6XG4gICAgICAgIGNhc2UgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2VuZXJpY01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGVycm9yTWVzc2FnZSB8fCBwcmVkZWZpbmVkRXJyb3IuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcG9zc2libGVGaXg6IHByZWRlZmluZWRFcnJvci5wb3NzaWJsZUZpeCB8fFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JEZXRhaWxzLnBvc3NpYmxlRml4LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZW5lcmljTWVzc2FnZSB8fCBheGlvc0Vycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGVycm9yTWVzc2FnZSB8fCBwcmVkZWZpbmVkRXJyb3IuZGVzY3JpcHRpb247XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZUZpeCA9IHByZWRlZmluZWRFcnJvci5wb3NzaWJsZUZpeCB8fFxuICAgICAgICAgICAgICAgIGRlZmF1bHRFcnJvckRldGFpbHMucG9zc2libGVGaXggfHxcbiAgICAgICAgICAgICAgICBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4LFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgZ2VuZXJhdGVNZXRhZGF0YUZyb21BeGlvc0Vycm9yID0gKGF4aW9zRXJyb3IpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgY29uc3QgeyByZXF1ZXN0SWQsIC4uLnJlc3RNZXRhZGF0YSB9ID0gYXhpb3NFcnJvci5tZXRhZGF0YSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdWxsVXJsOiAoKF9iID0gKF9hID0gYXhpb3NFcnJvci5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYXNlVVJMKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiKSArICgoX2QgPSAoX2MgPSBheGlvc0Vycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVybCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJcIiksXG4gICAgICAgIG1ldGhvZDogKChfZiA9IChfZSA9IGF4aW9zRXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWV0aG9kKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIlwiKS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICBzdGF0dXNDb2RlOiAoX2cgPSBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuc3RhdHVzLFxuICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZCA/IGAke3JlcXVlc3RJZH1gIDogdW5kZWZpbmVkLFxuICAgICAgICBtZXRhZGF0YTogcmVzdE1ldGFkYXRhLFxuICAgIH07XG59O1xuXG5jbGFzcyBDRUcge1xuICAgIHN0YXRpYyBoYW5kbGVBbGxFcnJvcihlcnJvciwgc2hvdWxkVGhyb3cgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb21wb3Npb0Vycm9yKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQYXNzZWQgZXJyb3IgaXMgbm90IGFuIGluc3RhbmNlIG9mIEVycm9yXCIpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygei5ab2RFcnJvcikge1xuICAgICAgICAgICAgY29uc3Qgem9kRXJyb3IgPSB0aGlzLnJldHVyblpvZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IHpvZEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHpvZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQXhpb3NFcnJvciA9IGVycm9yLmlzQXhpb3NFcnJvcjtcbiAgICAgICAgaWYgKCFpc0F4aW9zRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbUVycm9yID0gdGhpcy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLlVOS05PV04sIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSBjaGVjayBlcnJvciBtZXNzYWdlIGFuZCBzdGFjayB0cmFjZVwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY3VzdG9tRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc1Jlc3BvbnNlTm90UHJlc2VudCA9ICEoXCJyZXNwb25zZVwiIGluIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc1Jlc3BvbnNlTm90UHJlc2VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vblJlc3BvbnNlRXJyb3IgPSB0aGlzLmhhbmRsZU5vblJlc3BvbnNlQXhpb3NFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5vblJlc3BvbnNlRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub25SZXNwb25zZUVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXBpRXJyb3IgPSB0aGlzLnRocm93QVBJRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXBpRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXBpRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGhhbmRsZU5vblJlc3BvbnNlQXhpb3NFcnJvcihlcnJvcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBmdWxsVXJsID0gKCgoX2EgPSBlcnJvci5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iYXNlVVJMKSB8fCBcIlwiKSArICgoKF9iID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXJsKSB8fCBcIlwiKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBnZW5lcmF0ZU1ldGFkYXRhRnJvbUF4aW9zRXJyb3IoZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBvc2lvRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5CQVNFX1VSTF9OT1RfUkVBQ0hBQkxFLCBgRUNPTk5SRUZVU0VEIGZvciAke2Z1bGxVcmx9YCwgXCJcIiwgXCJNYWtlIHN1cmU6XFxuMS4gVGhlIGJhc2UgVVJMIGlzIGNvcnJlY3QgYW5kIGlzIGFjY2Vzc2libGVcXG4yLiBZb3VyIG5ldHdvcmsgY29ubmVjdGlvbiBpcyBzdGFibGVcXG4zLiBUaGVyZSBhcmUgbm8gZmlyZXdhbGwgcnVsZXMgYmxvY2tpbmcgdGhlIGNvbm5lY3Rpb25cIiwgbWV0YWRhdGEsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFVElNRURPVVRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBvc2lvRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5SRVFVRVNUX1RJTUVPVVQsIGBFQ09OTkFCT1JURUQgZm9yICR7ZnVsbFVybH1gLCBgUmVxdWVzdCB0byAke2Z1bGxVcmx9IHRpbWVkIG91dCBhZnRlciB0aGUgY29uZmlndXJlZCB0aW1lb3V0IHBlcmlvZC4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gc2xvdyBuZXR3b3JrIGNvbmRpdGlvbnMsIHNlcnZlciBwZXJmb3JtYW5jZSBpc3N1ZXMsIG9yIHRoZSByZXF1ZXN0IGJlaW5nIHRvbyBsYXJnZS4gRXJyb3IgY29kZTogRVRJTUVET1VUYCwgXCJUcnk6XFxuMS4gQ2hlY2tpbmcgeW91ciBuZXR3b3JrIHNwZWVkIGFuZCBzdGFiaWxpdHlcXG4yLiBJbmNyZWFzaW5nIHRoZSByZXF1ZXN0IHRpbWVvdXQgc2V0dGluZyBpZiBuZWVkZWRcXG4zLiBCcmVha2luZyB1cCBsYXJnZSByZXF1ZXN0cyBpbnRvIHNtYWxsZXIgY2h1bmtzXFxuNC4gUmV0cnlpbmcgdGhlIHJlcXVlc3Qgd2hlbiBuZXR3b3JrIGNvbmRpdGlvbnMgaW1wcm92ZVxcbjUuIENvbnRhY3QgdGVjaEBjb21wb3Npby5kZXYgaWYgdGhlIGlzc3VlIHBlcnNpc3RzXCIsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21wb3Npb0Vycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uUkVRVUVTVF9BQk9SVEVELCBlcnJvci5tZXNzYWdlLCBcIlRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkIGR1ZSB0byBhIHRpbWVvdXQgb3Igb3RoZXIgbmV0d29yay1yZWxhdGVkIGlzc3Vlcy4gVGhpcyBjb3VsZCBiZSBkdWUgdG8gbmV0d29yayBpbnN0YWJpbGl0eSwgc2VydmVyIGlzc3Vlcywgb3IgdGhlIHJlcXVlc3QgYmVpbmcgdG9vIGxhcmdlLiBFcnJvciBjb2RlOiBFQ09OTkFCT1JURURcIiwgXCJUcnk6XFxuMS4gQ2hlY2tpbmcgeW91ciBuZXR3b3JrIHNwZWVkIGFuZCBzdGFiaWxpdHlcXG4yLiBJbmNyZWFzaW5nIHRoZSByZXF1ZXN0IHRpbWVvdXQgc2V0dGluZyBpZiBuZWVkZWRcXG4zLiBCcmVha2luZyB1cCBsYXJnZSByZXF1ZXN0cyBpbnRvIHNtYWxsZXIgY2h1bmtzXFxuNC4gUmV0cnlpbmcgdGhlIHJlcXVlc3Qgd2hlbiBuZXR3b3JrIGNvbmRpdGlvbnMgaW1wcm92ZVxcbjUuIENvbnRhY3QgdGVjaEBjb21wb3Npby5kZXYgaWYgdGhlIGlzc3VlIHBlcnNpc3RzXCIsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENvbXBvc2lvRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX1VOUkVBQ0hBQkxFLCBlcnJvci5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIlNlcnZlciBpcyB1bnJlYWNoYWJsZS4gUGxlYXNlIGNvbnRhY3QgdGVjaEBjb21wb3Npby5kZXYgd2l0aCB0aGUgZXJyb3IgZGV0YWlscy5cIiwgXCJTZXJ2ZXIgaXMgdW5yZWFjaGFibGUuIFBsZWFzZSBjb250YWN0IHRlY2hAY29tcG9zaW8uZGV2IHdpdGggdGhlIGVycm9yIGRldGFpbHMuXCIsIFwiUGxlYXNlIGNvbnRhY3QgdGVjaEBjb21wb3Npby5kZXYgd2l0aCB0aGUgZXJyb3IgZGV0YWlscy5cIiwgbWV0YWRhdGEsIGVycm9yKTtcbiAgICB9XG4gICAgc3RhdGljIHRocm93QVBJRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gKChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gc3RhdHVzQ29kZVxuICAgICAgICAgICAgPyBBUElfVE9fU0RLX0VSUk9SX0NPREVbc3RhdHVzQ29kZV0gfHxcbiAgICAgICAgICAgICAgICBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTktOT1dOXG4gICAgICAgICAgICA6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOS05PV047XG4gICAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGdldEFQSUVycm9yRGV0YWlscyhlcnJvcik7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2VuZXJhdGVNZXRhZGF0YUZyb21BeGlvc0Vycm9yKGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IENvbXBvc2lvRXJyb3IoZXJyb3JDb2RlLCBlcnJvckRldGFpbHMubWVzc2FnZSwgZXJyb3JEZXRhaWxzLmRlc2NyaXB0aW9uLCBlcnJvckRldGFpbHMucG9zc2libGVGaXgsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgfVxuICAgIHN0YXRpYyByZXR1cm5ab2RFcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRDtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgY29uc3QgZXJyb3JEZXNjcmlwdGlvbiA9IFwiVGhlIHBhcmFtZXRlcnMgcGFzc2VkIGFyZSBpbnZhbGlkXCI7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRml4ID0gXCJQbGVhc2UgY2hlY2sgZXJyb3IgbWVzc2FnZSBmb3IgbW9yZSBkZXRhaWxzXCI7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgaXNzdWVzOiBlcnJvci5pc3N1ZXMsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zaW9FcnJvcihlcnJvckNvZGUsIGVycm9yTWVzc2FnZSwgZXJyb3JEZXNjcmlwdGlvbiwgcG9zc2libGVGaXgsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDdXN0b21FcnJvcihtZXNzYWdlQ29kZSwgeyBtZXNzYWdlLCB0eXBlLCBzdWJ0eXBlLCBkZXNjcmlwdGlvbiwgcG9zc2libGVGaXgsIG9yaWdpbmFsRXJyb3IsIG1ldGFkYXRhLCB9KSB7XG4gICAgICAgIGNvbnN0IGZpbmFsRXJyb3JDb2RlID0gISFtZXNzYWdlQ29kZSA/IG1lc3NhZ2VDb2RlIDogYCR7dHlwZX06OiR7c3VidHlwZX1gO1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBCQVNFX0VSUk9SX0NPREVfSU5GT1tmaW5hbEVycm9yQ29kZV0gfHwgQkFTRV9FUlJPUl9DT0RFX0lORk8uVU5LTk9XTjtcbiAgICAgICAgY29uc3QgZmluYWxNZXNzYWdlID0gbWVzc2FnZSB8fCBlcnJvckRldGFpbHMubWVzc2FnZSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBmaW5hbERlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gfHwgZXJyb3JEZXRhaWxzLmRlc2NyaXB0aW9uIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZmluYWxQb3NzaWJsZUZpeCA9IHBvc3NpYmxlRml4IHx8IGVycm9yRGV0YWlscy5wb3NzaWJsZUZpeCB8fCBcIlwiO1xuICAgICAgICB0aHJvdyBuZXcgQ29tcG9zaW9FcnJvcihtZXNzYWdlQ29kZSwgZmluYWxNZXNzYWdlLCBmaW5hbERlc2NyaXB0aW9uLCBmaW5hbFBvc3NpYmxlRml4LCBtZXRhZGF0YSwgb3JpZ2luYWxFcnJvcik7XG4gICAgfVxufVxuXG5jbGFzcyBCYXRjaFByb2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IodGltZSA9IDIwMDAsIGJhdGNoU2l6ZSA9IDEwMCwgcHJvY2Vzc0JhdGNoQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5iYXRjaCA9IFtdO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXRjaCA9IFtdO1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IGJhdGNoU2l6ZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQmF0Y2hDYWxsYmFjayA9IHByb2Nlc3NCYXRjaENhbGxiYWNrO1xuICAgIH1cbiAgICBwdXNoSXRlbShpdGVtKSB7XG4gICAgICAgIHRoaXMuYmF0Y2gucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2gubGVuZ3RoID49IHRoaXMuYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NCYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnByb2Nlc3NCYXRjaCgpLCB0aGlzLnRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NCYXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQmF0Y2hDYWxsYmFjayh0aGlzLmJhdGNoKTtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2ggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBfYTtcbmNsYXNzIFRFTEVNRVRSWV9MT0dHRVIge1xuICAgIHN0YXRpYyBjcmVhdGVUZWxlbWV0cnlXcmFwcGVyKG1ldGhvZCwgY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBldmVudE5hbWU6IG1ldGhvZC5uYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgY2xhc3NOYW1lLCBhcmdzIH0sXG4gICAgICAgICAgICAgICAgc2RrX21ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpS2V5OiBDb21wb3Npb1NES0NvbnRleHQuYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICBiYXNlVVJMOiBDb21wb3Npb1NES0NvbnRleHQuYmFzZVVSTCxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaW9WZXJzaW9uOiBDb21wb3Npb1NES0NvbnRleHQuY29tcG9zaW9WZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBmcmFtZXdvcmtSdW50aW1lOiBDb21wb3Npb1NES0NvbnRleHQuZnJhbWV3b3JrUnVudGltZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBDb21wb3Npb1NES0NvbnRleHQuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IENvbXBvc2lvU0RLQ29udGV4dC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIGlzQnJvd3NlcjogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9hLmJhdGNoUHJvY2Vzc29yLnB1c2hJdGVtKHBheWxvYWQpO1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIHNlbmRUZWxlbWV0cnkocGF5bG9hZCkge1xuICAgICAgICBjb25zdCBpc1RlbGVtZXRyeURpc2FibGVkID0gZ2V0RW52VmFyaWFibGUoXCJURUxFTUVUUllfRElTQUJMRURcIiwgXCJmYWxzZVwiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGlmIChpc1RlbGVtZXRyeURpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gYCR7VEVMRU1FVFJZX1VSTH0vYXBpL3Nka19tZXRyaWNzL3RlbGVtZXRyeWA7XG4gICAgICAgIGNvbnN0IHJlcVBheWxvYWQgPSB7XG4gICAgICAgICAgICBkYXRhOiBwYXlsb2FkLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgYXdhaXQgc2VuZEJyb3dzZXJSZXEocmVxUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBzZW5kUHJvY2Vzc1JlcShyZXFQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgbWFudWFsVGVsZW1ldHJ5KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHNka19tZXRhOiB7XG4gICAgICAgICAgICAgICAgYXBpS2V5OiBDb21wb3Npb1NES0NvbnRleHQuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGJhc2VVUkw6IENvbXBvc2lvU0RLQ29udGV4dC5iYXNlVVJMLFxuICAgICAgICAgICAgICAgIGNvbXBvc2lvVmVyc2lvbjogQ29tcG9zaW9TREtDb250ZXh0LmNvbXBvc2lvVmVyc2lvbixcbiAgICAgICAgICAgICAgICBmcmFtZXdvcmtSdW50aW1lOiBDb21wb3Npb1NES0NvbnRleHQuZnJhbWV3b3JrUnVudGltZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IENvbXBvc2lvU0RLQ29udGV4dC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgaXNCcm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgX2EuYmF0Y2hQcm9jZXNzb3IucHVzaEl0ZW0ocGF5bG9hZCk7XG4gICAgfVxuICAgIHN0YXRpYyB3cmFwRnVuY3Rpb25Gb3JUZWxlbWV0cnkoZnVuYywgY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBfYS5jcmVhdGVUZWxlbWV0cnlXcmFwcGVyKGZ1bmMsIGNsYXNzTmFtZSk7XG4gICAgfVxufVxuX2EgPSBURUxFTUVUUllfTE9HR0VSO1xuVEVMRU1FVFJZX0xPR0dFUi5iYXRjaFByb2Nlc3NvciA9IG5ldyBCYXRjaFByb2Nlc3NvcigxMDAsIDEwLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgIGF3YWl0IF9hLnNlbmRUZWxlbWV0cnkoZGF0YSk7XG59KTtcblxudmFyIFRFTEVNRVRSWV9FVkVOVFM7XG4oZnVuY3Rpb24gKFRFTEVNRVRSWV9FVkVOVFMpIHtcbiAgICBURUxFTUVUUllfRVZFTlRTW1wiU0RLX0lOSVRJQUxJWkVEXCJdID0gXCJTREtfSU5JVElBTElaRURcIjtcbiAgICBURUxFTUVUUllfRVZFTlRTW1wiU0RLX01FVEhPRF9JTlZPS0VEXCJdID0gXCJTREtfTUVUSE9EX0lOVk9LRURcIjtcbiAgICBURUxFTUVUUllfRVZFTlRTW1wiQ0xJX0lOVk9LRURcIl0gPSBcIkNMSV9JTlZPS0VEXCI7XG59KShURUxFTUVUUllfRVZFTlRTIHx8IChURUxFTUVUUllfRVZFTlRTID0ge30pKTtcblxuLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmNvbnN0IGNsaWVudCA9IGNsaWVudEF4aW9zLmNyZWF0ZUNsaWVudChjbGllbnRBeGlvcy5jcmVhdGVDb25maWcoKSk7XG5jbGFzcyBDbGllbnRTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBpbmZvXG4gICAgICogR2V0IGNsaWVudCBpbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFVzZXJJbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGllbnQvYXV0aC9jbGllbnRfaW5mb1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG5ldyBwcm9qZWN0XG4gICAgICogQWRkIGEgbmV3IHByb2plY3QgdG8gdGhlIGNsaWVudCdzIG9yZ2FuaXphdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9qZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpZW50L2F1dGgvcHJvamVjdC9hZGRcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBwcm9qZWN0XG4gICAgICogRGVsZXRlIGEgcHJvamVjdCBmcm9tIHRoZSBjbGllbnQncyBvcmdhbml6YXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlUHJvamVjdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpZW50L2F1dGgvcHJvamVjdC9kZWxldGUve3Byb2plY3RJZH1cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwcm9qZWN0c1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcm9qZWN0cyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpZW50L2F1dGgvcHJvamVjdHNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBvcmcgYXBpIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRPcmdBcGlLZXkob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2NsaWVudC9hdXRoL29yZy9hcGlfa2V5XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlIG9yZyBhcGkga2V5XG4gICAgICovXG4gICAgc3RhdGljIHJlZ2VuZXJhdGVPcmdBcGlLZXkob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGllbnQvYXV0aC9vcmcvYXBpX2tleS9yZWdlbmVyYXRlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFwaUtleXNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhcGkga2V5XG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlQXBpS2V5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvYXBpX2tleXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXBpIGtleXNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdEFwaUtleXMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FwaV9rZXlzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYXBpIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVBcGlLZXkob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FwaV9rZXlzL3tpZH1cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQXBwc1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIExpc3QgYXBwIGNhdGVnb3JpZXNcbiAgICAgKiBMaXN0IG9mIGF2YWlsYWJsZSBhcHAgY2F0ZWdvcmllcywgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGFwcHMuXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBcHBDYXRlZ29yaWVzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hcHBzL2xpc3QvY2F0ZWdvcmllc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhcHAgZW51bXNcbiAgICAgKiBMaXN0IGFwcCBlbnVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QXBwRW51bXMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FwcHMvbGlzdC9lbnVtc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhcHBzXG4gICAgICogTGlzdCBhbGwgYXBwcyBiYXNlZCBvbiB0aGUgZ2l2ZW4gZmlsdGVycywgaWYgYW55LiBUaGlzIHdpbGwgcmV0dXJuIGFsbCBhdmFpbGFibGUgYXBwcyBpZiBubyBmaWx0ZXJzIGFyZSBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QXBwcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvYXBwc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNpbmdsZSBhcHBcbiAgICAgKiBHZXQgYXBwIGRldGFpbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QXBwKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hcHBzL3thcHBOYW1lfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBJbnRlZ3JhdGlvbnNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgY29ubmVjdG9yXG4gICAgICogQ3JlYXRlIGEgbmV3IGNvbm5lY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb25uZWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9pbnRlZ3JhdGlvbnNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIGNvbm5lY3RvcnNcbiAgICAgKiBMaXN0IGFsbCBjb25uZWN0b3JzXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBbGxDb25uZWN0b3JzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9pbnRlZ3JhdGlvbnNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjb25uZWN0b3IgaW5mb1xuICAgICAqIEdldCBjb25uZWN0b3IgaW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb25uZWN0b3JJbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9pbnRlZ3JhdGlvbnMve2ludGVncmF0aW9uSWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgY29ubmVjdG9yXG4gICAgICogTW9kaWZ5IGEgY29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIG1vZGlmeUNvbm5lY3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBhdGNoKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9pbnRlZ3JhdGlvbnMve2ludGVncmF0aW9uSWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgY29ubmVjdG9yXG4gICAgICogRGVsZXRlIGEgY29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZUNvbm5lY3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvaW50ZWdyYXRpb25zL3tpbnRlZ3JhdGlvbklkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBBY3Rpb25zU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhY3Rpb24gZW51bXNcbiAgICAgKiBMaXN0IGFjdGlvbiBlbnVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QWN0aW9uRW51bXMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FjdGlvbnMvbGlzdC9lbnVtc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhY3Rpb24gdGFnc1xuICAgICAqIExpc3QgYWxsIHRoZSBhY3Rpb24gdGFncyBhdmFpbGFibGUgaW4gY29tcG9zaW9cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdEFjdGlvblRhZ3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMvbGlzdC90YWdzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFjdGlvbiBlbnVtc1xuICAgICAqIExpc3QgYWN0aW9uIGVudW1zXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBY3Rpb25FbnVtczEob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMvbGlzdC9lbnVtc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhY3Rpb25zIHdpdGggY29tcGxldGUgZGV0YWlsc1xuICAgICAqIExpc3QgYW5kIGZpbHRlciBhbGwgdGhlIGFjdGlvbnMgYXZhaWxhYmxlIGluIGNvbXBvc2lvLCB3aXRoIGFsbCB0aGUgZGV0YWlscyBuZWVkZWQgZm9yIG1hbnVhbCBhY3Rpb24gZXhlY3V0aW9uIG9yIHRocm91Z2ggZnVuY3Rpb24tY2FsbGluZy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdEFjdGlvbnNWMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9uc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhY3Rpb25zXG4gICAgICogUmV0cmlldmUgYSBsaXN0IG9mIGFsbCBhY3Rpb25zIGJhc2VkIG9uIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBY3Rpb25zTWluaW1hbFYyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL2xpc3QvYWxsXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFuIGFjdGlvblxuICAgICAqIEV4ZWN1dGUgYW4gYWN0aW9uLiBTdXBwb3J0IGJvdGggY29ubmVjdGVkIGFjY291bnQgYW5kIG5vIGF1dGggYXV0aC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhlY3V0ZUFjdGlvblYyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy97YWN0aW9uSWR9L2V4ZWN1dGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY3Rpb24gaW5wdXRzXG4gICAgICogR2V0IHRoZSBpbnB1dHMgZm9yIGFuIGFjdGlvbiB3aXRoIE5MQVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBY3Rpb25JbnB1dHNWMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMve2FjdGlvbklkfS9leGVjdXRlL2dldC5pbnB1dHNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaW5nbGUgYWN0aW9uXG4gICAgICogR2V0IGFjdGlvbiBkZXRhaWxzLCBpbmNsdWRpbmcgdGhlIGlucHV0IGFuZCByZXNwb25zZSBzY2hlbWEuIFRoaXMgaXMgdmVyeSB1c2VmdWwgZm9yIHNldHRpbmcgdXBmdW5jdGlvbi90b29sIGNhbGxpbmcgd2l0aCBjb21wb3NpbyBhY3Rpb25zLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBY3Rpb25WMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy97YWN0aW9uSWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHdpdGggSFRUUCBDbGllbnRcbiAgICAgKiBVc2UgY29tcG9zaW8gYXMgYSBodHRwIGNsaWVudCB0byBtYWtlIHJlcXVlc3QgdG8gdGhlIGNvbm5lY3RlZCBhY2NvdW50IHNlcnZpY2Ugb24geW91ciBiZWhhbGYsIHdpdGhvdXQgbWFuYWdpbmcgYXV0aGVudGljYXRpb24gb24geW91ciBzaWRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBleGVjdXRlV2l0aEh0dHBDbGllbnQob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL3Byb3h5XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlZCB1c2UgY2FzZSBzZWFyY2hcbiAgICAgKiBQZXJmb3JtIHVzZSBjYXNlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWR2YW5jZWRVc2VDYXNlU2VhcmNoKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL3NlYXJjaC9hZHZhbmNlZFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB1c2VyIGZpbGVzXG4gICAgICovXG4gICAgc3RhdGljIHYyTGlzdFVzZXJGaWxlcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy9maWxlcy9saXN0XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgZmlsZSB1cGxvYWQgdXJsXG4gICAgICogQ3JlYXRlIGZpbGUgdXBsb2FkIFVSTCBmb3IgYWN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmlsZVVwbG9hZFVybChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMvZmlsZXMvdXBsb2FkL3tmaWxlVHlwZX1cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ29ubmVjdGlvbnNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGNvbm5lY3Rpb25zXG4gICAgICogR2V0IGFsbCBjb25uZWN0aW9ucyBpbiB0aGUgY3VycmVudCBwcm9qZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0Q29ubmVjdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGluaXRpYXRlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29ubmVjdGlvbiBkYXRhXG4gICAgICogVXBkYXRlIGNvbm5lY3Rpb24gZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVDb25uZWN0aW9uRGF0YShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBhdGNoKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfS9kYXRhXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWluaXRpYXRlIGNvbm5lY3Rpb25cbiAgICAgKiBSZWluaXRpYXRlIGFuIGV4aXN0aW5nIGNvbm5lY3Rpb24gdG8gZ2V0IG5ldyBjcmVkZW50aWFsc1xuICAgICAqL1xuICAgIHN0YXRpYyByZWluaXRpYXRlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzL3tjb25uZWN0ZWRBY2NvdW50SWR9L3JlaW5pdGlhdGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaW5nbGUgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGNvbm5lY3Rpb25cbiAgICAgKiBEZWxldGUgYSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzL3tjb25uZWN0ZWRBY2NvdW50SWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgQXV0aCBjcmVkZW50aWFsc1xuICAgICAqIEdldCBhdXRoZW50aWNhdGlvbiBjcmRlbnRpYWxzIGZvciB0aGUgY29ubmVjdGVkIGFjY291bnQsIGkuZSBhbGwgdGhlIGhlYWRlcnMsIHF1ZXJ5IHBhcmFtZXRlcnMsIGV0Yy4gdGhhdCBhcmUgcmVxdWlyZWQgdG8gbWFrZSByZXF1ZXN0cyB0byB0aGUgdGhpcmQtcGFydHkgc2VydmljZSBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29ubmVjdGlvbkluZm8ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzL3tjb25uZWN0ZWRBY2NvdW50SWR9L2luZm9cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgY29ubmVjdGlvblxuICAgICAqIERpc2FibGUgYSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGRpc2FibGVDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY29ubmVjdGVkQWNjb3VudHMve2Nvbm5lY3RlZEFjY291bnRJZH0vZGlzYWJsZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGNvbm5lY3Rpb25cbiAgICAgKiBFbmFibGUgYSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGVuYWJsZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfS9lbmFibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVHJpZ2dlcnNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IHRyaWdnZXJzXG4gICAgICogTGlzdCB0cmlnZ2Vyc1xuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0VHJpZ2dlcnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRyaWdnZXIgZW51bXNcbiAgICAgKiBMaXN0IHRyaWdnZXIgZW51bXNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdFRyaWdnZXJFbnVtcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvbGlzdC9lbnVtc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG5ldyB3ZWJob29rXG4gICAgICogVXBkYXRlIGlzTmV3V2ViaG9va1xuICAgICAqL1xuICAgIHN0YXRpYyB1cGRhdGVOZXdXZWJob29rKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvdXBkYXRlX3dlYmhvb2tfZm9ybWF0XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdHJpZ2dlclxuICAgICAqIEVuYWJsZXMgYSB0cmlnZ2VyIGZvciBhIGNvbm5lY3RlZCBhY2NvdW50IGFuZCBzcGVjaWZpYyB0cmlnZ2VyIG5hbWUuXG4gICAgICovXG4gICAgc3RhdGljIGVuYWJsZVRyaWdnZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS90cmlnZ2Vycy9lbmFibGUve2Nvbm5lY3RlZEFjY291bnRJZH0ve3RyaWdnZXJOYW1lfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjdGl2ZSB0cmlnZ2Vyc1xuICAgICAqIExpc3RzIGFjdGl2ZSB0cmlnZ2VycyBiYXNlZCBvbiBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBY3RpdmVUcmlnZ2VycyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvYWN0aXZlX3RyaWdnZXJzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTd2l0Y2ggdHJpZ2dlciBpbnN0YW5jZSBzdGF0dXNcbiAgICAgKiBTd2l0Y2hlcyB0aGUgc3RhdHVzIG9mIGEgdHJpZ2dlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgc3dpdGNoVHJpZ2dlckluc3RhbmNlU3RhdHVzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucGF0Y2goe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL2luc3RhbmNlL3t0cmlnZ2VySWR9L3N0YXR1c1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB0cmlnZ2VyXG4gICAgICogRGlzYWJsZXMgYSBzcGVjaWZpZWQgdHJpZ2dlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGlzYWJsZVRyaWdnZXIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS90cmlnZ2Vycy9kaXNhYmxlL3t0cmlnZ2VySW5zdGFuY2VJZH1cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0cmlnZ2VyXG4gICAgICogRGVsZXRlcyBhIHNwZWNpZmllZCB0cmlnZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVUcmlnZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS90cmlnZ2Vycy9pbnN0YW5jZS97dHJpZ2dlckluc3RhbmNlSWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY2FsbGJhY2sgdXJsXG4gICAgICogU2V0cyBhIHVuaXZlcnNhbCBjYWxsYmFjayBVUkwgZm9yIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgc3RhdGljIHNldENhbGxiYWNrVXJsKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvc2V0X2NhbGxiYWNrX3VybFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHdlYmhvb2sgdXJsXG4gICAgICogUmV0cmlldmVzIHRoZSB1bml2ZXJzYWwgY2FsbGJhY2sgVVJMIHNldCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0V2ViaG9va1VybChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvY2FsbGJhY2tfdXJsXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbG9nc1xuICAgICAqIEZldGNoZXMgbG9ncyBiYXNlZCBvbiBjb25uZWN0aW9uIGFuZCBpbnRlZ3JhdGlvbiBkZXRhaWxzLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRUcmlnZ2VyTG9ncyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvbG9nc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRyaWdnZXIgaW5mb1xuICAgICAqIEdldCBUcmlnZ2VyIEluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VHJpZ2dlckluZm9WMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvdHJpZ2dlcnMve3RyaWdnZXJOYW1lfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBDbGlTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2xpIGNvZGUgZXhjaGFuZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2VuZXJhdGVDbGlTZXNzaW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGkvZ2VuZXJhdGUtY2xpLXNlc3Npb25cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjbGkgY29kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRDbGlDb2RlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGkvZ2V0LWNsaS1jb2RlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2xpIGNvZGUgdmVyaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIHZlcmlmeUNsaUNvZGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2NsaS92ZXJpZnktY2xpLWNvZGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgTG9nc1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEdldCBsb2dzXG4gICAgICogTGlzdCBsb2dzXG4gICAgICovXG4gICAgc3RhdGljIGdldExvZ3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2xvZ3MvXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3N0IGxvZ3NcbiAgICAgKiBBZGQgbmV3IGxvZ3NcbiAgICAgKi9cbiAgICBzdGF0aWMgcG9zdExvZ3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9sb2dzL1wiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBJbnRlZ3JhdGlvbnNWMlNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCBjb25uZWN0b3JcbiAgICAgKiBTZWFyY2ggZm9yIGEgY29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIHNlYXJjaENvbm5lY3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2ludGVncmF0aW9ucy9zZWFyY2gtYnktZmlsdGVyc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbm5lY3RvclxuICAgICAqIENyZWF0ZSBhIG5ldyBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29ubmVjdG9yVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9pbnRlZ3JhdGlvbnMvY3JlYXRlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGNvbm5lY3RvclxuICAgICAqIEdldCBvciBjcmVhdGUgYSBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGVDb25uZWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9pbnRlZ3JhdGlvbnMvZ2V0LW9yLWNyZWF0ZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBDb25uZWN0aW9uc3YyU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0aWF0ZUNvbm5lY3Rpb25WMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2Nvbm5lY3RlZEFjY291bnRzL2luaXRpYXRlQ29ubmVjdGlvblwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbnZhciBhcGlDbGllbnQgPSB7XG4gICAgbG9nczogTG9nc1NlcnZpY2UsXG4gICAgYWN0aW9uc1YxOiBBY3Rpb25zU2VydmljZSxcbiAgICBhY3Rpb25zVjI6IEFjdGlvbnNTZXJ2aWNlLFxuICAgIGFwaUtleXM6IEFwaUtleXNTZXJ2aWNlLFxuICAgIGNsaWVudEF1dGg6IENsaWVudFNlcnZpY2UsXG4gICAgY2xpOiBDbGlTZXJ2aWNlLFxuICAgIGFwcENvbm5lY3RvcjogSW50ZWdyYXRpb25zU2VydmljZSxcbiAgICBhcHBDb25uZWN0b3JWMjogSW50ZWdyYXRpb25zVjJTZXJ2aWNlLFxuICAgIGFwcHM6IEFwcHNTZXJ2aWNlLFxuICAgIGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uc1NlcnZpY2UsXG4gICAgY29ubmVjdGlvbnNWMjogQ29ubmVjdGlvbnN2MlNlcnZpY2UsXG4gICAgdHJpZ2dlcnM6IFRyaWdnZXJzU2VydmljZSxcbn07XG5cbmNvbnN0IFpBY3Rpb25HZXRQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhY3Rpb25OYW1lOiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpHZXRMaXN0QWN0aW9uc1BhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFwcHM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQ29tbWEgc2VwYXJhdGVkIGFwcCBuYW1lc1wiKSxcbiAgICBhY3Rpb25zOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkNvbW1hIHNlcGFyYXRlZCBhY3Rpb24gbmFtZXNcIiksXG4gICAgdGFnczogei56LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJDb21tYSBzZXBhcmF0ZWQgdGFnIG5hbWVzXCIpLFxuICAgIHVzZUNhc2U6IHouei5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJVc2UgY2FzZSBuYW1lXCIpLFxuICAgIHVzZWNhc2VMaW1pdDogei56Lm51bWJlcigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJMaW1pdCBmb3IgdXNlIGNhc2VcIiksXG4gICAgc2hvd0FsbDogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiU2hvdyBhbGwgYWN0aW9uc1wiKSxcbiAgICBzaG93RW5hYmxlZE9ubHk6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlNob3cgZW5hYmxlZCBhY3Rpb25zXCIpLFxuICAgIGZpbHRlckltcG9ydGFudEFjdGlvbnM6IHouelxuICAgICAgICAuYm9vbGVhbigpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIkZpbHRlciBpbXBvcnRhbnQgYWN0aW9uc1wiKSxcbiAgICBmaWx0ZXJCeUF2YWlsYWJsZUFwcHM6IHouelxuICAgICAgICAuYm9vbGVhbigpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIkZpbHRlciBhY3Rpb25zIGJ5IGF2YWlsYWJsZSBhcHBzXCIpLFxufSk7XG5jb25zdCBaUGFyYW1ldGVyID0gei56Lm9iamVjdCh7XG4gICAgbmFtZTogei56LnN0cmluZygpLFxuICAgIGluOiB6LnouZW51bShbXCJxdWVyeVwiLCBcImhlYWRlclwiXSksXG4gICAgdmFsdWU6IHouei5zdHJpbmcoKSxcbn0pO1xuY29uc3QgWkN1c3RvbUF1dGhQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBiYXNlX3VybDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcGFyYW1ldGVyczogei56LmFycmF5KFpQYXJhbWV0ZXIpLFxuICAgIGJvZHk6IHouei5yZWNvcmQoei56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWkV4ZWN1dGVQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhY3Rpb25OYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgcmVxdWVzdEJvZHk6IHouei5vYmplY3Qoe1xuICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBpbnB1dDogei56LnJlY29yZCh6LnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICAgICAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGV4dDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIGF1dGhDb25maWc6IFpDdXN0b21BdXRoUGFyYW1zLm9wdGlvbmFsKCksXG4gICAgICAgIGFsbG93VHJhY2luZzogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBzZXNzaW9uSW5mbzogei56XG4gICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgIHNlc3Npb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB9KSxcbn0pO1xuY29uc3QgWkZpbmRBY3Rpb25FbnVtc0J5VXNlQ2FzZVBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFwcHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLFxuICAgIHVzZUNhc2U6IHouei5zdHJpbmcoKSxcbiAgICBsaW1pdDogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpFeGVjdXRlUmVxdWVzdFBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLFxuICAgIGVuZHBvaW50OiB6Lnouc3RyaW5nKCksXG4gICAgbWV0aG9kOiB6LnouZW51bShbXCJHRVRcIiwgXCJQT1NUXCIsIFwiUFVUXCIsIFwiUEFUQ0hcIiwgXCJERUxFVEVcIl0pLFxuICAgIHBhcmFtZXRlcnM6IHouei5hcnJheShaUGFyYW1ldGVyKSxcbiAgICBib2R5OiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLm9wdGlvbmFsKCksXG59KTtcblxuY2xhc3MgQWN0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoYmFja2VuZENsaWVudCwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL2FjdGlvbnMudHNcIjtcbiAgICAgICAgdGhpcy5iYWNrZW5kQ2xpZW50ID0gYmFja2VuZENsaWVudDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgYWN0aW9uIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybSBieSBwcm92aWRpbmcgaXRzIGFjdGlvbiBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIHJlc3BvbnNlIGluY2x1ZGVzIHRoZSBhY3Rpb24ncyBuYW1lLCBkaXNwbGF5IG5hbWUsIGRlc2NyaXB0aW9uLCBpbnB1dCBwYXJhbWV0ZXJzLCBleHBlY3RlZCByZXNwb25zZSwgYXNzb2NpYXRlZCBhcHAgaW5mb3JtYXRpb24sIGFuZCBlbmFibGVkIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7R2V0QWN0aW9uRGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aW9uSXRlbUdldFJlc1swXT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXRhaWxzIG9mIHRoZSBhY3Rpb24uXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBaQWN0aW9uR2V0UGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IGFwaUNsaWVudC5hY3Rpb25zVjIuZ2V0QWN0aW9uVjIoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZDogcGFyc2VkRGF0YS5hY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25zLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBhY3Rpb25zIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gZmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgYXZhaWxhYmxlIGFjdGlvbnMuIEl0IHN1cHBvcnRzIHBhZ2luYXRpb24gdG8gaGFuZGxlIGxhcmdlIG51bWJlcnMgb2YgYWN0aW9ucy4gVGhlIHJlc3BvbnNlIGluY2x1ZGVzIGFuIGFycmF5IG9mIGFjdGlvbiBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgYWN0aW9uJ3MgbmFtZSwgZGlzcGxheSBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dldExpc3RBY3Rpb25zRGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aW9uc0xpc3RSZXNwb25zZURUTz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFsbCBhY3Rpb25zLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QoZGF0YSA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJsaXN0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWkdldExpc3RBY3Rpb25zUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgbGV0IGFwcHMgPSBwYXJzZWREYXRhLmFwcHM7XG4gICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiB1c2VyIGhhcyBwcm92aWRlZCBib3RoIGZpbHRlckJ5QXZhaWxhYmxlQXBwcyBhbmQgYXBwc1xuICAgICAgICAgICAgaWYgKChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZmlsdGVyQnlBdmFpbGFibGVBcHBzKSAmJiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmFwcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBmaWx0ZXJCeUF2YWlsYWJsZUFwcHMgYW5kIGFwcHMgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5maWx0ZXJCeUF2YWlsYWJsZUFwcHMpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2RvOiBUbyBjcmVhdGUgYSBuZXcgQVBJIHRvIGdldCBhbGwgaW50ZWdyYXRlZCBhcHBzIGZvciBhIHVzZXIgaW5zdGVhZCBvZiBmZXRjaGluZyBhbGwgYXBwc1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVncmF0ZWRBcHBzID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3Rvci5saXN0QWxsQ29ubmVjdG9ycygpO1xuICAgICAgICAgICAgICAgIGFwcHMgPSAoX2EgPSBpbnRlZ3JhdGVkQXBwcy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXRlbXMubWFwKChhcHApID0+IGFwcCA9PT0gbnVsbCB8fCBhcHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcC5hcHBOYW1lKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFjdGlvbnNWMi5saXN0QWN0aW9uc1YyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGRhdGEuYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYXBwczogYXBwcyxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0FsbDogZGF0YS5zaG93QWxsLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiBkYXRhLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckltcG9ydGFudEFjdGlvbnM6IGRhdGEuZmlsdGVySW1wb3J0YW50QWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0VuYWJsZWRPbmx5OiBkYXRhLnNob3dFbmFibGVkT25seSxcbiAgICAgICAgICAgICAgICAgICAgdXNlY2FzZUxpbWl0OiBkYXRhLnVzZWNhc2VMaW1pdCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHVzZUNhc2U6IGRhdGEudXNlQ2FzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBzcGVjaWZpYyBhY3Rpb24gaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqIFRoaXMgZG9lc24ndCBleGVjdXRlIHRoZSBsb2NhbCBhY3Rpb24gYW5kIGlzIHdyYXBwZXIgb3ZlciBiYWNrZW5kLiBUcnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSBmcm9tIHRvb2xzZXRcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gdHJpZ2dlciB0aGUgZXhlY3V0aW9uIG9mIGFuIGFjdGlvbiBieSBwcm92aWRpbmcgaXRzIG5hbWUgYW5kIHRoZSBuZWNlc3NhcnkgaW5wdXQgcGFyYW1ldGVycy4gVGhlIHJlcXVlc3QgaW5jbHVkZXMgdGhlIGNvbm5lY3RlZCBhY2NvdW50IElEIHRvIGlkZW50aWZ5IHRoZSBhcHAgY29ubmVjdGlvbiB0byB1c2UgZm9yIHRoZSBhY3Rpb24sIGFuZCB0aGUgaW5wdXQgcGFyYW1ldGVycyByZXF1aXJlZCBieSB0aGUgYWN0aW9uLiBUaGUgcmVzcG9uc2UgcHJvdmlkZXMgZGV0YWlscyBhYm91dCB0aGUgZXhlY3V0aW9uIHN0YXR1cyBhbmQgdGhlIHJlc3BvbnNlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXhlY3V0ZUFjdGlvbkRhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbkV4ZWN1dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBleGVjdXRpb24gc3RhdHVzIGFuZCByZXNwb25zZSBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGUoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJleGVjdXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWkV4ZWN1dGVQYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlcyB9ID0gYXdhaXQgYXBpQ2xpZW50LmFjdGlvbnNWMi5leGVjdXRlQWN0aW9uVjIoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJzZWREYXRhLnJlcXVlc3RCb2R5LFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2EgPSBwYXJzZWREYXRhLnJlcXVlc3RCb2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2Vzc2lvbkluZm8pIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogKChfYyA9IChfYiA9IHBhcnNlZERhdGEucmVxdWVzdEJvZHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXNzaW9uSW5mbykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlc3Npb25JZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb21wb3Npb1NES0NvbnRleHQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd1RyYWNpbmc6IEJvb2xlYW4oQ29tcG9zaW9TREtDb250ZXh0ID09PSBudWxsIHx8IENvbXBvc2lvU0RLQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogQ29tcG9zaW9TREtDb250ZXh0LmFsbG93VHJhY2luZyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbklkOiBwYXJzZWREYXRhLmFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIGFjdGlvbiBlbnVtcyBieSB1c2UgY2FzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmluZEFjdGlvbkVudW1zQnlVc2VDYXNlUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbkZpbmRBY3Rpb25FbnVtc0J5VXNlQ2FzZVJlcz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFjdGlvbiBlbnVtcy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5kQWN0aW9uRW51bXNCeVVzZUNhc2UoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZmluZEFjdGlvbkVudW1zQnlVc2VDYXNlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWkZpbmRBY3Rpb25FbnVtc0J5VXNlQ2FzZVBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzIH0gPSBhd2FpdCBhcGlDbGllbnQuYWN0aW9uc1YyLmFkdmFuY2VkVXNlQ2FzZVNlYXJjaCh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBhcHBzOiAoX2EgPSBwYXJzZWREYXRhLmFwcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHBhcnNlZERhdGEubGltaXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJCeUF2YWlsYWJsZUFwcHM6IHBhcnNlZERhdGEuZmlsdGVyQnlBdmFpbGFibGVBcHBzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICB1c2VDYXNlOiBwYXJzZWREYXRhLnVzZUNhc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5pdGVtcy5tYXAoKGl0ZW0pID0+IGl0ZW0uYWN0aW9ucykuZmxhdCgpIHx8IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhIGFjdGlvbiB1c2luZyBDb21wb3NpbyBQcm94eVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byB0cmlnZ2VyIHRoZSBleGVjdXRpb24gb2YgYW4gYWN0aW9uIGJ5IHByb3ZpZGluZyBpdHMgbmFtZSBhbmQgdGhlIG5lY2Vzc2FyeSBpbnB1dCBwYXJhbWV0ZXJzLiBUaGUgcmVxdWVzdCBpbmNsdWRlcyB0aGUgY29ubmVjdGVkIGFjY291bnQgSUQgdG8gaWRlbnRpZnkgdGhlIGFwcCBjb25uZWN0aW9uIHRvIHVzZSBmb3IgdGhlIGFjdGlvbiwgYW5kIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIHJlcXVpcmVkIGJ5IHRoZSBhY3Rpb24uIFRoZSByZXNwb25zZSBwcm92aWRlcyBkZXRhaWxzIGFib3V0IHRoZSBleGVjdXRpb24gc3RhdHVzIGFuZCB0aGUgcmVzcG9uc2UgZGF0YSByZXR1cm5lZCBieSB0aGUgYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFeGVjdXRlQWN0aW9uRGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aW9uRXhlY3V0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGV4ZWN1dGlvbiBzdGF0dXMgYW5kIHJlc3BvbnNlIGRhdGEuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZVJlcXVlc3QoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImV4ZWN1dGVSZXF1ZXN0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWkV4ZWN1dGVSZXF1ZXN0UGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXMgfSA9IGF3YWl0IGFwaUNsaWVudC5hY3Rpb25zVjIuZXhlY3V0ZVdpdGhIdHRwQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBwYXJzZWREYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHBhcnNlZERhdGEuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcGFyc2VkRGF0YS5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHBhcnNlZERhdGEucGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcGFyc2VkRGF0YS5ib2R5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBaVHJpZ2dlckl0ZW1QYXJhbSA9IHouei5vYmplY3Qoe1xuICAgIHRyaWdnZXJJZDogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaQWN0aXZlVHJpZ2dlcnNRdWVyeSA9IHouei5vYmplY3Qoe1xuICAgIHRyaWdnZXJJZHM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJOYW1lczogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29ubmVjdGVkQWNjb3VudElkczogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgaW50ZWdyYXRpb25JZHM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGxpbWl0OiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBwYWdlOiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBzaG93RGlzYWJsZWQ6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWkNvbm5lY3Rpb24gPSB6Lnoub2JqZWN0KHtcbiAgICBpZDogei56LnN0cmluZygpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKSxcbiAgICBtZW1iZXJJZDogei56LnN0cmluZygpLFxuICAgIGNsaWVudFVuaXF1ZVVzZXJJZDogei56LnN0cmluZygpLFxuICAgIHN0YXR1czogei56LnN0cmluZygpLFxuICAgIGRhdGE6IHouei5yZWNvcmQoei56LnVua25vd24oKSksXG4gICAgZGVsZXRlZDogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIGVuYWJsZWQ6IHouei5ib29sZWFuKCksXG4gICAgbGFiZWxzOiB6LnouYXJyYXkoei56LnVua25vd24oKSksXG4gICAgY3JlYXRlZEF0OiB6Lnouc3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiB6Lnouc3RyaW5nKCksXG59KTtcbnouei5vYmplY3Qoe1xuICAgIGlkOiB6Lnouc3RyaW5nKCksXG4gICAgY29ubmVjdGlvbklkOiB6Lnouc3RyaW5nKCksXG4gICAgdHJpZ2dlck5hbWU6IHouei5zdHJpbmcoKSxcbiAgICB0cmlnZ2VyRGF0YTogei56LnN0cmluZygpLFxuICAgIHRyaWdnZXJDb25maWc6IHouei5yZWNvcmQoei56LnVua25vd24oKSksXG4gICAgc3RhdGU6IHouei5yZWNvcmQoei56LnVua25vd24oKSksXG4gICAgY3JlYXRlZEF0OiB6Lnouc3RyaW5nKCksXG4gICAgdXBkYXRlZEF0OiB6Lnouc3RyaW5nKCksXG4gICAgZGlzYWJsZWRBdDogei56LnN0cmluZygpLm51bGxhYmxlKCksXG4gICAgZGlzYWJsZWRSZWFzb246IHouei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICAgIGNvbm5lY3Rpb246IFpDb25uZWN0aW9uLFxufSk7XG5cbmNsYXNzIEFjdGl2ZVRyaWdnZXJzIHtcbiAgICBjb25zdHJ1Y3RvcihiYWNrZW5kQ2xpZW50LCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL3Nkay9tb2RlbHMvYWN0aXZlVHJpZ2dlcnMudHNcIjtcbiAgICAgICAgdGhpcy5iYWNrZW5kQ2xpZW50ID0gYmFja2VuZENsaWVudDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKiBNaXNzaW5nIHR5cGUgKi9cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBvZiBhIHNwZWNpZmljIGFjdGl2ZSB0cmlnZ2VyIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybSBieSBwcm92aWRpbmcgaXRzIHRyaWdnZXIgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXNwb25zZSBpbmNsdWRlcyB0aGUgdHJpZ2dlcidzIG5hbWUsIGRlc2NyaXB0aW9uLCBpbnB1dCBwYXJhbWV0ZXJzLCBleHBlY3RlZCByZXNwb25zZSwgYXNzb2NpYXRlZCBhcHAgaW5mb3JtYXRpb24sIGFuZCBlbmFibGVkIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJpZ2dlckl0ZW1QYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJpZ2dlckl0ZW1SZXM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGV0YWlscyBvZiB0aGUgYWN0aXZlIHRyaWdnZXIuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHsgdHJpZ2dlcklkIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyB0cmlnZ2VySWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlRyaWdnZXJJdGVtUGFyYW0ucGFyc2UoeyB0cmlnZ2VySWQgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5nZXRBY3RpdmVUcmlnZ2Vycyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySWRzOiBgJHtwYXJzZWREYXRhLnRyaWdnZXJJZH1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudHJpZ2dlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgYWN0aXZlIHRyaWdnZXJzIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gZmV0Y2ggYSBsaXN0IG9mIGFsbCB0aGUgYXZhaWxhYmxlIGFjdGl2ZSB0cmlnZ2Vycy4gSXQgc3VwcG9ydHMgcGFnaW5hdGlvbiB0byBoYW5kbGUgbGFyZ2UgbnVtYmVycyBvZiB0cmlnZ2Vycy4gVGhlIHJlc3BvbnNlIGluY2x1ZGVzIGFuIGFycmF5IG9mIHRyaWdnZXIgb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHRyaWdnZXIncyBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dldEFjdGl2ZVRyaWdnZXJzRGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8WkFjdGl2ZVRyaWdnZXJJdGVtUmVzW10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhbGwgYWN0aXZlIHRyaWdnZXJzLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QoZGF0YSA9IHt9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwibGlzdFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpBY3RpdmVUcmlnZ2Vyc1F1ZXJ5LnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXNwb25zZSB9ID0gYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLmdldEFjdGl2ZVRyaWdnZXJzKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBwYXJzZWREYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnRyaWdnZXJzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSBwcmV2aW91c2x5IGRpc2FibGVkIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyaWdnZXJJdGVtUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHtzdGF0dXM6IHN0cmluZ30+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGVuYWJsZSByZXF1ZXN0LlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZW5hYmxlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlRyaWdnZXJJdGVtUGFyYW0ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuc3dpdGNoVHJpZ2dlckluc3RhbmNlU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHsgdHJpZ2dlcklkOiBwYXJzZWREYXRhLnRyaWdnZXJJZCB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgcHJldmlvdXNseSBlbmFibGVkIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyaWdnZXJJdGVtUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHtzdGF0dXM6IHN0cmluZ30+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGRpc2FibGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNhYmxlKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJkaXNhYmxlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlRyaWdnZXJJdGVtUGFyYW0ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuc3dpdGNoVHJpZ2dlckluc3RhbmNlU3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhcnNlZERhdGEsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuei56Lm9iamVjdCh7XG4gICAgYXBwS2V5OiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpHZXRSZXF1aXJlZFBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFwcElkOiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpHZXRSZXF1aXJlZFBhcmFtc0ZvckF1dGhTY2hlbWUgPSB6Lnoub2JqZWN0KHtcbiAgICBhcHBJZDogei56LnN0cmluZygpLFxuICAgIGF1dGhTY2hlbWU6IHouei5zdHJpbmcoKSxcbn0pO1xuY29uc3QgWlJlcXVpcmVkUGFyYW1zUmVzcG9uc2UgPSB6Lnoub2JqZWN0KHtcbiAgICByZXF1aXJlZF9maWVsZHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLFxuICAgIGV4cGVjdGVkX2Zyb21fdXNlcjogei56LmFycmF5KHouei5zdHJpbmcoKSksXG4gICAgb3B0aW9uYWxfZmllbGRzOiB6LnouYXJyYXkoei56LnN0cmluZygpKSxcbn0pO1xuei56Lm9iamVjdCh7XG4gICAgYXZhaWxhYmxlQXV0aFNjaGVtZXM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLFxuICAgIGF1dGhTY2hlbWVzOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgWlJlcXVpcmVkUGFyYW1zUmVzcG9uc2UpLFxufSk7XG5cbmNsYXNzIEFwcHMge1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL21vZGVscy9hcHBzLnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgYXBwcyBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBleHBsb3JlIGFuZCBkaXNjb3ZlciB0aGUgc3VwcG9ydGVkIGFwcHMuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgYXBwIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBlc3NlbnRpYWwgZGV0YWlscyBzdWNoIGFzIHRoZSBhcHAncyBrZXksIG5hbWUsIGRlc2NyaXB0aW9uLCBsb2dvLCBjYXRlZ29yaWVzLCBhbmQgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBJdGVtTGlzdFJlc3BvbnNlW10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhbGwgYXBwcy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImxpc3RcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpQ2xpZW50LmFwcHMuZ2V0QXBwcyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsRmllbGRzOiBcImF1dGhfc2NoZW1lc1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLml0ZW1zKSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGRldGFpbHMgb2YgYSBzcGVjaWZpYyBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZmV0Y2ggZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpYyBhcHAgYnkgcHJvdmlkaW5nIGl0cyB1bmlxdWUga2V5LiBUaGUgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIGFwcCdzIG5hbWUsIGtleSwgc3RhdHVzLCBkZXNjcmlwdGlvbiwgbG9nbywgY2F0ZWdvcmllcywgYXV0aGVudGljYXRpb24gc2NoZW1lcywgYW5kIG90aGVyIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcHBHZXREYXRhUGFyYW1zfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBhcHAncyB1bmlxdWUga2V5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcEl0ZW1SZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXRhaWxzIG9mIHRoZSBhcHAuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzcG9uc2UgfSA9IGF3YWl0IGFwaUNsaWVudC5hcHBzLmdldEFwcCh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IGRhdGEuYXBwS2V5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXBwIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGFwcCBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBmZXRjaCB0aGUgbmVjZXNzYXJ5IHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgYXBwIGJ5IHByb3ZpZGluZyBpdHMgdW5pcXVlIGtleS4gVGhlIHJlc3BvbnNlIGluY2x1ZGVzIHRoZSBhcHAncyBuYW1lLCBrZXksIHN0YXR1cywgZGVzY3JpcHRpb24sIGxvZ28sIGNhdGVnb3JpZXMsIGF1dGhlbnRpY2F0aW9uIHNjaGVtZXMsIGFuZCBvdGhlciBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcHBJZCBUaGUgdW5pcXVlIGtleSBvZiB0aGUgYXBwLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcFJlcXVpcmVkUGFyYW1zRnVsbFJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIHRoZSBhcHAuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWlyZWRQYXJhbXMoYXBwSWQpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRSZXF1aXJlZFBhcmFtc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBhcHBJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpHZXRSZXF1aXJlZFBhcmFtcy5wYXJzZSh7IGFwcElkIH0pO1xuICAgICAgICAgICAgY29uc3QgYXBwRGF0YSA9IGF3YWl0IHRoaXMuZ2V0KHsgYXBwS2V5OiBhcHBJZCB9KTtcbiAgICAgICAgICAgIGlmICghYXBwRGF0YSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcHAgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgY29uc3QgYXV0aFNjaGVtZXMgPSBhcHBEYXRhLmF1dGhfc2NoZW1lcztcbiAgICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZUF1dGhTY2hlbWVzID0gYXV0aFNjaGVtZXMgPT09IG51bGwgfHwgYXV0aFNjaGVtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1dGhTY2hlbWVzLm1hcCgoc2NoZW1lKSA9PiBzY2hlbWUgPT09IG51bGwgfHwgc2NoZW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWUubW9kZSk7XG4gICAgICAgICAgICBjb25zdCBhdXRoU2NoZW1lc09iamVjdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWUgb2YgYXV0aFNjaGVtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gc2NoZW1lLm1vZGU7XG4gICAgICAgICAgICAgICAgYXV0aFNjaGVtZXNPYmplY3RbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkX2ZpZWxkczogW10sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsX2ZpZWxkczogW10sXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkX2Zyb21fdXNlcjogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2hlbWUuZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRXhwZWN0ZWRGb3JJbnRlZ3JhdGlvblNldHVwID0gZmllbGQuZXhwZWN0ZWRfZnJvbV9jdXN0b21lciA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBmaWVsZC5yZXF1aXJlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhwZWN0ZWRGb3JJbnRlZ3JhdGlvblNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTY2hlbWVzT2JqZWN0W25hbWVdLmV4cGVjdGVkX2Zyb21fdXNlci5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFNjaGVtZXNPYmplY3RbbmFtZV0ub3B0aW9uYWxfZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoU2NoZW1lc09iamVjdFtuYW1lXS5yZXF1aXJlZF9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVBdXRoU2NoZW1lcyxcbiAgICAgICAgICAgICAgICBhdXRoU2NoZW1lczogYXV0aFNjaGVtZXNPYmplY3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgYXV0aGVudGljYXRpb24gc2NoZW1lIG9mIGFuIGFwcCBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBmZXRjaCB0aGUgbmVjZXNzYXJ5IHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgYXV0aGVudGljYXRpb24gc2NoZW1lIG9mIGFuIGFwcCBieSBwcm92aWRpbmcgaXRzIHVuaXF1ZSBrZXkgYW5kIHRoZSBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FwcEdldFJlcXVpcmVkUGFyYW1zRm9yQXV0aFNjaGVtZVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBhcHAncyB1bmlxdWUga2V5IGFuZCB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFwcFJlcXVpcmVkUGFyYW1zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3IgdGhlIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1aXJlZFBhcmFtc0ZvckF1dGhTY2hlbWUoeyBhcHBJZCwgYXBwTmFtZSwgYXV0aFNjaGVtZSwgfSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFJlcXVpcmVkUGFyYW1zRm9yQXV0aFNjaGVtZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBhcHBJZCwgYXV0aFNjaGVtZSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQXBwSWQgPSBhcHBOYW1lIHx8IGFwcElkO1xuICAgICAgICAgICAgWkdldFJlcXVpcmVkUGFyYW1zRm9yQXV0aFNjaGVtZS5wYXJzZSh7IGFwcElkOiBmaW5hbEFwcElkLCBhdXRoU2NoZW1lIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXdhaXQgdGhpcy5nZXRSZXF1aXJlZFBhcmFtcyhmaW5hbEFwcElkKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuYXV0aFNjaGVtZXNbYXV0aFNjaGVtZV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBaQ29ubmVjdGlvblN0YXR1cyA9IHouei5lbnVtKFtcIklOSVRJQVRFRFwiLCBcIkFDVElWRVwiLCBcIkZBSUxFRFwiXSk7XG5jb25zdCBaTGlzdENvbm5lY3Rpb25zRGF0YSA9IHouei5vYmplY3Qoe1xuICAgIGFwcE5hbWVzOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBhcHBVbmlxdWVLZXlzOiB6Lnouc3RyaW5nKCkuYXJyYXkoKS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3Rpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZW50aXR5SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGxhYmVsczogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcGFnZTogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgcGFnZVNpemU6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIHNob3dBY3RpdmVPbmx5OiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgc2hvd0Rpc2FibGVkOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgc3RhdHVzOiBaQ29ubmVjdGlvblN0YXR1cy5vcHRpb25hbCgpLFxuICAgIHVzZXJfdXVpZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbnouei5vYmplY3Qoe1xuICAgIGNvbm5lY3Rpb25QYXJhbXM6IHouei5yZWNvcmQoei56LnN0cmluZygpLCB6LnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBsYWJlbHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcmVkaXJlY3RVcmk6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGF1dGhNb2RlOiBaQXV0aE1vZGUub3B0aW9uYWwoKSxcbiAgICBhdXRoQ29uZmlnOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgei56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbiAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlNhdmVVc2VyQWNjZXNzRGF0YVBhcmFtID0gei56Lm9iamVjdCh7XG4gICAgZmllbGRJbnB1dHM6IHouei5yZWNvcmQoei56LnN0cmluZygpLCB6LnoudW5rbm93bigpKSxcbiAgICByZWRpcmVjdFVybDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZW50aXR5SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBaU2luZ2xlQ29ubmVjdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLFxufSk7XG56Lnoub2JqZWN0KHtcbiAgICBkYXRhOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgei56LnVua25vd24oKSksXG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLFxuICAgIHJlZGlyZWN0VXJpOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB1c2VyVXVpZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgZW50aXR5SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGxhYmVsczogei56LnN0cmluZygpLmFycmF5KCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlJlaW5pdGlhdGVDb25uZWN0aW9uUGF5bG9hZER0byA9IHouei5vYmplY3Qoe1xuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLFxuICAgIGRhdGE6IHouei5yZWNvcmQoei56LnN0cmluZygpLCB6LnoudW5rbm93bigpKSxcbiAgICByZWRpcmVjdFVyaTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgY29ubmVjdGVkIGFjY291bnRzIGluIHRoZSBzeXN0ZW0uXG4gKi9cbmNsYXNzIENvbm5lY3RlZEFjY291bnRzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29ubmVjdGVkQWNjb3VudHMgY2xhc3MuXG4gICAgICogQHBhcmFtIHtBeGlvc0JhY2tlbmRDbGllbnR9IGJhY2tlbmRDbGllbnQgLSBUaGUgYmFja2VuZCBjbGllbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmFja2VuZENsaWVudCwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL2Nvbm5lY3RlZEFjY291bnRzLnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBjb25uZWN0ZWQgYWNjb3VudHNcbiAgICAgKiBAcGFyYW0ge0Nvbm5lY3RlZEFjY291bnRzTGlzdERhdGF9IGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhlIGNvbm5lY3RlZCBhY2NvdW50cyBsaXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGVkQWNjb3VudExpc3RSZXNwb25zZT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBsaXN0IG9mIGNvbm5lY3RlZCBhY2NvdW50c1xuICAgICAqL1xuICAgIGFzeW5jIGxpc3QoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImxpc3RcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXBwTmFtZXMsIGFwcFVuaXF1ZUtleXMgfSA9IFpMaXN0Q29ubmVjdGlvbnNEYXRhLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxBcHBOYW1lcyA9IGFwcE5hbWVzIHx8IChhcHBVbmlxdWVLZXlzID09PSBudWxsIHx8IGFwcFVuaXF1ZUtleXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcFVuaXF1ZUtleXMuam9pbihcIixcIikpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmxpc3RDb25uZWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lczogZmluYWxBcHBOYW1lcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNpbmdsZSBjb25uZWN0ZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7U2luZ2xlQ29ubmVjdGlvblBhcmFtfSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBzaW5nbGUgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpbmdsZUNvbm5lY3RlZEFjY291bnRSZXNwb25zZT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzaW5nbGUgY29ubmVjdGVkIGFjY291bnRcbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWlNpbmdsZUNvbm5lY3Rpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnMuZ2V0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiBkYXRhLFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBzaW5nbGUgY29ubmVjdGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge1NpbmdsZUNvbm5lY3Rpb25QYXJhbX0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGUgc2luZ2xlIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaW5nbGVEZWxldGVSZXNwb25zZT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGVkIGFjY291bnQgaXMgZGVsZXRlZFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaU2luZ2xlQ29ubmVjdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaUNsaWVudC5jb25uZWN0aW9ucy5kZWxldGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IGRhdGEsXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgYSBzaW5nbGUgY29ubmVjdGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge1NpbmdsZUNvbm5lY3Rpb25QYXJhbX0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGUgc2luZ2xlIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uQ2hhbmdlUmVzcG9uc2U+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3RlZCBhY2NvdW50IGlzIGRpc2FibGVkXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGlzYWJsZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWlNpbmdsZUNvbm5lY3Rpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnMuZGlzYWJsZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDogZGF0YSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGRhdGEuY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGEgc2luZ2xlIGNvbm5lY3RlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTaW5nbGVDb25uZWN0aW9uUGFyYW19IGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhlIHNpbmdsZSBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbkNoYW5nZVJlc3BvbnNlPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0ZWQgYWNjb3VudCBpcyBlbmFibGVkXG4gICAgICovXG4gICAgYXN5bmMgZW5hYmxlKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJlbmFibGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTaW5nbGVDb25uZWN0aW9uUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmVuYWJsZUNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGRhdGEuY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBkYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7SW5pdGlhdGVDb25uZWN0aW9uRGF0YVJlcX0gcGF5bG9hZCAtIFRoZSBwYXlsb2FkIGZvciB0aGUgY29ubmVjdGlvbiBpbml0aWF0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvblJlcXVlc3Q+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29ubmVjdGlvbiByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhdGUocGF5bG9hZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiaW5pdGlhdGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgcGF5bG9hZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnNWMi5pbml0aWF0ZUNvbm5lY3Rpb25WMih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlS2V5OiBwYXlsb2FkLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBwYXlsb2FkLmludGVncmF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlQ29tcG9zaW9BdXRoOiAhIXBheWxvYWQuYXV0aE1vZGUgJiYgISFwYXlsb2FkLmF1dGhDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoU2NoZW1lOiBwYXlsb2FkLmF1dGhNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25TZWNyZXRzOiBwYXlsb2FkLmF1dGhDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiBwYXlsb2FkLmVudGl0eUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhdGVEYXRhOiBwYXlsb2FkLmNvbm5lY3Rpb25QYXJhbXMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VVJMOiBwYXlsb2FkLnJlZGlyZWN0VXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogcGF5bG9hZC5sYWJlbHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25SZXNwb25zZSA9IChfYSA9IGNvbm5lY3Rpb24gPT09IG51bGwgfHwgY29ubmVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvbi5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblJlc3BvbnNlID09PSBudWxsIHx8IGNvbm5lY3Rpb25SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvblJlc3BvbnNlLmNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBjb25uZWN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHwgY29ubmVjdGlvblJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uUmVzcG9uc2UuY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBjb25uZWN0aW9uUmVzcG9uc2UgPT09IG51bGwgfHwgY29ubmVjdGlvblJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uUmVzcG9uc2UucmVkaXJlY3RVcmwsXG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWluaXRpYXRlIGEgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7UmVpbml0aWF0ZUNvbm5lY3Rpb25QYXlsb2FkfSBkYXRhIC0gVGhlIHBheWxvYWQgZm9yIHRoZSBjb25uZWN0aW9uIHJlaW5pdGlhbGl6YXRpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uUmVxdWVzdD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBjb25uZWN0aW9uIHJlcXVlc3RcbiAgICAgKi9cbiAgICBhc3luYyByZWluaXRpYXRlQ29ubmVjdGlvbihkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwicmVpbml0aWF0ZUNvbm5lY3Rpb25cIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpSZWluaXRpYXRlQ29ubmVjdGlvblBheWxvYWREdG8ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLnJlaW5pdGlhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBkYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5kYXRhLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogZGF0YS5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjb25uZWN0aW9uLmRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbm5lY3Rpb25SZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMuY29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IHJlcyA9PT0gbnVsbCB8fCByZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcy5yZWRpcmVjdFVybCxcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29ubmVjdGlvblJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKHsgY29ubmVjdGlvblN0YXR1cywgY29ubmVjdGVkQWNjb3VudElkLCByZWRpcmVjdFVyaSwgY2xpZW50LCB9KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyA9IGNvbm5lY3Rpb25TdGF0dXM7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWNjb3VudElkID0gY29ubmVjdGVkQWNjb3VudElkO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJsID0gcmVkaXJlY3RVcmk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBzYXZlVXNlckFjY2Vzc0RhdGEoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWlNhdmVVc2VyQWNjZXNzRGF0YVBhcmFtLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjb25uZWN0ZWRBY2NvdW50IH0gPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnMuZ2V0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7IGNvbm5lY3RlZEFjY291bnRJZDogdGhpcy5jb25uZWN0ZWRBY2NvdW50SWQgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRBY2NvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbm5lY3RlZCBhY2NvdW50IG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnMuaW5pdGlhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogY29ubmVjdGVkQWNjb3VudC5pbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5maWVsZElucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IGRhdGEucmVkaXJlY3RVcmwsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJVdWlkOiBkYXRhLmVudGl0eUlkLFxuICAgICAgICAgICAgICAgICAgICBlbnRpdHlJZDogZGF0YS5lbnRpdHlJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXQgdW50aWwgdGhlIGNvbm5lY3Rpb24gYmVjb21lcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCAtIFRoZSB0aW1lb3V0IGZvciB0aGUgY29ubmVjdGlvbiB0byBiZWNvbWUgYWN0aXZlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbj59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0VW50aWxBY3RpdmUodGltZW91dCA9IDYwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0ICogMTAwMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLmdldENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiB7IGNvbm5lY3RlZEFjY291bnRJZDogdGhpcy5jb25uZWN0ZWRBY2NvdW50SWQgfSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0ZWQgYWNjb3VudCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uc3RhdHVzID09PSBcIkFDVElWRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGRpZCBub3QgYmVjb21lIGFjdGl2ZSB3aXRoaW4gdGhlIHRpbWVvdXQgcGVyaW9kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEludGVncmF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoYmFja2VuZENsaWVudCwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL2ludGVncmF0aW9ucy50c1wiO1xuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBiYWNrZW5kQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGludGVncmF0aW9ucyBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBleHBsb3JlIGFuZCBkaXNjb3ZlciB0aGUgc3VwcG9ydGVkIGludGVncmF0aW9ucy4gSXQgcmV0dXJucyBhbiBhcnJheSBvZiBpbnRlZ3JhdGlvbiBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgZXNzZW50aWFsIGRldGFpbHMgc3VjaCBhcyB0aGUgaW50ZWdyYXRpb24ncyBrZXksIG5hbWUsIGRlc2NyaXB0aW9uLCBsb2dvLCBjYXRlZ29yaWVzLCBhbmQgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnRlZ3JhdGlvbkxpc3RSZXM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhbGwgaW50ZWdyYXRpb25zLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QoZGF0YSA9IHt9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwibGlzdFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBhcHBOYW1lLCBhcHBVbmlxdWVLZXksIC4uLnJlc3QgfSA9IFpMaXN0SW50ZWdyYXRpb25zUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxBcHBOYW1lID0gYXBwTmFtZSAmJiBhcHBOYW1lLmxlbmd0aCA+IDAgPyBhcHBOYW1lIDogYXBwVW5pcXVlS2V5O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuYXBwQ29ubmVjdG9yLmxpc3RBbGxDb25uZWN0b3JzKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7IC4uLnJlc3QsIGFwcE5hbWU6IGZpbmFsQXBwTmFtZSB9LFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgaW50ZWdyYXRpb24gaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtIGJ5IHByb3ZpZGluZyBpdHMgaW50ZWdyYXRpb24gbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXNwb25zZSBpbmNsdWRlcyB0aGUgaW50ZWdyYXRpb24ncyBuYW1lLCBkaXNwbGF5IG5hbWUsIGRlc2NyaXB0aW9uLCBpbnB1dCBwYXJhbWV0ZXJzLCBleHBlY3RlZCByZXNwb25zZSwgYXNzb2NpYXRlZCBhcHAgaW5mb3JtYXRpb24sIGFuZCBlbmFibGVkIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZWdyYXRpb25HZXRQYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb25HZXRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZXRhaWxzIG9mIHRoZSBpbnRlZ3JhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuYXBwQ29ubmVjdG9yLmdldENvbm5lY3RvckluZm8oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDogZGF0YSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgaW50ZWdyYXRpb24ncyBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGdldCB0aGUgbmVjZXNzYXJ5IGlucHV0IGZpZWxkcyBmb3IgYSBzcGVjaWZpYyBpbnRlZ3JhdGlvbidzIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZWdyYXRpb25HZXRQYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb25SZXF1aXJlZFBhcmFtc1Jlcz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciB0aGUgaW50ZWdyYXRpb24ncyBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWlyZWRQYXJhbXMoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0UmVxdWlyZWRQYXJhbXNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTaW5nbGVJbnRlZ3JhdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3Rvci5nZXRDb25uZWN0b3JJbmZvKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogZGF0YS5pbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cGVjdGVkSW5wdXRGaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW50ZWdyYXRpb24gaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gY3JlYXRlIGEgbmV3IGludGVncmF0aW9uIGJ5IHByb3ZpZGluZyB0aGUgbmVjZXNzYXJ5IGRldGFpbHMgc3VjaCBhcyBhcHAgSUQsIG5hbWUsIGF1dGhlbnRpY2F0aW9uIG1vZGUsIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbnRlZ3JhdGlvbkNyZWF0ZVBhcmFtc30gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb25HZXRSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjcmVhdGVkIGludGVncmF0aW9uIG1vZGVsLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJjcmVhdGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpDcmVhdGVJbnRlZ3JhdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGxldCB1bmlxdWVLZXkgPSBkYXRhLmFwcFVuaXF1ZUtleTtcbiAgICAgICAgICAgIGlmICghdW5pcXVlS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcyA9IGF3YWl0IGFwaUNsaWVudC5hcHBzLmdldEFwcHMoeyBjbGllbnQ6IHRoaXMuY2xpZW50IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IChfYSA9IGFwcHMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW1zLmZpbmQoKGFwcCkgPT4gYXBwLmFwcElkID09PSBkYXRhLmFwcElkKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVLZXkgPSBhcHAua2V5O1xuICAgICAgICAgICAgICAgIGlmICghdW5pcXVlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIGFwcCB3YXMgZm91bmQgd2l0aCB0aGUgcHJvdmlkZWQgYXBwSWRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBQbGVhc2UgcHJvdmlkZSBhbiBhcHAgdW5pcXVlIGtleWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3RvclYyLmNyZWF0ZUNvbm5lY3RvclYyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVLZXk6IHVuaXF1ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VDb21wb3Npb0F1dGg6IGRhdGEudXNlQ29tcG9zaW9BdXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogZGF0YS5hdXRoU2NoZW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25TZWNyZXRzOiBkYXRhLmF1dGhDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGludGVncmF0aW9uSWQgPSByZXNwb25zZS5kYXRhLmludGVncmF0aW9uSWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoeyBpbnRlZ3JhdGlvbklkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZUludGVncmF0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldE9yQ3JlYXRlSW50ZWdyYXRpb25cIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpDcmVhdGVJbnRlZ3JhdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGxldCB1bmlxdWVLZXkgPSBkYXRhLmFwcFVuaXF1ZUtleTtcbiAgICAgICAgICAgIGlmICghdW5pcXVlS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwcyA9IGF3YWl0IGFwaUNsaWVudC5hcHBzLmdldEFwcHMoeyBjbGllbnQ6IHRoaXMuY2xpZW50IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcCA9IChfYSA9IGFwcHMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW1zLmZpbmQoKGFwcCkgPT4gYXBwLmFwcElkID09PSBkYXRhLmFwcElkKTtcbiAgICAgICAgICAgICAgICB1bmlxdWVLZXkgPSBhcHAua2V5O1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTm8gYXBwIHdhcyBmb3VuZCB3aXRoIHRoZSBwcm92aWRlZCBhcHBJZGAsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUGxlYXNlIHByb3ZpZGUgYW4gYXBwIHVuaXF1ZSBrZXlgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuYXBwQ29ubmVjdG9yVjIuZ2V0T3JDcmVhdGVDb25uZWN0b3Ioe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUtleSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VDb21wb3Npb0F1dGg6IGRhdGEudXNlQ29tcG9zaW9BdXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogZGF0YS5hdXRoU2NoZW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25TZWNyZXRzOiBkYXRhLmF1dGhDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGludGVncmF0aW9uSWQgPSByZXNwb25zZS5kYXRhLmludGVncmF0aW9uSWQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoeyBpbnRlZ3JhdGlvbklkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIGV4aXN0aW5nIGludGVncmF0aW9uIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBjbGllbnRzIHRvIGRlbGV0ZSBhbiBleGlzdGluZyBpbnRlZ3JhdGlvbiBieSBwcm92aWRpbmcgaXRzIGludGVncmF0aW9uIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbnRlZ3JhdGlvbkxpc3REYXRhfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbnRlZ3JhdGlvbkRlbGV0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlbGV0ZWQgaW50ZWdyYXRpb24gbW9kZWwuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJkZWxldGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTaW5nbGVJbnRlZ3JhdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3Rvci5kZWxldGVDb25uZWN0b3Ioe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBkYXRhLmludGVncmF0aW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgUFVTSEVSX0tFWSA9IHByb2Nlc3MuZW52LkNMSUVOVF9QVVNIRVJfS0VZIHx8IFwiOGUxYjhjOTJiN2Y4YjIxNTFjMTVcIjtcbmNvbnN0IFBVU0hFUl9DTFVTVEVSID0gXCJtdDFcIjtcbmNsYXNzIFB1c2hlclV0aWxzIHtcbiAgICBzdGF0aWMgZ2V0UHVzaGVyQ2xpZW50KGJhc2VVUkwsIGFwaUtleSkge1xuICAgICAgICBpZiAoIVB1c2hlclV0aWxzLnB1c2hlckNsaWVudCkge1xuICAgICAgICAgICAgLy8gRHluYW1pYyBpbXBvcnQgbm90IGF2YWlsYWJsZSwgdXNpbmcgcmVxdWlyZSBmb3Igbm93XG4gICAgICAgICAgICAvLyBUT0RPOiBVcGRhdGUgdG8gdXNlIGR5bmFtaWMgaW1wb3J0IHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICAgICAgY29uc3QgUHVzaGVyQ2xpZW50ID0gcmVxdWlyZShcInB1c2hlci1qc1wiKTtcbiAgICAgICAgICAgIFB1c2hlclV0aWxzLnB1c2hlckNsaWVudCA9IG5ldyBQdXNoZXJDbGllbnQoUFVTSEVSX0tFWSwge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXI6IFBVU0hFUl9DTFVTVEVSLFxuICAgICAgICAgICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBgJHtiYXNlVVJMfS9hcGkvdjEvY2xpZW50L2F1dGgvcHVzaGVyX2F1dGhgLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogXCJhamF4XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQdXNoZXJVdGlscy5wdXNoZXJDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gYSBQdXNoZXIgY2hhbm5lbCBhbmQgYmluZHMgYW4gZXZlbnQgdG8gYSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhbm5lbE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hhbm5lbCB0byBzdWJzY3JpYmUgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJpbmQgdG8gdGhlIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHsoZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHZvaWR9IGZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgICAqIEByZXR1cm5zIHtQdXNoZXJDbGllbnR9IFRoZSBQdXNoZXIgY2xpZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBzdWJzY3JpYmUoY2hhbm5lbE5hbWUsIGV2ZW50LCBmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHVzaGVyVXRpbHMucHVzaGVyQ2xpZW50LnN1YnNjcmliZShjaGFubmVsTmFtZSkuYmluZChldmVudCwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBzdWJzY3JpYmluZyB0byAke2NoYW5uZWxOYW1lfSB3aXRoIGV2ZW50ICR7ZXZlbnR9OiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGEgUHVzaGVyIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gdW5zdWJzY3JpYmUgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgdW5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpIHtcbiAgICAgICAgUHVzaGVyVXRpbHMucHVzaGVyQ2xpZW50LnVuc3Vic2NyaWJlKGNoYW5uZWxOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgYW4gZXZlbnQgdG8gYSBjaGFubmVsIHdpdGggc3VwcG9ydCBmb3IgY2h1bmtlZCBtZXNzYWdlcy5cbiAgICAgKiBAcGFyYW0ge1B1c2hlckNsaWVudH0gY2hhbm5lbCAtIFRoZSBQdXNoZXIgY2hhbm5lbCB0byBiaW5kIHRoZSBldmVudCB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgdG8gYmluZCB0byB0aGUgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0geyhkYXRhOiB1bmtub3duKSA9PiB2b2lkfSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFdpdGhDaHVua2luZyhjaGFubmVsLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgY2hhbm5lbC5iaW5kKGV2ZW50LCBjYWxsYmFjayk7IC8vIEFsbG93IG5vcm1hbCB1bmNodW5rZWQgZXZlbnRzLlxuICAgICAgICAvLyBOb3cgdGhlIGNodW5rZWQgdmFyaWF0aW9uLiBBbGxvd3MgYXJiaXRyYXJpbHkgbG9uZyBtZXNzYWdlcy5cbiAgICAgICAgY29uc3QgZXZlbnRzID0ge307XG4gICAgICAgIGNoYW5uZWwuYmluZChcImNodW5rZWQtXCIgKyBldmVudCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkRGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBpZiAoIWV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlZERhdGEuaWQpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzW3R5cGVkRGF0YS5pZF0gPSB7IGNodW5rczogW10sIHJlY2VpdmVkRmluYWw6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldiA9IGV2ZW50c1t0eXBlZERhdGEuaWRdO1xuICAgICAgICAgICAgZXYuY2h1bmtzW3R5cGVkRGF0YS5pbmRleF0gPSB0eXBlZERhdGEuY2h1bms7XG4gICAgICAgICAgICBpZiAodHlwZWREYXRhLmZpbmFsKVxuICAgICAgICAgICAgICAgIGV2LnJlY2VpdmVkRmluYWwgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2LnJlY2VpdmVkRmluYWwgJiZcbiAgICAgICAgICAgICAgICBldi5jaHVua3MubGVuZ3RoID09PSBPYmplY3Qua2V5cyhldi5jaHVua3MpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKEpTT04ucGFyc2UoZXYuY2h1bmtzLmpvaW4oXCJcIikpKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVkRGF0YS5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGEgdHJpZ2dlciBjaGFubmVsIGZvciBhIGNsaWVudCBhbmQgaGFuZGxlcyBjaHVua2VkIGRhdGEuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudElkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2xpZW50IHN1YnNjcmliaW5nIHRvIHRoZSBldmVudHMuXG4gICAgICogQHBhcmFtIHsoZGF0YTogVHJpZ2dlckRhdGEpID0+IHZvaWR9IGZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0cmlnZ2VyIGRhdGEgaXMgcmVjZWl2ZWQuXG4gICAgICovXG4gICAgc3RhdGljIHRyaWdnZXJTdWJzY3JpYmUoY2xpZW50SWQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBQdXNoZXJVdGlscy5wdXNoZXJDbGllbnQuc3Vic2NyaWJlKGBwcml2YXRlLSR7Y2xpZW50SWR9X3RyaWdnZXJzYCk7XG4gICAgICAgIFB1c2hlclV0aWxzLmJpbmRXaXRoQ2h1bmtpbmcoY2hhbm5lbCwgXCJ0cmlnZ2VyX3RvX2NsaWVudFwiLCBmbik7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBTdWJzY3JpYmVkIHRvIHRyaWdnZXJzLiBZb3Ugc2hvdWxkIHN0YXJ0IHJlY2VpdmluZyBldmVudHMgbm93LmApO1xuICAgIH1cbiAgICBzdGF0aWMgdHJpZ2dlclVuc3Vic2NyaWJlKGNsaWVudElkKSB7XG4gICAgICAgIFB1c2hlclV0aWxzLnB1c2hlckNsaWVudC51bnN1YnNjcmliZShgJHtjbGllbnRJZH1fdHJpZ2dlcnNgKTtcbiAgICB9XG59XG5cbmNvbnN0IFpUcmlnZ2VyUXVlcnkgPSB6Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySWRzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVHJpZ2dlciBJbnN0YW5jZSBJRHNcIiksXG4gICAgdHJpZ2dlckluc3RhbmNlSWRzOiB6LnpcbiAgICAgICAgLmFycmF5KHouei5zdHJpbmcoKSlcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiVHJpZ2dlciBJbnN0YW5jZSBJRHNcIiksXG4gICAgYXBwTmFtZXM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJBcHAgTmFtZXMgaW4gbG93ZXJjYXNlXCIpLFxuICAgIGFwcFVuaXF1ZUtleXM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJBcHAgVW5pcXVlIEtleXNcIiksXG4gICAgY29ubmVjdGVkQWNjb3VudElkczogei56XG4gICAgICAgIC5hcnJheSh6Lnouc3RyaW5nKCkpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIkNvbm5lY3RlZCBBY2NvdW50IFVVSURzXCIpLFxuICAgIGludGVncmF0aW9uSWRzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiSW50ZWdyYXRpb24gSURzXCIpLFxuICAgIHNob3dFbmFibGVkT25seTogei56XG4gICAgICAgIC5ib29sZWFuKClcbiAgICAgICAgLm9wdGlvbmFsKClcbiAgICAgICAgLmRlc2NyaWJlKFwiU2hvdyBFbmFibGVkIHRyaWdnZXJzIG9ubHlcIiksXG59KTtcbmNvbnN0IFpUcmlnZ2VySW5zdGFuY2VJdGVtcyA9IHouei5vYmplY3Qoe1xuICAgIHRyaWdnZXJJbnN0YW5jZUlkOiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpUcmlnZ2VyU2V0dXBQYXJhbSA9IHouei5vYmplY3Qoe1xuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLFxuICAgIHRyaWdnZXJOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgY29uZmlnOiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLm9wdGlvbmFsKCksXG59KTtcbnouei5vYmplY3Qoe1xuICAgIGFwcE5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29ubmVjdGlvbklkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBpbnRlZ3JhdGlvbklkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB0cmlnZ2VyTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdHJpZ2dlckRhdGE6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlNpbmdsZVRyaWdnZXJQYXJhbSA9IHouei5vYmplY3Qoe1xuICAgIHRyaWdnZXJJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdHJpZ2dlck5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG56Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySW5zdGFuY2VJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdHJpZ2dlcklkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuei56Lm9iamVjdCh7XG4gICAgbmFtZTogei56LnN0cmluZygpLFxuICAgIGRpc3BsYXlOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgZGVzY3JpcHRpb246IHouei5zdHJpbmcoKSxcbiAgICB0eXBlOiB6Lnouc3RyaW5nKCksXG4gICAgYXBwSWQ6IHouei5zdHJpbmcoKSxcbiAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBwYXlsb2FkOiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLFxuICAgIGNvbmZpZzogei56LnJlY29yZCh6LnoudW5rbm93bigpKSxcbn0pO1xuXG5jbGFzcyBUcmlnZ2VycyB7XG4gICAgY29uc3RydWN0b3IoYmFja2VuZENsaWVudCwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcl90b19jbGllbnRfZXZlbnQgPSBcInRyaWdnZXJfdG9fY2xpZW50XCI7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL3RyaWdnZXJzLnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGFsbCB0cmlnZ2VycyBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGF2YWlsYWJsZSB0cmlnZ2Vycy4gSXQgc3VwcG9ydHMgcGFnaW5hdGlvbiB0byBoYW5kbGUgbGFyZ2UgbnVtYmVycyBvZiB0cmlnZ2Vycy4gVGhlIHJlc3BvbnNlIGluY2x1ZGVzIGFuIGFycmF5IG9mIHRyaWdnZXIgb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHRyaWdnZXIncyBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xpc3RUcmlnZ2Vyc0RhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPExpc3RUcmlnZ2Vyc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgYWxsIHRyaWdnZXJzLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QoZGF0YSA9IHt9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwibGlzdFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBhcHBOYW1lcywgdHJpZ2dlcklkcywgY29ubmVjdGVkQWNjb3VudElkcywgaW50ZWdyYXRpb25JZHMsIHNob3dFbmFibGVkT25seSwgdHJpZ2dlckluc3RhbmNlSWRzLCBhcHBVbmlxdWVLZXlzLCB9ID0gWlRyaWdnZXJRdWVyeS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsVHJpZ2dlckluc3RhbmNlSWRzID0gdHJpZ2dlcklkcyAmJiB0cmlnZ2VySWRzLmxlbmd0aCA+IDAgPyB0cmlnZ2VySWRzIDogdHJpZ2dlckluc3RhbmNlSWRzO1xuICAgICAgICAgICAgY29uc3QgZmluYWxBcHBOYW1lcyA9IGFwcE5hbWVzICYmIGFwcE5hbWVzLmxlbmd0aCA+IDAgPyBhcHBOYW1lcyA6IGFwcFVuaXF1ZUtleXM7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlc3BvbnNlIH0gPSBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMubGlzdFRyaWdnZXJzKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWVzOiBmaW5hbEFwcE5hbWVzID09PSBudWxsIHx8IGZpbmFsQXBwTmFtZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbmFsQXBwTmFtZXMuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJJZHM6IGZpbmFsVHJpZ2dlckluc3RhbmNlSWRzID09PSBudWxsIHx8IGZpbmFsVHJpZ2dlckluc3RhbmNlSWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaW5hbFRyaWdnZXJJbnN0YW5jZUlkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkczogY29ubmVjdGVkQWNjb3VudElkcyA9PT0gbnVsbCB8fCBjb25uZWN0ZWRBY2NvdW50SWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0ZWRBY2NvdW50SWRzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkczogaW50ZWdyYXRpb25JZHMgPT09IG51bGwgfHwgaW50ZWdyYXRpb25JZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVncmF0aW9uSWRzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICBzaG93RW5hYmxlZE9ubHk6IHNob3dFbmFibGVkT25seSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8IHJlc3BvbnNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5OT1RfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUcmlnZ2VyIG5vdCBmb3VuZCB3aXRoIHRoZSBnaXZlbiBwYXJhbXNcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBub3QgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBhc3MgYSBjaGVjayBpZiBmaWx0ZXIgcGFyYW1zIGFyZSBjb3JyZWN0XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29uZmlndXJhdGlvbiBvZiBhIHNpbmdsZSB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VyU2luZ2xlUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyaWdnZXJTaW5nbGVDb25maWc+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJpZ2dlciBjb25maWd1cmF0aW9uLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldChkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgbWV0aG9kOiBcImdldFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmlnZ2VySW5mbyhkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHRyaWdnZXIuZ2V0IGluc3RlYWRcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBzaW5nbGUgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJpZ2dlclNpbmdsZVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmlnZ2VyU2luZ2xlQ29uZmlnPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyaWdnZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmlnZ2VyQ29uZmlnKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTaW5nbGVUcmlnZ2VyQ29uZmlnXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlNpbmdsZVRyaWdnZXJQYXJhbS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VkRGF0YS50cmlnZ2VyTmFtZSAmJiAhcGFyc2VkRGF0YS50cmlnZ2VySWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUcmlnZ2VyIG5hbWUgb3IgdHJpZ2dlciBpZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUcmlnZ2VyIG5hbWUgb3IgdHJpZ2dlciBpZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGVpdGhlciB0cmlnZ2VyTmFtZSBvciB0cmlnZ2VySWRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5nZXRUcmlnZ2VySW5mb1YyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5hbWU6IHBhcnNlZERhdGEudHJpZ2dlck5hbWUgfHwgcGFyc2VkRGF0YS50cmlnZ2VySWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCYWQgdHlwZSBpbmZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJJbmZvID0gcmVzLmRhdGE7XG4gICAgICAgICAgICBpZiAoIXRyaWdnZXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELk5PVF9GT1VORCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRyaWdnZXIgaW5mbyBub3QgZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBpbmZvIG5vdCBmb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGEgY2hlY2sgaWYgdHJpZ2dlciBleGlzdHNcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGNvbmZpZzogdHJpZ2dlckluZm8uY29uZmlnIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHNpbmdsZSB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VyU2luZ2xlUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpbmdsZVRyaWdnZXJSZXM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHJpZ2dlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmlnZ2VySW5mbyhkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0VHJpZ2dlckluZm9cIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBaU2luZ2xlVHJpZ2dlclBhcmFtLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLmdldFRyaWdnZXJJbmZvVjIoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyTmFtZTogcGFyc2VkRGF0YS50cmlnZ2VyTmFtZSB8fCBwYXJzZWREYXRhLnRyaWdnZXJJZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEJhZCB0eXBlIGluZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgdHJpZ2dlciA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELk5PVF9GT1VORCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRyaWdnZXIgaW5mbyBub3QgZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBpbmZvIG5vdCBmb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGEgY2hlY2sgaWYgdHJpZ2dlciBleGlzdHNcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhIHRyaWdnZXIgZm9yIGEgY29ubmVjdGVkIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NldHVwVHJpZ2dlckRhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNldHVwVHJpZ2dlclJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNldHVwIHRyaWdnZXIgcmVzcG9uc2UuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgc2V0dXAocGFyYW1zKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwic2V0dXBcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlRyaWdnZXJTZXR1cFBhcmFtLnBhcnNlKHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5lbmFibGVUcmlnZ2VyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBwYXJzZWREYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5hbWU6IHBhcnNlZERhdGEudHJpZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDb25maWc6IHBhcnNlZERhdGEuY29uZmlnIHx8IHt9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHRyaWdnZXJJZCwgc3RhdHVzIH0gPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VySWQ6IHRyaWdnZXJJZCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTmFtZTogcGFyc2VkRGF0YS50cmlnZ2VyTmFtZSxcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgICAgdHJpZ2dlckluc3RhbmNlSWQ6IHRyaWdnZXJJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgYSB0cmlnZ2VyIGZvciBhIGNvbm5lY3RlZCBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHt0cmlnZ2VySWQsdHJpZ2dlckluc3RhbmNlSWR9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGVuYWJsZSByZXF1ZXN0LlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGVuYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZW5hYmxlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFRyaWdnZXJJZCA9IGRhdGEudHJpZ2dlcklkIHx8IGRhdGEudHJpZ2dlckluc3RhbmNlSWQ7XG4gICAgICAgICAgICBpZiAoIWZpbmFsVHJpZ2dlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVHJpZ2dlciBJRCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUcmlnZ2VyIElEIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBhc3MgZWl0aGVyIHRyaWdnZXJJZCBvciB0cmlnZ2VySW5zdGFuY2VJZFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLnN3aXRjaFRyaWdnZXJJbnN0YW5jZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJJZDogZmluYWxUcmlnZ2VySWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYSB0cmlnZ2VyIGZvciBhIGNvbm5lY3RlZCBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHt0cmlnZ2VySWQsdHJpZ2dlckluc3RhbmNlSWR9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGRpc2FibGUgcmVxdWVzdC5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkaXNhYmxlKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJkaXNhYmxlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFRyaWdnZXJJZCA9IGRhdGEudHJpZ2dlcklkIHx8IGRhdGEudHJpZ2dlckluc3RhbmNlSWQ7XG4gICAgICAgICAgICBpZiAoIWZpbmFsVHJpZ2dlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVHJpZ2dlciBJRCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUcmlnZ2VyIElEIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBhc3MgZWl0aGVyIHRyaWdnZXJJZCBvciB0cmlnZ2VySW5zdGFuY2VJZFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLnN3aXRjaFRyaWdnZXJJbnN0YW5jZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJJZDogZmluYWxUcmlnZ2VySWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSB0cmlnZ2VyIGZvciBhIGNvbm5lY3RlZCBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VySW5zdGFuY2VJdGVtc30gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBvZiB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJkZWxldGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBaVHJpZ2dlckluc3RhbmNlSXRlbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuZGVsZXRlVHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJJbnN0YW5jZUlkOiBwYXJzZWREYXRhLnRyaWdnZXJJbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZShmbiwgZmlsdGVycyA9IHt9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwic3Vic2NyaWJlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGZpbHRlcnMgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZm4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyByZXF1aXJlZCBmb3IgdHJpZ2dlciBzdWJzY3JpcHRpb25cIik7XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gYXdhaXQgdGhpcy5iYWNrZW5kQ2xpZW50LmdldENsaWVudElkKCk7XG4gICAgICAgIGF3YWl0IFB1c2hlclV0aWxzLmdldFB1c2hlckNsaWVudCh0aGlzLmJhY2tlbmRDbGllbnQuYmFzZVVybCwgdGhpcy5iYWNrZW5kQ2xpZW50LmFwaUtleSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFNlbmRUcmlnZ2VyID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJzKS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCghZmlsdGVycy5hcHBOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYXBwTmFtZS50b0xvd2VyQ2FzZSgpID09PSBmaWx0ZXJzLmFwcE5hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmaWx0ZXJzLnRyaWdnZXJJZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tZXRhZGF0YS5pZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMudHJpZ2dlcklkLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICghZmlsdGVycy5jb25uZWN0aW9uSWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubWV0YWRhdGEuY29ubmVjdGlvbklkLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5jb25uZWN0aW9uSWQudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmaWx0ZXJzLnRyaWdnZXJOYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1ldGFkYXRhLnRyaWdnZXJOYW1lLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycy50cmlnZ2VyTmFtZS50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZpbHRlcnMuZW50aXR5SWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubWV0YWRhdGEuY29ubmVjdGlvbi5jbGllbnRVbmlxdWVVc2VySWQudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLmVudGl0eUlkLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICghZmlsdGVycy5pbnRlZ3JhdGlvbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1ldGFkYXRhLmNvbm5lY3Rpb24uaW50ZWdyYXRpb25JZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMuaW50ZWdyYXRpb25JZC50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlN1YnNjcmliaW5nIHRvIHRyaWdnZXJzXCIsIGZpbHRlcnMpO1xuICAgICAgICBQdXNoZXJVdGlscy50cmlnZ2VyU3Vic2NyaWJlKGNsaWVudElkLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNlbmRUcmlnZ2VyKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZm4oZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSBhd2FpdCB0aGlzLmJhY2tlbmRDbGllbnQuZ2V0Q2xpZW50SWQoKTtcbiAgICAgICAgUHVzaGVyVXRpbHMudHJpZ2dlclVuc3Vic2NyaWJlKGNsaWVudElkKTtcbiAgICB9XG59XG5cbmNvbnN0IExBQkVMUyA9IHtcbiAgICBQUklNQVJZOiBcInByaW1hcnlcIixcbn07XG5jbGFzcyBFbnRpdHkge1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGlkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL3Nkay9tb2RlbHMvRW50aXR5LnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50cmlnZ2VyTW9kZWwgPSBuZXcgVHJpZ2dlcnModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmFjdGlvbnNNb2RlbCA9IG5ldyBBY3Rpb25zKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hcHBzID0gbmV3IEFwcHModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFjY291bnRzID0gbmV3IENvbm5lY3RlZEFjY291bnRzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5pbnRlZ3JhdGlvbnMgPSBuZXcgSW50ZWdyYXRpb25zKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUcmlnZ2VycyA9IG5ldyBBY3RpdmVUcmlnZ2Vycyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGFuIGFjdGlvbiBmb3IgYW4gZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGFjdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHBhcmFtcyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBwYXNzIHRvIHRoZSBhY3Rpb24uIFRoaXMgY2FuIGJlIHRvIHBlcmZvcm0gTkxBIGV4ZWN1dGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25uZWN0ZWRBY2NvdW50SWQgVGhlIElEIG9mIHRoZSBjb25uZWN0ZWQgYWNjb3VudCB0byB1c2UgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aW9uRXhlY3V0ZVJlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIGZyb20gdGhlIGFjdGlvbiBleGVjdXRpb24uXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZSh7IGFjdGlvbk5hbWUsIHBhcmFtcywgdGV4dCwgY29ubmVjdGVkQWNjb3VudElkLCB9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXhlY3V0ZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBhY3Rpb25OYW1lLCBwYXJhbXMsIHRleHQsIGNvbm5lY3RlZEFjY291bnRJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpFeGVjdXRlQWN0aW9uUGFyYW1zJDEucGFyc2Uoe1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBhd2FpdCB0aGlzLmFjdGlvbnNNb2RlbC5nZXQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhY3Rpb246ICR7YWN0aW9uTmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwcCA9IGF3YWl0IHRoaXMuYXBwcy5nZXQoe1xuICAgICAgICAgICAgICAgIGFwcEtleTogYWN0aW9uLmFwcEtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFwcC5ub19hdXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uc01vZGVsLmV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IGFjdGlvbi5hcHBLZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBhcHA6IGFjdGlvbi5hcHBLZXksXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3RlZEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLlNESy5OT19DT05ORUNURURfQUNDT1VOVF9GT1VORCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0aW9uIHdpdGggYXBwPScke2FjdGlvbi5hcHBLZXl9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0aW9uIHdpdGggYXBwPScke2FjdGlvbi5hcHBLZXl9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb25zTW9kZWwuZXhlY3V0ZSh7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keToge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGVkQWNjb3VudCA9PT0gbnVsbCB8fCBjb25uZWN0ZWRBY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0ZWRBY2NvdW50LmlkLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBhY3Rpb24uYXBwS2V5LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZmV0Y2ggdGhlIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgYnkgcHJvdmlkaW5nIGl0cyB1bmlxdWUga2V5IGFuZCB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb25uZWN0aW9uUGFyYW1zfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBhcHAncyB1bmlxdWUga2V5IGFuZCB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVpcmVkUGFyYW1zUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3IgdGhlIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25uZWN0aW9uKHsgYXBwLCBhcHBOYW1lLCBjb25uZWN0ZWRBY2NvdW50SWQgfSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldENvbm5lY3Rpb25cIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgYXBwLCBhcHBOYW1lLCBjb25uZWN0ZWRBY2NvdW50SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEFwcCA9IGFwcE5hbWUgfHwgYXBwO1xuICAgICAgICAgICAgWkNvbm5lY3Rpb25QYXJhbXMucGFyc2UoeyBhcHA6IGZpbmFsQXBwLCBjb25uZWN0ZWRBY2NvdW50SWQgfSk7XG4gICAgICAgICAgICBpZiAoIWZpbmFsQXBwICYmICFjb25uZWN0ZWRBY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBcHAgb3IgY29ubmVjdGVkQWNjb3VudElkIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFwcCBvciBjb25uZWN0ZWRBY2NvdW50SWQgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWRBY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25uZWN0ZWRBY2NvdW50cy5nZXQoe1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGF0ZXN0QWNjb3VudCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbGF0ZXN0Q3JlYXRpb25EYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRzID0gYXdhaXQgdGhpcy5jb25uZWN0ZWRBY2NvdW50cy5saXN0KHtcbiAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBjb25uZWN0ZWRBY2NvdW50cy5pdGVtcykge1xuICAgICAgICAgICAgICAgIGlmICgoYWNjb3VudCA9PT0gbnVsbCB8fCBhY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY2NvdW50LmxhYmVscykgJiYgKGFjY291bnQgPT09IG51bGwgfHwgYWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWNjb3VudC5sYWJlbHMuaW5jbHVkZXMoTEFCRUxTLlBSSU1BUlkpKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXRlc3RBY2NvdW50ID0gYWNjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXRlc3RBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb25uZWN0ZWRBY2NvdW50IG9mIGNvbm5lY3RlZEFjY291bnRzLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoZmluYWxBcHAgPT09IG51bGwgfHwgZmluYWxBcHAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbmFsQXBwLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudC5hcHBOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyZWF0aW9uRGF0ZSA9IG5ldyBEYXRlKGNvbm5lY3RlZEFjY291bnQuY3JlYXRlZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWxhdGVzdEFjY291bnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobGF0ZXN0Q3JlYXRpb25EYXRlICYmIGNyZWF0aW9uRGF0ZSA+IGxhdGVzdENyZWF0aW9uRGF0ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudC5zdGF0dXMgPT09IFwiQUNUSVZFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RDcmVhdGlvbkRhdGUgPSBjcmVhdGlvbkRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0QWNjb3VudCA9IGNvbm5lY3RlZEFjY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhdGVzdEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLlNESy5OT19DT05ORUNURURfQUNDT1VOVF9GT1VORCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0aW9uIHdpdGggYXBwPScke2ZpbmFsQXBwfScgYW5kIGVudGl0eT0nJHt0aGlzLmlkfSdgLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHtmaW5hbEFwcH0nIGFuZCBlbnRpdHk9JyR7dGhpcy5pZH0nYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnQgPSBhd2FpdCB0aGlzLmNvbm5lY3RlZEFjY291bnRzLmdldCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBsYXRlc3RBY2NvdW50LmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3RlZEFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLlNESy5OT19DT05ORUNURURfQUNDT1VOVF9GT1VORCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0aW9uIHdpdGggYXBwPScke2ZpbmFsQXBwfScgYW5kIGVudGl0eT0nJHt0aGlzLmlkfSdgLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHtmaW5hbEFwcH0nIGFuZCBlbnRpdHk9JyR7dGhpcy5pZH0nYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0ZWRBY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgYXV0aGVudGljYXRpb24gc2NoZW1lIG9mIGFuIGFwcCBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBzZXR1cCBhIHRyaWdnZXIgZm9yIGFuIGFwcCBieSBwcm92aWRpbmcgaXRzIHVuaXF1ZSBrZXkgYW5kIHRoZSB0cmlnZ2VyIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyaWdnZXJTdWJzY3JpYmVQYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QsIGluY2x1ZGluZyB0aGUgYXBwJ3MgdW5pcXVlIGtleSBhbmQgdGhlIHRyaWdnZXIgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1aXJlZFBhcmFtc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgc2V0dXBUcmlnZ2VyKHsgYXBwLCBhcHBOYW1lLCB0cmlnZ2VyTmFtZSwgY29uZmlnLCB9KSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwic2V0dXBUcmlnZ2VyXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGFwcCwgYXBwTmFtZSwgdHJpZ2dlck5hbWUsIGNvbmZpZyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQXBwID0gYXBwTmFtZSB8fCBhcHA7XG4gICAgICAgICAgICBaVHJpZ2dlclN1YnNjcmliZVBhcmFtLnBhcnNlKHsgYXBwOiBmaW5hbEFwcCwgdHJpZ2dlck5hbWUsIGNvbmZpZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnQgPSBhd2FpdCB0aGlzLmdldENvbm5lY3Rpb24oeyBhcHA6IGZpbmFsQXBwIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5TREsuTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHtmaW5hbEFwcH0nIGFuZCBlbnRpdHk9JyR7dGhpcy5pZH0nYCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDb3VsZCBub3QgZmluZCBhIGNvbm5lY3Rpb24gd2l0aCBhcHA9JyR7ZmluYWxBcHB9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VyID0gYXdhaXQgdGhpcy50cmlnZ2VyTW9kZWwuc2V0dXAoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGVkQWNjb3VudC5pZCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIGEgc3BlY2lmaWMgYXV0aGVudGljYXRpb24gc2NoZW1lIG9mIGFuIGFwcCBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBkaXNhYmxlIGEgdHJpZ2dlciBieSBwcm92aWRpbmcgaXRzIHRyaWdnZXIgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJpZ2dlcklkIFRoZSBJRCBvZiB0aGUgdHJpZ2dlciB0byBkaXNhYmxlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgc3RhdHVzOiBzdHJpbmcgfT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0dXMgb2YgdGhlIHRyaWdnZXIgZGlzYWJsZW1lbnQuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZVRyaWdnZXIodHJpZ2dlcklkKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGlzYWJsZVRyaWdnZXJcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgdHJpZ2dlcklkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hY3RpdmVUcmlnZ2Vycy5kaXNhYmxlKHsgdHJpZ2dlcklkOiB0cmlnZ2VySWQgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwic3VjY2Vzc1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgY29ubmVjdGlvbnMgZm9yIGFuIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb25JdGVtW10+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBjb25uZWN0aW9uIGl0ZW1zLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENvbm5lY3Rpb25zKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFsbCBjb25uZWN0aW9ucyBmb3IgYW4gZW50aXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb25uZWN0aW9uc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmNvbm5lY3RlZEFjY291bnRzLmxpc3Qoe1xuICAgICAgICAgICAgICAgIHVzZXJfdXVpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RlZEFjY291bnRzLml0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGFjdGl2ZSB0cmlnZ2VycyBmb3IgYW4gZW50aXR5LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aXZlVHJpZ2dlcltdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYWN0aXZlIHRyaWdnZXJzLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjdGl2ZVRyaWdnZXJzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFsbCBhY3RpdmUgdHJpZ2dlcnMgZm9yIGFuIGVudGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0QWN0aXZlVHJpZ2dlcnNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0aW9ucygpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVHJpZ2dlcnMgPSBhd2FpdCB0aGlzLmFjdGl2ZVRyaWdnZXJzLmxpc3Qoe1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWRzOiBjb25uZWN0ZWRBY2NvdW50c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChhY2NvdW50KSA9PiBhY2NvdW50LmlkKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIixcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVUcmlnZ2VycztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgYSBjb25uZWN0aW9uIGZvciBhbiBlbnRpdHkuXG4gICAgICogQHBhcmFtIHtJbml0aWF0ZUNvbm5lY3Rpb25QYXJhbXN9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LCBpbmNsdWRpbmcgdGhlIGFwcCdzIHVuaXF1ZSBrZXkgYW5kIHRoZSBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvblJlcXVlc3Q+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY29ubmVjdGlvbiByZXF1ZXN0LlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYXRlQ29ubmVjdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiaW5pdGlhdGVDb25uZWN0aW9uXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGFwcE5hbWUsIGF1dGhNb2RlLCBhdXRoQ29uZmlnLCBpbnRlZ3JhdGlvbklkLCBjb25uZWN0aW9uUGFyYW1zLCByZWRpcmVjdFVyaSwgbGFiZWxzLCB9ID0gWkluaXRpYXRlQ29ubmVjdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIC8vIEluaXRpYXRlIHRoZSBjb25uZWN0aW9uIHByb2Nlc3NcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RlZEFjY291bnRzLmluaXRpYXRlKHtcbiAgICAgICAgICAgICAgICBhdXRoTW9kZTogYXV0aE1vZGUsXG4gICAgICAgICAgICAgICAgYXV0aENvbmZpZzogYXV0aENvbmZpZyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBpbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgICAgIGFwcE5hbWU6IGFwcE5hbWUsXG4gICAgICAgICAgICAgICAgZW50aXR5SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IHJlZGlyZWN0VXJpIHx8ICgoX2EgPSBkYXRhLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VXJsKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25QYXJhbXM6IGNvbm5lY3Rpb25QYXJhbXMsXG4gICAgICAgICAgICAgICAgbGFiZWxzOiBsYWJlbHMgfHwgKChfYiA9IGRhdGEuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGFiZWxzKSB8fCBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgcmVtb3ZlVHJhaWxpbmdTbGFzaElmRXhpc3RzID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL1xcLyskLywgXCJcIik7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBkZXRhaWxzIHJlcXVpcmVkIHRvIGluaXRpYWxpemUgYW5kIGNvbmZpZ3VyZSB0aGUgQVBJIGNsaWVudC5cbiAqL1xuY2xhc3MgQXhpb3NCYWNrZW5kQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFwaUNsaWVudERldGFpbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFwaUtleSAtIFRoZSBBUEkga2V5IGZvciBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVcmwgLSBUaGUgYmFzZSBVUkwgZm9yIHRoZSBBUEkgY2xpZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydW50aW1lIC0gVGhlIHJ1bnRpbWUgZW52aXJvbm1lbnQgaWRlbnRpZmllci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIEFQSSBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFwaUtleSwgYmFzZVVybCwgcnVudGltZSkge1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSByZW1vdmVUcmFpbGluZ1NsYXNoSWZFeGlzdHMoYmFzZVVybCk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjbGllbnRBeGlvcy5jcmVhdGVDbGllbnQoY2xpZW50QXhpb3MuY3JlYXRlQ29uZmlnKHtcbiAgICAgICAgICAgIGJhc2VVUkw6IHRoaXMuYmFzZVVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb246IHtcbiAgICAgICAgICAgICAgICBcIlgtQVBJLUtFWVwiOiBgJHt0aGlzLmFwaUtleX1gLFxuICAgICAgICAgICAgICAgIFwiWC1TT1VSQ0VcIjogXCJqc19zZGtcIixcbiAgICAgICAgICAgICAgICBcIlgtUlVOVElNRVwiOiB0aGlzLnJ1bnRpbWUsXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQVBJX0tFWV9VTkFWQUlMQUJMRSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQVBJIGtleSBpcyBub3QgYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIEFQSSBrZXkgcmVxdWlyZWQgZm9yIGF1dGhlbnRpY2F0aW9uIGlzIG5vdCBwcm92aWRlZC4gWW91IGNhbiBnZXQgdGhlIEFQSSBrZXkgZnJvbSB0aGUgQ29tcG9zaW8gZGFzaGJvYXJkLlwiLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSBwcm92aWRlIHRoZSBBUEkga2V5IGluIHRoZSBjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFsaWRhdGUgYmFzZVVybFxuICAgICAgICBpZiAoIWJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgJiYgIWJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5CQVNFX1VSTF9OT1RfUkVBQ0hBQkxFLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYPCflJcgQmFzZSBVUkwgJHtiYXNlVXJsfSBpcyBub3QgdmFsaWRgLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBjb21wb3NpbyBiYWNrZW5kIFVSTCBwcm92aWRlZCBpcyBub3QgdmFsaWRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFwaUNsaWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNsaWVudCBJRCBmcm9tIHRoZSB1c2VyJ3MgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNsaWVudCBJRC5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIEhUVFAgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGllbnRJZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGlDbGllbnQuY2xpZW50QXV0aC5nZXRVc2VySW5mbyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jbGllbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFQSSBjbGllbnQgd2l0aCB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVBcGlDbGllbnQoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0Q29uZmlnKHtcbiAgICAgICAgICAgIGJhc2VVUkw6IHJlbW92ZVRyYWlsaW5nU2xhc2hJZkV4aXN0cyh0aGlzLmJhc2VVcmwpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICBcIlgtQVBJLUtFWVwiOiBgJHt0aGlzLmFwaUtleX1gLFxuICAgICAgICAgICAgICAgICAgICBcIlgtU09VUkNFXCI6IFwianNfc2RrXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiWC1SVU5USU1FXCI6IHRoaXMucnVudGltZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldEF4aW9zQ2xpZW50Q29uZmlnKHRoaXMuaW5zdGFuY2UuaW5zdGFuY2UpO1xuICAgIH1cbiAgICBnZXRBeGlvc0luc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5pbnN0YW5jZTtcbiAgICB9XG59XG5cbi8vIEZpbGUgcGF0aCBoZWxwZXJzXG5jb25zdCB1c2VyRGF0YVBhdGggPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICAgICAgcmV0dXJuIHBhdGguam9pbihvcy5ob21lZGlyKCksIENPTVBPU0lPX0RJUiwgVVNFUl9EQVRBX0ZJTEVfTkFNRSk7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmNvbnN0IGdldFVzZXJEYXRhSnNvbiA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh1c2VyRGF0YVBhdGgoKSwgXCJ1dGY4XCIpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcbi8vIEF4aW9zIGNvbmZpZ3VyYXRpb25cbmNvbnN0IHNldEF4aW9zQ2xpZW50Q29uZmlnID0gKGF4aW9zQ2xpZW50SW5zdGFuY2UpID0+IHtcbiAgICBheGlvc0NsaWVudEluc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZSgocmVxdWVzdCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJvZHkgPSByZXF1ZXN0LmRhdGEgPyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmRhdGEpIDogXCJcIjtcbiAgICAgICAgLy8gc2V0IHgtcmVxdWVzdC1pZCBoZWFkZXJcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gZ2V0VVVJRCgpO1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbXCJ4LXJlcXVlc3QtaWRcIl0gPSByZXF1ZXN0SWQ7XG4gICAgICAgIHJlcXVlc3QubWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIFJlcSBbJHsoX2EgPSByZXF1ZXN0Lm1ldGhvZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvVXBwZXJDYXNlKCl9XSAke3JlcXVlc3QudXJsfSwgeC1yZXF1ZXN0LWlkOiAke3JlcXVlc3RJZH1gLCB7XG4gICAgICAgICAgICAuLi4oYm9keSAmJiB7IGJvZHkgfSksXG4gICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5wYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9KTtcbiAgICBheGlvc0NsaWVudEluc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXRob2QgPSAoX2EgPSByZXNwb25zZS5jb25maWcubWV0aG9kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VTaXplID0gTWF0aC5yb3VuZChKU09OLnN0cmluZ2lmeShyZXNwb25zZS5kYXRhKS5sZW5ndGggLyAxMDI0KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0YXJ0VGltZSA9IChfYiA9IHJlc3BvbnNlLmNvbmZpZ1xuICAgICAgICAgICAgLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnRUaW1lO1xuICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSByZXF1ZXN0U3RhcnRUaW1lID8gRGF0ZS5ub3coKSAtIHJlcXVlc3RTdGFydFRpbWUgOiAwO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmhlYWRlcnNbXCJ4LXJlcXVlc3QtaWRcIl0gfHxcbiAgICAgICAgICAgICgoX2MgPSByZXNwb25zZS5jb25maWcubWV0YWRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZXF1ZXN0SWQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEVycm9yIHdpdGggbWV0YWRhdGEgdHlwZVxuICAgICAgICByZXNwb25zZVtcIm1ldGFkYXRhXCJdID0ge1xuICAgICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICAgICAgcmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoYEFQSSBSZXMgWyR7bWV0aG9kfV0gJHtyZXNwb25zZS5jb25maWcudXJsfSAtICR7c3RhdHVzfSAtICR7cmVzcG9uc2VTaXplfSBLQiAke3Jlc3BvbnNlVGltZX1tc2ApO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3A7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RTdGFydFRpbWUgPSAoX2IgPSAoX2EgPSBlcnJvci5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFN0YXJ0VGltZUlkID0gKF9kID0gKF9jID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWV0YWRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXF1ZXN0SWQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IHJlcXVlc3RTdGFydFRpbWUgPyBEYXRlLm5vdygpIC0gcmVxdWVzdFN0YXJ0VGltZSA6IDA7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9ICgoX2UgPSBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnN0YXR1cykgfHwgXCJVbmtub3duXCI7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9ICgoX2cgPSBKU09OLnN0cmluZ2lmeSgoX2YgPSBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmRhdGEpKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubGVuZ3RoKSB8fCAwO1xuICAgICAgICBjb25zdCByZXNwb25zZVNpemUgPSBNYXRoLnJvdW5kKGxlbmd0aCAvIDEwMjQpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSAoKF9qID0gKF9oID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2pbXCJ4LXJlcXVlc3QtaWRcIl0pIHx8IHJlcXVlc3RTdGFydFRpbWVJZDtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICByZXNwb25zZVRpbWUsXG4gICAgICAgICAgICByZXNwb25zZVNpemUsXG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRXJyb3Igd2l0aCBtZXRhZGF0YSB0eXBlXG4gICAgICAgIGVycm9yLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQVBJIEVycm9yIFske3N0YXR1c31dICR7KF9sID0gKF9rID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2subWV0aG9kKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wudG9VcHBlckNhc2UoKX0gJHsoX20gPSBlcnJvci5jb25maWcpID09PSBudWxsIHx8IF9tID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbS51cmx9IC0gJHtzdGF0dXN9IC0gJHtyZXNwb25zZVRpbWV9bXMsIHgtcmVxdWVzdC1pZDogJHtyZXF1ZXN0SWR9YCwge1xuICAgICAgICAgICAgaGVhZGVyczogKF9vID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby5oZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogKF9wID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC5kYXRhLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICByZXNwb25zZVRpbWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xufTtcbi8vIENsaWVudCBjb25maWd1cmF0aW9uIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0U0RLQ29uZmlnKGJhc2VVcmwsIGFwaUtleSkge1xuICAgIGNvbnN0IHVzZXJEYXRhID0gZ2V0VXNlckRhdGFKc29uKCk7XG4gICAgY29uc3QgeyBhcGlfa2V5OiBhcGlLZXlGcm9tVXNlckNvbmZpZywgYmFzZV91cmw6IGJhc2VVUkxGcm9tVXNlckNvbmZpZyB9ID0gdXNlckRhdGE7XG4gICAgY29uc3QgYmFzZVVSTFBhcnNlZCA9IGJhc2VVcmwgfHxcbiAgICAgICAgZ2V0RW52VmFyaWFibGUoXCJDT01QT1NJT19CQVNFX1VSTFwiKSB8fFxuICAgICAgICBiYXNlVVJMRnJvbVVzZXJDb25maWcgfHxcbiAgICAgICAgREVGQVVMVF9CQVNFX1VSTDtcbiAgICBjb25zdCBhcGlLZXlQYXJzZWQgPSBhcGlLZXkgfHwgZ2V0RW52VmFyaWFibGUoXCJDT01QT1NJT19BUElfS0VZXCIpIHx8IGFwaUtleUZyb21Vc2VyQ29uZmlnIHx8IFwiXCI7XG4gICAgcmV0dXJuIHsgYmFzZVVSTDogYmFzZVVSTFBhcnNlZCwgYXBpS2V5OiBhcGlLZXlQYXJzZWQgfTtcbn1cblxuY29uc3QgaXNOZXdlclZlcnNpb24gPSAodjEsIHYyKSA9PiB7XG4gICAgY29uc3QgcGFydHMxID0gdjEuc3BsaXQoXCIuXCIpLm1hcChOdW1iZXIpO1xuICAgIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBpZiAocGFydHMxW2ldID4gcGFydHMyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChwYXJ0czFbaV0gPCBwYXJ0czJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNsYXNzIENvbXBvc2lvIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29tcG9zaW8gY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBDb21wb3NpbyBTREtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5hcGlLZXldIC0gVGhlIEFQSSBrZXkgZm9yIGF1dGhlbnRpY2F0aW5nIHdpdGggdGhlIENvbXBvc2lvIGJhY2tlbmQuIENhbiBhbHNvIGJlIHNldCBsb2NhbGx5IGluIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmJhc2VVcmxdIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgQ29tcG9zaW8gYmFja2VuZC4gQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIHRoZSBwcm9kdWN0aW9uIFVSTC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5ydW50aW1lXSAtIFRoZSBydW50aW1lIGVudmlyb25tZW50IGZvciB0aGUgU0RLLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5hbGxvd1RyYWNpbmddIC0gV2hldGhlciB0byBhbGxvdyB0cmFjaW5nIGZvciB0aGUgU0RLLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvaW5kZXgudHNcIjtcbiAgICAgICAgLy8gUGFyc2UgdGhlIGJhc2UgVVJMIGFuZCBBUEkga2V5LCBmYWxsaW5nIGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIGRlZmF1bHRzIGlmIG5vdCBwcm92aWRlZFxuICAgICAgICBjb25zdCB7IGJhc2VVUkw6IGJhc2VVUkxQYXJzZWQsIGFwaUtleTogYXBpS2V5UGFyc2VkIH0gPSBnZXRTREtDb25maWcoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmwsIGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hcGlLZXkpO1xuICAgICAgICBpZiAoSVNfREVWRUxPUE1FTlRfT1JfQ0kpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBJbml0aWFsaXppbmcgQ29tcG9zaW8gdyBBUEkgS2V5OiBbUkVEQUNURURdIGFuZCBiYXNlVVJMOiAke2Jhc2VVUkxQYXJzZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LmFwaUtleSA9IGFwaUtleVBhcnNlZDtcbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LmJhc2VVUkwgPSBiYXNlVVJMUGFyc2VkO1xuICAgICAgICBDb21wb3Npb1NES0NvbnRleHQuZnJhbWV3b3JrUnVudGltZSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5ydW50aW1lO1xuICAgICAgICBDb21wb3Npb1NES0NvbnRleHQuY29tcG9zaW9WZXJzaW9uID0gQ09NUE9TSU9fVkVSU0lPTjtcbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LmFsbG93VHJhY2luZyA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hbGxvd1RyYWNpbmc7XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIGdlbmVyYXRlIGEgc2Vzc2lvbklkIHVubGVzcyBhbGxvd1RyYWNpbmcgaXMgZXhwbGljaXRseSBzZXQgdG8gZmFsc2VcbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LnNlc3Npb25JZCA9XG4gICAgICAgICAgICAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmFsbG93VHJhY2luZykgIT09IGZhbHNlID8gZ2V0VVVJRCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19JTklUSUFMSVpFRCwge30pO1xuICAgICAgICBpZiAoIWFwaUtleVBhcnNlZCkge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQVBJX0tFWV9VTkFWQUlMQUJMRSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwi8J+UkSBBUEkgS2V5IGlzIG5vdCBwcm92aWRlZFwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIllvdSBuZWVkIHRvIHByb3ZpZGUgaXQgaW4gdGhlIGNvbnN0cnVjdG9yIG9yIGFzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlIENPTVBPU0lPX0FQSV9LRVlcIixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEFQSSBLZXkuIFlvdSBjYW4gZ2V0IGl0IGZyb20gaHR0cHM6Ly9hcHAuY29tcG9zaW8uZGV2L3NldHRpbmdzIE9SIENoZWNrIGlmIHlvdSBhcmUgcGFzc2luZyBpdCBhcyBhbiBvYmplY3QgaW4gdGhlIGNvbnN0cnVjdG9yIGxpa2UgLSB7IGFwaUtleTogJ3lvdXItYXBpLWtleScgfVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYEluaXRpYWxpemluZyBDb21wb3NpbyB3IEFQSSBLZXk6IFtSRURBQ1RFRF0gYW5kIGJhc2VVUkw6ICR7YmFzZVVSTFBhcnNlZH1gKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgQmFja2VuZENsaWVudCB3aXRoIHRoZSBwYXJzZWQgQVBJIGtleSBhbmQgYmFzZSBVUkwuXG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IG5ldyBBeGlvc0JhY2tlbmRDbGllbnQoYXBpS2V5UGFyc2VkLCBiYXNlVVJMUGFyc2VkLCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucnVudGltZSk7XG4gICAgICAgIHNldEF4aW9zQ2xpZW50Q29uZmlnKHRoaXMuYmFja2VuZENsaWVudC5nZXRBeGlvc0luc3RhbmNlKCkpO1xuICAgICAgICAvLyBJbnN0YW50aWF0ZSBtb2RlbHMgd2l0aCBkZXBlbmRlbmNpZXMgYXMgbmVlZGVkLlxuICAgICAgICB0aGlzLmNvbm5lY3RlZEFjY291bnRzID0gbmV3IENvbm5lY3RlZEFjY291bnRzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy50cmlnZ2VycyA9IG5ldyBUcmlnZ2Vycyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYXBwcyA9IG5ldyBBcHBzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbmV3IEFjdGlvbnModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmludGVncmF0aW9ucyA9IG5ldyBJbnRlZ3JhdGlvbnModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmFjdGl2ZVRyaWdnZXJzID0gbmV3IEFjdGl2ZVRyaWdnZXJzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5jaGVja0ZvckxhdGVzdFZlcnNpb25Gcm9tTlBNKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBDb21wb3NpbyBTREsgZnJvbSBOUE0uXG4gICAgICogSWYgYSBuZXdlciB2ZXJzaW9uIGlzIGF2YWlsYWJsZSwgaXQgbG9ncyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUuXG4gICAgICovXG4gICAgYXN5bmMgY2hlY2tGb3JMYXRlc3RWZXJzaW9uRnJvbU5QTSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gXCJjb21wb3Npby1jb3JlXCI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbkZyb21QYWNrYWdlSnNvbiA9IENPTVBPU0lPX1ZFUlNJT047XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvJHtwYWNrYWdlTmFtZX0vbGF0ZXN0YCk7XG4gICAgICAgICAgICBjb25zdCBsYXRlc3RWZXJzaW9uID0gcmVzcG9uc2UuZGF0YS52ZXJzaW9uO1xuICAgICAgICAgICAgaWYgKGlzTmV3ZXJWZXJzaW9uKGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uRnJvbVBhY2thZ2VKc29uKSAmJlxuICAgICAgICAgICAgICAgICFJU19ERVZFTE9QTUVOVF9PUl9DSSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGDwn5qAIFVwZ3JhZGUgYXZhaWxhYmxlISBZb3VyIGNvbXBvc2lvLWNvcmUgdmVyc2lvbiAoJHtjdXJyZW50VmVyc2lvbkZyb21QYWNrYWdlSnNvbn0pIGlzIGJlaGluZC4gTGF0ZXN0IHZlcnNpb246ICR7bGF0ZXN0VmVyc2lvbn0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFuZCBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIEVudGl0eSBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbaWQ9J2RlZmF1bHQnXSAtIFRoZSBJRCBvZiB0aGUgZW50aXR5IHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtFbnRpdHl9IEFuIGluc3RhbmNlIG9mIHRoZSBFbnRpdHkgY2xhc3MuXG4gICAgICovXG4gICAgZ2V0RW50aXR5KGlkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRFbnRpdHlcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgaWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgRW50aXR5KHRoaXMuYmFja2VuZENsaWVudCwgaWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRFeHBlY3RlZFBhcmFtc0ZvclVzZXIocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2w7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0RXhwZWN0ZWRQYXJhbXNGb3JVc2VyXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGFwcCB9ID0gcGFyYW1zO1xuICAgICAgICBsZXQgeyBpbnRlZ3JhdGlvbklkIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpbnRlZ3JhdGlvbklkID09PSBudWxsICYmIGFwcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBgaW50ZWdyYXRpb25faWRgIGFuZCBgYXBwYCBjYW5ub3QgYmUgTm9uZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWludGVncmF0aW9uSWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZWdyYXRpb25zID0gYXdhaXQgdGhpcy5pbnRlZ3JhdGlvbnMubGlzdCh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWU6IGFwcCxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmF1dGhTY2hlbWUgJiYgaW50ZWdyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9ucy5pdGVtcyA9IGludGVncmF0aW9ucy5pdGVtcy5maWx0ZXIoKGludGVncmF0aW9uKSA9PiBpbnRlZ3JhdGlvbi5hdXRoU2NoZW1lID09PSBwYXJhbXMuYXV0aFNjaGVtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludGVncmF0aW9uSWQgPSAoX2EgPSBpbnRlZ3JhdGlvbnMgPT09IG51bGwgfHwgaW50ZWdyYXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlZ3JhdGlvbnMuaXRlbXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uSWRcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5pbnRlZ3JhdGlvbnMuZ2V0KHtcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBpbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaW50ZWdyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRJbnB1dEZpZWxkczogaW50ZWdyYXRpb24uZXhwZWN0ZWRJbnB1dEZpZWxkcyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBpbnRlZ3JhdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBhdXRoU2NoZW1lOiBpbnRlZ3JhdGlvbi5hdXRoU2NoZW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBJbmZvID0gYXdhaXQgdGhpcy5hcHBzLmdldCh7XG4gICAgICAgICAgICBhcHBLZXk6IGFwcC50b0xvY2FsZUxvd2VyQ2FzZSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlZmVycmVkQXV0aFNjaGVtZSA9IFtcbiAgICAgICAgICAgIFwiT0FVVEgyXCIsXG4gICAgICAgICAgICBcIk9BVVRIMVwiLFxuICAgICAgICAgICAgXCJBUElfS0VZXCIsXG4gICAgICAgICAgICBcIkJBU0lDXCIsXG4gICAgICAgICAgICBcIkJFQVJFUl9UT0tFTlwiLFxuICAgICAgICAgICAgXCJCQVNJQ19XSVRIX0pXVFwiLFxuICAgICAgICBdO1xuICAgICAgICBsZXQgc2NoZW1hID0gcGFyYW1zLmF1dGhTY2hlbWU7XG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtZSBvZiBwcmVmZXJyZWRBdXRoU2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYiA9IGFwcEluZm8uYXV0aF9zY2hlbWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChfYXV0aFNjaGVtZSkgPT4gX2F1dGhTY2hlbWUubW9kZSkuaW5jbHVkZXMoc2NoZW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNUZXN0Q29ubmVjdG9ycyA9ICgoX2QgPSAoX2MgPSBhcHBJbmZvLnRlc3RDb25uZWN0b3JzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwKSA+IDA7XG4gICAgICAgIGNvbnN0IGF1dGhTY2hlbWVGaWVsZHMgPSAoX2YgPSAoX2UgPSBhcHBJbmZvLmF1dGhfc2NoZW1lcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmZpbmQoKF9hdXRoU2NoZW1lKSA9PiBfYXV0aFNjaGVtZS5tb2RlID09PSBzY2hlbWEpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZmllbGRzO1xuICAgICAgICBjb25zdCByZXF1aXJlZEN1c3RvbWVyRmllbGRzID0gKF9oID0gKF9nID0gYXV0aFNjaGVtZUZpZWxkcyA9PT0gbnVsbCB8fCBhdXRoU2NoZW1lRmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoU2NoZW1lRmllbGRzLmZpbHRlcigoZmllbGQpID0+ICFmaWVsZC5leHBlY3RlZF9mcm9tX2N1c3RvbWVyKSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMDtcbiAgICAgICAgY29uc3QgYXJlTm9GaWVsZHNSZXF1aXJlZEZvckludGVncmF0aW9uID0gaGFzVGVzdENvbm5lY3RvcnMgfHwgcmVxdWlyZWRDdXN0b21lckZpZWxkcyA9PT0gMDtcbiAgICAgICAgaWYgKCFhcmVOb0ZpZWxkc1JlcXVpcmVkRm9ySW50ZWdyYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVmYXVsdCBjcmVkZW50aWFscyBhdmFpbGFibGUgZm9yIHRoaXMgYXBwLCBwbGVhc2UgY3JlYXRlIG5ldyBpbnRlZ3JhdGlvbiBieSBnb2luZyB0byBhcHAuY29tcG9zaW8uZGV2IG9yIHRocm91Z2ggQ0xJIC0gY29tcG9zaW8gYWRkICR7YXBwSW5mby5rZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1stOi5dL2csIFwiXCIpO1xuICAgICAgICBjb25zdCBoYXNSZWxldmFudFRlc3RDb25uZWN0b3JzID0gcGFyYW1zLmF1dGhTY2hlbWVcbiAgICAgICAgICAgID8gKChfayA9IChfaiA9IGFwcEluZm8udGVzdENvbm5lY3RvcnMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5maWx0ZXIoKGNvbm5lY3RvcikgPT4gY29ubmVjdG9yLmF1dGhTY2hlbWUgPT09IHBhcmFtcy5hdXRoU2NoZW1lKSkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmxlbmd0aCkgPiAwXG4gICAgICAgICAgICA6ICgoX2wgPSBhcHBJbmZvLnRlc3RDb25uZWN0b3JzKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wubGVuZ3RoKSA+IDA7XG4gICAgICAgIGlmIChoYXNSZWxldmFudFRlc3RDb25uZWN0b3JzKSB7XG4gICAgICAgICAgICBpbnRlZ3JhdGlvbiA9IGF3YWl0IHRoaXMuaW50ZWdyYXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYXBwSWQ6IGFwcEluZm8uYXBwSWQsXG4gICAgICAgICAgICAgICAgbmFtZTogYGludGVncmF0aW9uXyR7dGltZXN0YW1wfWAsXG4gICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogc2NoZW1hLFxuICAgICAgICAgICAgICAgIGF1dGhDb25maWc6IHt9LFxuICAgICAgICAgICAgICAgIHVzZUNvbXBvc2lvQXV0aDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZElucHV0RmllbGRzOiBpbnRlZ3JhdGlvbiA9PT0gbnVsbCB8fCBpbnRlZ3JhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZWdyYXRpb24uZXhwZWN0ZWRJbnB1dEZpZWxkcyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBpbnRlZ3JhdGlvbiA9PT0gbnVsbCB8fCBpbnRlZ3JhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZWdyYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogaW50ZWdyYXRpb24gPT09IG51bGwgfHwgaW50ZWdyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVncmF0aW9uLmF1dGhTY2hlbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1cHBvcnRlZCBhdXRoIHNjaGVtZSBmb3VuZCBmb3IgXFxgJHtTdHJpbmcoYXBwKX1cXGAsIGAgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIGNyZWF0ZSBhbiBpbnRlZ3JhdGlvbiBhbmQgdXNlIHRoZSBJRCB0byBcIiArXG4gICAgICAgICAgICAgICAgXCJnZXQgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGludGVncmF0aW9uID0gYXdhaXQgdGhpcy5pbnRlZ3JhdGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICAgIGFwcElkOiBhcHBJbmZvLmFwcElkLFxuICAgICAgICAgICAgbmFtZTogYGludGVncmF0aW9uXyR7dGltZXN0YW1wfWAsXG4gICAgICAgICAgICBhdXRoU2NoZW1lOiBzY2hlbWEsXG4gICAgICAgICAgICBhdXRoQ29uZmlnOiB7fSxcbiAgICAgICAgICAgIHVzZUNvbXBvc2lvQXV0aDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWludGVncmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBpbnRlZ3JhdGlvbiwgcGxlYXNlIGNyZWF0ZSBhbiBpbnRlZ3JhdGlvbiBtYW51YWxseSBhbmQgdXNlIGl0cyBJRCB0byBnZXQgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cGVjdGVkSW5wdXRGaWVsZHM6IGludGVncmF0aW9uLmV4cGVjdGVkSW5wdXRGaWVsZHMsXG4gICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBpbnRlZ3JhdGlvbi5pZCxcbiAgICAgICAgICAgIGF1dGhTY2hlbWU6IGludGVncmF0aW9uLmF1dGhTY2hlbWUsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKlxuICAgIFRoaXMgaXMgdGhlIHNjaGVtYSBmb3IgdGhlIHJhdyBhY3Rpb24gdG8gYmUgc3RvcmVkIGxvY2FsbHlcbiAgICBBbHNvIHJldHVybmVkIGJ5IHRoZSBBUElcbiovXG56Lnoub2JqZWN0KHtcbiAgICBuYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgZGlzcGxheV9uYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgZGVzY3JpcHRpb246IHouei5zdHJpbmcoKSxcbiAgICBhcHBLZXk6IHouei5zdHJpbmcoKSxcbiAgICBhcHBJZDogei56LnN0cmluZygpLFxuICAgIGFwcE5hbWU6IHouei5zdHJpbmcoKSxcbiAgICBsb2dvOiB6Lnouc3RyaW5nKCksXG4gICAgZW5hYmxlZDogei56LmJvb2xlYW4oKSxcbiAgICB0YWdzOiB6LnouYXJyYXkoei56LnN0cmluZygpKSxcbiAgICBwYXJhbWV0ZXJzOiB6Lnoub2JqZWN0KHtcbiAgICAgICAgdHlwZTogei56LnN0cmluZygpLFxuICAgICAgICB0aXRsZTogei56LnN0cmluZygpLFxuICAgICAgICBkZXNjcmlwdGlvbjogei56LnN0cmluZygpLFxuICAgICAgICByZXF1aXJlZDogei56LmFycmF5KHouei5zdHJpbmcoKSksXG4gICAgICAgIHByb3BlcnRpZXM6IHouei5yZWNvcmQoei56LmFueSgpKSxcbiAgICB9KSxcbiAgICByZXNwb25zZTogei56LnJlY29yZCh6LnouYW55KCkpLFxuICAgIG1ldGFkYXRhOiB6Lnoub2JqZWN0KHtcbiAgICAgICAgbmFtZTogei56LnN0cmluZygpLFxuICAgICAgICB0b29sTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgfSksXG59KTtcbi8qXG4gICAgVGhpcyBpcyB0aGUgc2NoZW1hIGZvciB0aGUgcGFyYW1zIG9iamVjdCBpbiB0aGUgRXhlY3V0ZUFjdGlvbiBmdW5jdGlvblxuKi9cbmNvbnN0IFpFeGVjdXRlQWN0aW9uUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgYWN0aW9uOiB6Lnouc3RyaW5nKCksXG4gICAgcGFyYW1zOiB6LnoucmVjb3JkKHouei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICBlbnRpdHlJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgbmxhVGV4dDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29ubmVjdGVkQWNjb3VudElkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBjb25maWc6IHouelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgbGFiZWxzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBaVG9vbFNjaGVtYUZpbHRlciA9IHouei5vYmplY3Qoe1xuICAgIGFjdGlvbnM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgYXBwczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB0YWdzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIHVzZUNhc2U6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHVzZUNhc2VMaW1pdDogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcblxuY2xhc3MgQWN0aW9uUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5jdXN0b21BY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVBY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgY2FsbGJhY2sgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5hY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwcm92aWRlIGFjdGlvbk5hbWUgZm9yIHRoaXMgYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnB1dFBhcmFtcykge1xuICAgICAgICAgICAgb3B0aW9ucy5pbnB1dFBhcmFtcyA9IHouei5vYmplY3Qoe30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMuaW5wdXRQYXJhbXM7XG4gICAgICAgIGNvbnN0IGFjdGlvbk5hbWUgPSBvcHRpb25zLmFjdGlvbk5hbWUgfHwgY2FsbGJhY2submFtZSB8fCBcIlwiO1xuICAgICAgICBjb25zdCBwYXJhbXNTY2hlbWEgPSAoYXdhaXQgem9kVG9Kc29uU2NoZW1hLnpvZFRvSnNvblNjaGVtYShwYXJhbXMsIHtcbiAgICAgICAgICAgIG5hbWU6IFwiaW5wdXRcIixcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBfcGFyYW1zID0gcGFyYW1zU2NoZW1hLmRlZmluaXRpb25zLmlucHV0LnByb3BlcnRpZXM7XG4gICAgICAgIGNvbnN0IGNvbXBvc2lvU2NoZW1hID0ge1xuICAgICAgICAgICAgbmFtZTogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIHRpdGxlOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHBhcmFtc1NjaGVtYS5kZWZpbml0aW9ucy5pbnB1dC5yZXF1aXJlZCB8fCBbXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfcGFyYW1zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJSZXNwb25zZSBmb3IgXCIgKyBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jdXN0b21BY3Rpb25zLnNldCgoKF9hID0gb3B0aW9ucy5hY3Rpb25OYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb2NhbGVMb3dlckNhc2UoKSkgfHwgXCJcIiwge1xuICAgICAgICAgICAgbWV0YWRhdGE6IG9wdGlvbnMsXG4gICAgICAgICAgICBzY2hlbWE6IGNvbXBvc2lvU2NoZW1hLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2lvU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY3Rpb25zKHsgYWN0aW9ucywgfSkge1xuICAgICAgICBjb25zdCBhY3Rpb25zQXJyID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlckNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQWN0aW9ucy5oYXMobG93ZXJDYXNlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmN1c3RvbUFjdGlvbnMuZ2V0KGxvd2VyQ2FzZU5hbWUpO1xuICAgICAgICAgICAgICAgIGFjdGlvbnNBcnIucHVzaChhY3Rpb24uc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aW9uc0FycjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxsQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jdXN0b21BY3Rpb25zLnZhbHVlcygpKS5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLnNjaGVtYSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRvb2xOYW1lKHsgYWN0aW9uLCB9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWN0aW9uIG5hbWUgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJQbGVhc2UgcHJvdmlkZSBhbiBhY3Rpb24gbmFtZSB0byBnZXQgaXRzIHRvb2wgbmFtZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jdXN0b21BY3Rpb25zLmdldChsb3dlckNhc2VOYW1lKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGFkYXRhLnRvb2xOYW1lO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlQWN0aW9uKG5hbWUsIGlucHV0UGFyYW1zLCBtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBsb3dlckNhc2VOYW1lID0gbmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tQWN0aW9ucy5oYXMobG93ZXJDYXNlTmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uIHdpdGggbmFtZSAke25hbWV9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5jdXN0b21BY3Rpb25zLmdldChsb3dlckNhc2VOYW1lKTtcbiAgICAgICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0aW9uIHdpdGggbmFtZSAke25hbWV9IGNvdWxkIG5vdCBiZSByZXRyaWV2ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCB0b29sTmFtZSB9ID0gYWN0aW9uLm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICBsZXQgYXV0aENyZWRlbnRpYWxzID0ge307XG4gICAgICAgIGlmICh0b29sTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0RW50aXR5KG1ldGFkYXRhLmVudGl0eUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBlbnRpdHkuZ2V0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgYXBwOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IG1ldGFkYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25uZWN0aW9uIHdpdGggYXBwIG5hbWUgJHt0b29sTmFtZX0gYW5kIGVudGl0eUlkICR7bWV0YWRhdGEuZW50aXR5SWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvblBhcmFtcyA9IGNvbm5lY3Rpb24uY29ubmVjdGlvblBhcmFtcztcbiAgICAgICAgICAgIGF1dGhDcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBjb25uZWN0aW9uUGFyYW1zID09PSBudWxsIHx8IGNvbm5lY3Rpb25QYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb25QYXJhbXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogY29ubmVjdGlvblBhcmFtcyA9PT0gbnVsbCB8fCBjb25uZWN0aW9uUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uUGFyYW1zLnF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJhc2VVcmw6IChjb25uZWN0aW9uUGFyYW1zID09PSBudWxsIHx8IGNvbm5lY3Rpb25QYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb25QYXJhbXMuYmFzZVVybCkgfHwgKGNvbm5lY3Rpb25QYXJhbXMgPT09IG51bGwgfHwgY29ubmVjdGlvblBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvblBhcmFtcy5iYXNlX3VybCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VELCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRlUmVxdWVzdCA9IGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzIH0gPSBhd2FpdCBhcGlDbGllbnQuYWN0aW9uc1YyLmV4ZWN1dGVXaXRoSHR0cENsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQuYmFja2VuZENsaWVudC5pbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogbWV0YWRhdGEgPT09IG51bGwgfHwgbWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1ldGFkYXRhLmNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKGlucHV0UGFyYW1zLCBhdXRoQ3JlZGVudGlhbHMsIChkYXRhKSA9PiBleGVjdXRlUmVxdWVzdChkYXRhKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIENvbXBvc2lvIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBjcmVhdGVEaXJJZk5vdEV4aXN0cyAtIFdoZXRoZXIgdG8gY3JlYXRlIHRoZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqIEByZXR1cm5zIFRoZSBwYXRoIHRvIHRoZSBDb21wb3NpbyBkaXJlY3RvcnkuXG4gKi9cbmNvbnN0IGdldENvbXBvc2lvRGlyID0gKGNyZWF0ZURpcklmTm90RXhpc3RzID0gZmFsc2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgY29uc3QgY29tcG9zaW9EaXIgPSBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBDT01QT1NJT19ESVIpO1xuICAgICAgICBpZiAoY3JlYXRlRGlySWZOb3RFeGlzdHMgJiYgIWZzLmV4aXN0c1N5bmMoY29tcG9zaW9EaXIpKSB7XG4gICAgICAgICAgICBmcy5ta2RpclN5bmMoY29tcG9zaW9EaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb3Npb0RpcjtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBDb21wb3NpbyB0ZW1wb3JhcnkgZmlsZXMgZGlyZWN0b3J5LlxuICogQHBhcmFtIGNyZWF0ZURpcklmTm90RXhpc3RzIC0gV2hldGhlciB0byBjcmVhdGUgdGhlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICogQHJldHVybnMgVGhlIHBhdGggdG8gdGhlIENvbXBvc2lvIHRlbXBvcmFyeSBmaWxlcyBkaXJlY3RvcnkuXG4gKi9cbmNvbnN0IGdldENvbXBvc2lvVGVtcEZpbGVzRGlyID0gKGNyZWF0ZURpcklmTm90RXhpc3RzID0gZmFsc2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgY29uc3QgY29tcG9zaW9GaWxlc0RpciA9IHBhdGguam9pbihvcy5ob21lZGlyKCksIENPTVBPU0lPX0RJUiwgVEVNUF9GSUxFU19ESVJFQ1RPUllfTkFNRSk7XG4gICAgICAgIGlmIChjcmVhdGVEaXJJZk5vdEV4aXN0cyAmJiAhZnMuZXhpc3RzU3luYyhjb21wb3Npb0ZpbGVzRGlyKSkge1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKGNvbXBvc2lvRmlsZXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb3Npb0ZpbGVzRGlyO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG4vKipcbiAqIFNhdmVzIGEgZmlsZSB0byB0aGUgQ29tcG9zaW8gZGlyZWN0b3J5LlxuICogQHBhcmFtIGZpbGUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBzYXZlLlxuICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgY29udGVudCBvZiB0aGUgZmlsZSB0byBzYXZlLiBTaG91bGQgYmUgYSBzdHJpbmcuXG4gKiBAcGFyYW0gaXNUZW1wRmlsZSAtIFdoZXRoZXIgdGhlIGZpbGUgaXMgYSB0ZW1wb3JhcnkgZmlsZS5cbiAqIEByZXR1cm5zIFRoZSBwYXRoIHRvIHRoZSBzYXZlZCBmaWxlLlxuICovXG5jb25zdCBzYXZlRmlsZSA9IChmaWxlLCBjb250ZW50LCBpc1RlbXBGaWxlID0gZmFsc2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgICAgICBjb25zdCBjb21wb3Npb0ZpbGVzRGlyID0gaXNUZW1wRmlsZVxuICAgICAgICAgICAgPyBnZXRDb21wb3Npb1RlbXBGaWxlc0Rpcih0cnVlKVxuICAgICAgICAgICAgOiBnZXRDb21wb3Npb0Rpcih0cnVlKTtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oY29tcG9zaW9GaWxlc0RpciwgcGF0aC5iYXNlbmFtZShmaWxlKSk7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgY29udGVudCwgXCJ1dGY4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5jb25zdCByZWFkRmlsZUNvbnRlbnQgPSBhc3luYyAocGF0aCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKHBhdGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogY29udGVudC50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciByZWFkaW5nIGZpbGUgYXQgJHtwYXRofTogJHtlcnJvcn1gKTtcbiAgICB9XG59O1xuY29uc3QgcmVhZEZpbGVDb250ZW50RnJvbVVSTCA9IGFzeW5jIChwYXRoKSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQocGF0aCwge1xuICAgICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICB9KTtcbiAgICBjb25zdCBjb250ZW50ID0gQnVmZmVyLmZyb20ocmVzcG9uc2UuZGF0YSk7XG4gICAgY29uc3QgbWltZVR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogY29udGVudC50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgfTtcbn07XG5jb25zdCB1cGxvYWRGaWxlVG9TMyA9IGFzeW5jIChjb250ZW50LCBhY3Rpb25OYW1lLCBhcHBOYW1lLCBtaW1lVHlwZSwgY2xpZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1pbWVUeXBlLnNwbGl0KFwiL1wiKVsxXSB8fCBcImJpblwiO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFjdGlvbnNWMi5jcmVhdGVGaWxlVXBsb2FkVXJsKHtcbiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFwcDogYXBwTmFtZSxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBgJHthY3Rpb25OYW1lfV8ke0RhdGUubm93KCl9LiR7ZXh0ZW5zaW9ufWAsXG4gICAgICAgICAgICBtaW1ldHlwZTogbWltZVR5cGUsXG4gICAgICAgICAgICBtZDU6IGNyeXB0b1xuICAgICAgICAgICAgICAgIC5jcmVhdGVIYXNoKFwibWQ1XCIpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShjb250ZW50LCBcImJhc2U2NFwiKSlcbiAgICAgICAgICAgICAgICAuZGlnZXN0KFwiaGV4XCIpLFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICBmaWxlVHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgY29uc3Qgc2lnbmVkVVJMID0gZGF0YS51cmw7XG4gICAgY29uc3QgczNrZXkgPSBkYXRhLmtleTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShjb250ZW50LCBcImJhc2U2NFwiKTtcbiAgICAgICAgYXdhaXQgYXhpb3MucHV0KHNpZ25lZFVSTCwgYnVmZmVyLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogbWltZVR5cGUsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LUxlbmd0aFwiOiBidWZmZXIubGVuZ3RoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgYXhpb3MuQXhpb3NFcnJvciAmJiAoKF9hID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpID09PSA0MDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWduZWRVUkw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciB1cGxvYWRpbmcgZmlsZSB0byBTMzogJHtlcnJvcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHMza2V5O1xufTtcbmNvbnN0IGdldEZpbGVEYXRhQWZ0ZXJVcGxvYWRpbmdUb1MzID0gYXN5bmMgKHBhdGgsIGFjdGlvbk5hbWUsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IGlzVVJMID0gcGF0aC5zdGFydHNXaXRoKFwiaHR0cFwiKTtcbiAgICBjb25zdCBmaWxlRGF0YSA9IGlzVVJMXG4gICAgICAgID8gYXdhaXQgcmVhZEZpbGVDb250ZW50RnJvbVVSTChwYXRoKVxuICAgICAgICA6IGF3YWl0IHJlYWRGaWxlQ29udGVudChwYXRoKTtcbiAgICBjb25zdCBzM2tleSA9IGF3YWl0IHVwbG9hZEZpbGVUb1MzKGZpbGVEYXRhLmNvbnRlbnQsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUsIGZpbGVEYXRhLm1pbWVUeXBlLCBjbGllbnQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHBhdGhNb2R1bGUuYmFzZW5hbWUocGF0aCkgfHwgYCR7YWN0aW9uTmFtZX1fJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIG1pbWV0eXBlOiBmaWxlRGF0YS5taW1lVHlwZSxcbiAgICAgICAgczNrZXk6IHMza2V5LFxuICAgIH07XG59O1xuY29uc3QgZG93bmxvYWRGaWxlRnJvbVMzID0gYXN5bmMgKHsgYWN0aW9uTmFtZSwgczNVcmwsIG1pbWVUeXBlLCB9KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoczNVcmwsIHtcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gICAgfSk7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWltZVR5cGUuc3BsaXQoXCIvXCIpWzFdIHx8IFwidHh0XCI7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBgJHthY3Rpb25OYW1lfV8ke0RhdGUubm93KCl9LiR7ZXh0ZW5zaW9ufWA7XG4gICAgY29uc3QgZmlsZVBhdGggPSBzYXZlRmlsZShmaWxlTmFtZSwgcmVzcG9uc2UuZGF0YSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgczNLZXk6IHMzVXJsLFxuICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgfTtcbn07XG5cbmNvbnN0IEZJTEVfU1VGRklYID0gXCJfc2NoZW1hX3BhcnNlZF9maWxlXCI7XG5jb25zdCBjb252ZXJ0RmlsZVNjaGVtYVByb3BlcnR5ID0gKGtleSwgcHJvcGVydHkpID0+IHtcbiAgICBpZiAoIXByb3BlcnR5LmZpbGVfdXBsb2FkYWJsZSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleU5hbWU6IGAke2tleX0ke0ZJTEVfU1VGRklYfWAsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBwcm9wZXJ0eS5kZXNjcmlwdGlvbixcbiAgICB9O1xufTtcbmNvbnN0IHByb2Nlc3NGaWxlVXBsb2FkID0gYXN5bmMgKHBhcmFtcywgYWN0aW9uTmFtZSwgY2xpZW50KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi5wYXJhbXMgfTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQpKSB7XG4gICAgICAgIGlmICgha2V5LmVuZHNXaXRoKEZJTEVfU1VGRklYKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEtleSA9IGtleS5yZXBsYWNlKEZJTEVfU1VGRklYLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZmlsZURhdGEgPSBhd2FpdCBnZXRGaWxlRGF0YUFmdGVyVXBsb2FkaW5nVG9TMyh2YWx1ZSwgYWN0aW9uTmFtZSwgY2xpZW50KTtcbiAgICAgICAgcmVzdWx0W29yaWdpbmFsS2V5XSA9IGZpbGVEYXRhO1xuICAgICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgRklMRV9JTlBVVF9QUk9DRVNTT1IgPSBhc3luYyAoeyBwYXJhbXMsIGFjdGlvbk5hbWUsIGNsaWVudCwgfSkgPT4ge1xuICAgIHJldHVybiBwcm9jZXNzRmlsZVVwbG9hZChwYXJhbXMsIGFjdGlvbk5hbWUsIGNsaWVudCk7XG59O1xuY29uc3QgRklMRV9ET1dOTE9BREFCTEVfUFJPQ0VTU09SID0gYXN5bmMgKHsgYWN0aW9uTmFtZSwgdG9vbFJlc3BvbnNlLCB9KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0b29sUmVzcG9uc2UpKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh0b29sUmVzcG9uc2UuZGF0YSkpIHtcbiAgICAgICAgY29uc3QgZmlsZURhdGEgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCEoZmlsZURhdGEgPT09IG51bGwgfHwgZmlsZURhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVEYXRhLnMzdXJsKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGF3YWl0IGRvd25sb2FkRmlsZUZyb21TMyh7XG4gICAgICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgczNVcmw6IGZpbGVEYXRhLnMzdXJsLFxuICAgICAgICAgICAgbWltZVR5cGU6IGZpbGVEYXRhLm1pbWV0eXBlIHx8IFwiYXBwbGljYXRpb24vdHh0XCIsXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuZGF0YVtrZXldID0ge1xuICAgICAgICAgICAgdXJpOiBkb3dubG9hZGVkRmlsZS5maWxlUGF0aCxcbiAgICAgICAgICAgIHMzdXJsOiBmaWxlRGF0YS5zM3VybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBkb3dubG9hZGVkRmlsZS5taW1lVHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBGSUxFX1NDSEVNQV9QUk9DRVNTT1IgPSAoeyB0b29sU2NoZW1hIH0pID0+IHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIHJlcXVpcmVkOiByZXF1aXJlZFByb3BzID0gW10gfSA9IHRvb2xTY2hlbWEucGFyYW1ldGVycztcbiAgICBjb25zdCBuZXdQcm9wZXJ0aWVzID0geyAuLi5wcm9wZXJ0aWVzIH07XG4gICAgY29uc3QgbmV3UmVxdWlyZWQgPSBbLi4ucmVxdWlyZWRQcm9wc107XG4gICAgZm9yIChjb25zdCBba2V5LCBwcm9wZXJ0eV0gb2YgT2JqZWN0LmVudHJpZXMobmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eS5maWxlX3VwbG9hZGFibGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBrZXlOYW1lLCBkZXNjcmlwdGlvbiB9ID0gY29udmVydEZpbGVTY2hlbWFQcm9wZXJ0eShrZXksIHByb3BlcnR5KTtcbiAgICAgICAgbmV3UHJvcGVydGllc1trZXlOYW1lXSA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBwcm9wZXJ0eS50aXRsZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlcXVpcmVkUHJvcHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgbmV3UmVxdWlyZWRbbmV3UmVxdWlyZWQuaW5kZXhPZihrZXkpXSA9IGtleU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG5ld1Byb3BlcnRpZXNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4udG9vbFNjaGVtYSxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4udG9vbFNjaGVtYS5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBuZXdSZXF1aXJlZCxcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY2xhc3MgQ29tcG9zaW9Ub29sU2V0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvc2lvVG9vbFNldFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNvbmZpZy5hcGlLZXkgLSBBUEkga2V5IGZvciBhdXRoZW50aWNhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNvbmZpZy5iYXNlVXJsIC0gQmFzZSBVUkwgZm9yIEFQSSByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNvbmZpZy5ydW50aW1lIC0gUnVudGltZSBlbnZpcm9ubWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuZW50aXR5SWQgLSBFbnRpdHkgSUQgZm9yIG9wZXJhdGlvbnNcbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzIC0gTWFwIG9mIGFwcCBuYW1lcyB0byB0aGVpciBjb25uZWN0ZWQgYWNjb3VudCBJRHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmZpZy5hbGxvd1RyYWNpbmcgLSBXaGV0aGVyIHRvIGFsbG93IHRyYWNpbmcgZm9yIHRoZSBTREtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGFwaUtleSwgYmFzZVVybCwgcnVudGltZSwgZW50aXR5SWQsIGNvbm5lY3RlZEFjY291bnRJZHMsIGFsbG93VHJhY2luZywgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuZW50aXR5SWQgPSBcImRlZmF1bHRcIjtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzID0ge307XG4gICAgICAgIHRoaXMuaW50ZXJuYWxQcm9jZXNzb3JzID0ge1xuICAgICAgICAgICAgcHJlOiBbRklMRV9JTlBVVF9QUk9DRVNTT1JdLFxuICAgICAgICAgICAgcG9zdDogW0ZJTEVfRE9XTkxPQURBQkxFX1BST0NFU1NPUl0sXG4gICAgICAgICAgICBzY2hlbWE6IFtGSUxFX1NDSEVNQV9QUk9DRVNTT1JdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycyA9IHt9O1xuICAgICAgICBjb25zdCBjbGllbnRBcGlLZXkgPSBhcGlLZXkgfHxcbiAgICAgICAgICAgIGdldEVudlZhcmlhYmxlKFwiQ09NUE9TSU9fQVBJX0tFWVwiKSB8fFxuICAgICAgICAgICAgZ2V0VXNlckRhdGFKc29uKCkuYXBpX2tleTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjbGllbnRBcGlLZXk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IENvbXBvc2lvKHtcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICBiYXNlVXJsOiBiYXNlVXJsIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJ1bnRpbWU6IHJ1bnRpbWUsXG4gICAgICAgICAgICBhbGxvd1RyYWNpbmc6IGFsbG93VHJhY2luZyB8fCBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZW5kQ2xpZW50ID0gdGhpcy5jbGllbnQuYmFja2VuZENsaWVudDtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBY2NvdW50cyA9IHRoaXMuY2xpZW50LmNvbm5lY3RlZEFjY291bnRzO1xuICAgICAgICB0aGlzLmFwcHMgPSB0aGlzLmNsaWVudC5hcHBzO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSB0aGlzLmNsaWVudC5hY3Rpb25zO1xuICAgICAgICB0aGlzLnRyaWdnZXJzID0gdGhpcy5jbGllbnQudHJpZ2dlcnM7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25zID0gdGhpcy5jbGllbnQuaW50ZWdyYXRpb25zO1xuICAgICAgICB0aGlzLmFjdGl2ZVRyaWdnZXJzID0gdGhpcy5jbGllbnQuYWN0aXZlVHJpZ2dlcnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWNjb3VudElkcyA9IGNvbm5lY3RlZEFjY291bnRJZHMgfHwge307XG4gICAgICAgIHRoaXMudXNlckFjdGlvblJlZ2lzdHJ5ID0gbmV3IEFjdGlvblJlZ2lzdHJ5KHRoaXMuY2xpZW50KTtcbiAgICAgICAgaWYgKGVudGl0eUlkICYmIGNvbm5lY3RlZEFjY291bnRJZHMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiV2hlbiBib3RoIGVudGl0eSBhbmQgY29ubmVjdGVkQWNjb3VudElkcyBhcmUgcHJvdmlkZWQsIHByZWZlcmVuY2Ugd2lsbCBiZSBnaXZlbiB0byBjb25uZWN0ZWRBY2NvdW50SWRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0ZWRBY2NvdW50SWRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZEFjY291bnRJZHMgPSBjb25uZWN0ZWRBY2NvdW50SWRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRpdHlJZCkge1xuICAgICAgICAgICAgdGhpcy5lbnRpdHlJZCA9IGVudGl0eUlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFjdGlvbnNTY2hlbWEoZmlsdGVycyA9IHt9LCBfZW50aXR5SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9vbHNTY2hlbWEoe1xuICAgICAgICAgICAgYWN0aW9uczogZmlsdGVycy5hY3Rpb25zIHx8IFtdLFxuICAgICAgICB9LCBfZW50aXR5SWQpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb29sc1NjaGVtYShmaWx0ZXJzLCBfZW50aXR5SWQsIF9pbnRlZ3JhdGlvbklkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbHRlcnMgPSBaVG9vbFNjaGVtYUZpbHRlci5wYXJzZShmaWx0ZXJzKTtcbiAgICAgICAgbGV0IGFjdGlvbnMgPSBwYXJzZWRGaWx0ZXJzLmFjdGlvbnM7XG4gICAgICAgIGlmIChfaW50ZWdyYXRpb25JZCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZWdyYXRpb24gPSBhd2FpdCB0aGlzLmludGVncmF0aW9ucy5nZXQoe1xuICAgICAgICAgICAgICAgIGludGVncmF0aW9uSWQ6IF9pbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW50ZWdyYXRpb24gPT09IG51bGwgfHwgaW50ZWdyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVncmF0aW9uLmxpbWl0ZWRBY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMgPSBbLi4uaW50ZWdyYXRpb24ubGltaXRlZEFjdGlvbnNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGltaXRlZEFjdGlvbnNVcHBlcmNhc2UgPSBpbnRlZ3JhdGlvbi5saW1pdGVkQWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gYWN0aW9uLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5maWx0ZXIoKGFjdGlvbikgPT4gbGltaXRlZEFjdGlvbnNVcHBlcmNhc2UuaW5jbHVkZXMoYWN0aW9uLnRvVXBwZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwQWN0aW9ucyA9IGF3YWl0IHRoaXMuY2xpZW50LmFjdGlvbnMubGlzdCh7XG4gICAgICAgICAgICBhcHBzOiAoX2EgPSBwYXJzZWRGaWx0ZXJzLmFwcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgIHRhZ3M6IChfYiA9IHBhcnNlZEZpbHRlcnMudGFncykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgdXNlQ2FzZTogcGFyc2VkRmlsdGVycy51c2VDYXNlLFxuICAgICAgICAgICAgYWN0aW9uczogYWN0aW9ucyA9PT0gbnVsbCB8fCBhY3Rpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25zLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgdXNlY2FzZUxpbWl0OiBwYXJzZWRGaWx0ZXJzLnVzZUNhc2VMaW1pdCxcbiAgICAgICAgICAgIGZpbHRlckJ5QXZhaWxhYmxlQXBwczogcGFyc2VkRmlsdGVycy5maWx0ZXJCeUF2YWlsYWJsZUFwcHMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXN0b21BY3Rpb25zID0gYXdhaXQgdGhpcy51c2VyQWN0aW9uUmVnaXN0cnkuZ2V0QWxsQWN0aW9ucygpO1xuICAgICAgICBjb25zdCB0b29sc1dpdGhDdXN0b21BY3Rpb25zID0gY3VzdG9tQWN0aW9ucy5maWx0ZXIoKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lOiBhY3Rpb25OYW1lIH0gPSBhY3Rpb24gfHwge307XG4gICAgICAgICAgICByZXR1cm4gKCghZmlsdGVycy5hY3Rpb25zIHx8XG4gICAgICAgICAgICAgICAgZmlsdGVycy5hY3Rpb25zLnNvbWUoKG5hbWUpID0+IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gKGFjdGlvbk5hbWUgPT09IG51bGwgfHwgYWN0aW9uTmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uTmFtZS50b0xvd2VyQ2FzZSgpKSkpICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXJzLnRhZ3MgfHxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycy50YWdzLnNvbWUoKHRhZykgPT4gdGFnLnRvTG93ZXJDYXNlKCkgPT09IFwiY3VzdG9tXCIpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b29sc0FjdGlvbnMgPSBbXG4gICAgICAgICAgICAuLi4oKGFwcEFjdGlvbnMgPT09IG51bGwgfHwgYXBwQWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQWN0aW9ucy5pdGVtcykgfHwgW10pLFxuICAgICAgICAgICAgLi4udG9vbHNXaXRoQ3VzdG9tQWN0aW9ucyxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYWxsU2NoZW1hUHJvY2Vzc29yID0gW1xuICAgICAgICAgICAgLi4udGhpcy5pbnRlcm5hbFByb2Nlc3NvcnMuc2NoZW1hLFxuICAgICAgICAgICAgLi4uKHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnNjaGVtYVxuICAgICAgICAgICAgICAgID8gW3RoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnNjaGVtYV1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVG9vbHMgPSBbXTtcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b29scyBhbmQgcHJvY2VzcyB0aGVtXG4gICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sc0FjdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBzY2hlbWEgPSB0b29sO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgc2NoZW1hIHdpdGggYWxsIHRoZSBwcm9jZXNzb3JzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBhbGxTY2hlbWFQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBhd2FpdCBwcm9jZXNzb3Ioe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbFNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc2VkVG9vbHMucHVzaChzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWRUb29scztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlckFjdGlvblJlZ2lzdHJ5LmNyZWF0ZUFjdGlvbihvcHRpb25zKTtcbiAgICB9XG4gICAgaXNDdXN0b21BY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJBY3Rpb25SZWdpc3RyeVxuICAgICAgICAgICAgLmdldEFjdGlvbnMoeyBhY3Rpb25zOiBbYWN0aW9uXSB9KVxuICAgICAgICAgICAgLnRoZW4oKGFjdGlvbnMpID0+IGFjdGlvbnMubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEVudGl0eShlbnRpdHlJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuZ2V0RW50aXR5KGVudGl0eUlkKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZUFjdGlvbihmdW5jdGlvblBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgYWN0aW9uLCBwYXJhbXM6IGlucHV0UGFyYW1zID0ge30sIGVudGl0eUlkID0gdGhpcy5lbnRpdHlJZCwgbmxhVGV4dCA9IFwiXCIsIGNvbm5lY3RlZEFjY291bnRJZCwgfSA9IFpFeGVjdXRlQWN0aW9uUGFyYW1zLnBhcnNlKHtcbiAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb25QYXJhbXMuYWN0aW9uTmFtZSB8fCBmdW5jdGlvblBhcmFtcy5hY3Rpb24sXG4gICAgICAgICAgICBwYXJhbXM6IGZ1bmN0aW9uUGFyYW1zLnBhcmFtcyxcbiAgICAgICAgICAgIGVudGl0eUlkOiBmdW5jdGlvblBhcmFtcy5lbnRpdHlJZCxcbiAgICAgICAgICAgIG5sYVRleHQ6IGZ1bmN0aW9uUGFyYW1zLm5sYVRleHQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGZ1bmN0aW9uUGFyYW1zLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZW50aXR5SWQgJiYgIWNvbm5lY3RlZEFjY291bnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5TREsuTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTm8gZW50aXR5SWQgb3IgY29ubmVjdGVkQWNjb3VudElkIHByb3ZpZGVkYCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFBsZWFzZSBwcm92aWRlIGVpdGhlciBlbnRpdHlJZCBvciBjb25uZWN0ZWRBY2NvdW50SWRgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtcyA9IGlucHV0UGFyYW1zIHx8IHt9O1xuICAgICAgICBjb25zdCBhbGxJbnB1dFByb2Nlc3NvciA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuaW50ZXJuYWxQcm9jZXNzb3JzLnByZSxcbiAgICAgICAgICAgIC4uLih0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5wcmVcbiAgICAgICAgICAgICAgICA/IFt0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5wcmVdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF07XG4gICAgICAgIGZvciAoY29uc3QgcHJvY2Vzc29yIG9mIGFsbElucHV0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBhd2FpdCBwcm9jZXNzb3Ioe1xuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbixcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LmJhY2tlbmRDbGllbnQuaW5zdGFuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDdXN0b20gYWN0aW9ucyBhcmUgYWx3YXlzIGV4ZWN1dGVkIGluIHRoZSBob3N0L2xvY2FsIGVudmlyb25tZW50IGZvciBKUyBTREtcbiAgICAgICAgbGV0IGFjY291bnRJZCA9IGNvbm5lY3RlZEFjY291bnRJZDtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuaXNDdXN0b21BY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGF3YWl0IHRoaXMudXNlckFjdGlvblJlZ2lzdHJ5LmdldFRvb2xOYW1lKHsgYWN0aW9uIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRzID0gYXdhaXQgdGhpcy5jbGllbnQuY29ubmVjdGVkQWNjb3VudHMubGlzdCh7XG4gICAgICAgICAgICAgICAgICAgIGFwcE5hbWVzOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlcl91dWlkOiBlbnRpdHlJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcIkFDVElWRVwiLFxuICAgICAgICAgICAgICAgICAgICBzaG93QWN0aXZlT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQgPSAoX2EgPSBjb25uZWN0ZWRBY2NvdW50cyA9PT0gbnVsbCB8fCBjb25uZWN0ZWRBY2NvdW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGVkQWNjb3VudHMuaXRlbXNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgdXNlciB0byB1c2UgY3VzdG9tIGFjdGlvbnMgYW5kIHRvb2xzIHdpdGhvdXQgYSBjb25uZWN0ZWQgYWNjb3VudFxuICAgICAgICAgICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIk5vIGNvbm5lY3RlZCBhY2NvdW50IGZvdW5kIGZvciB0aGUgdXNlci4gSWYgeW91ciBjdXN0b20gYWN0aW9uIHJlcXVpcmVzIGEgY29ubmVjdGVkIGFjY291bnQsIHBsZWFzZSBkb3VibGUgY2hlY2sgaWYgeW91IGhhdmUgYWN0aXZlIGFjY291bnRzIGNvbm5lY3RlZCB0byBpdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VyQWN0aW9uUmVnaXN0cnkuZXhlY3V0ZUFjdGlvbihhY3Rpb24sIHBhcmFtcywge1xuICAgICAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGFjY291bnRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRLZXlzID0gT2JqZWN0LmtleXModGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzKTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEFjY291bnRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbkRldGFpbHMgPSBhd2FpdCB0aGlzLmFjdGlvbnMuZ2V0KHsgYWN0aW9uTmFtZTogYWN0aW9uIH0pO1xuICAgICAgICAgICAgY29uc3QgYXBwTmFtZUtleSA9IGNvbm5lY3RlZEFjY291bnRLZXlzLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IGFjdGlvbkRldGFpbHMuYXBwTmFtZSk7XG4gICAgICAgICAgICBpZiAoYXBwTmFtZUtleSkge1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCA9IHRoaXMuY29ubmVjdGVkQWNjb3VudElkc1thcHBOYW1lS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5jbGllbnQuZ2V0RW50aXR5KGVudGl0eUlkKS5leGVjdXRlKHtcbiAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbixcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgdGV4dDogbmxhVGV4dCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogYWNjb3VudElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlKGRhdGEsIHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGVudGl0eUlkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc1Jlc3BvbnNlKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgYWxsT3V0cHV0UHJvY2Vzc29yID0gW1xuICAgICAgICAgICAgLi4udGhpcy5pbnRlcm5hbFByb2Nlc3NvcnMucG9zdCxcbiAgICAgICAgICAgIC4uLih0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5wb3N0XG4gICAgICAgICAgICAgICAgPyBbdGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucG9zdF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gRGlydHkgd2F5IHRvIGF2b2lkIGNvcHlcbiAgICAgICAgbGV0IGRhdGFUb1JldHVybiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBhbGxPdXRwdXRQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgIGRhdGFUb1JldHVybiA9IGF3YWl0IHByb2Nlc3Nvcih7XG4gICAgICAgICAgICAgICAgYWN0aW9uTmFtZTogbWV0YS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgdG9vbFJlc3BvbnNlOiBkYXRhVG9SZXR1cm4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YVRvUmV0dXJuO1xuICAgIH1cbiAgICBhc3luYyBhZGRTY2hlbWFQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnNjaGVtYSA9IHByb2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvY2Vzc29yIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGFkZFByZVByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucHJlID0gcHJvY2Vzc29yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9jZXNzb3IgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXN5bmMgYWRkUG9zdFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucG9zdCA9IHByb2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvY2Vzc29yIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVByZVByb2Nlc3NvcigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnByZTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlUG9zdFByb2Nlc3NvcigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnBvc3Q7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVNjaGVtYVByb2Nlc3NvcigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnNjaGVtYTtcbiAgICB9XG59XG5cbmNvbnN0IENPTVBPU0lPX0JBU0VfVVJMID0gXCJodHRwczovL2JhY2tlbmQuY29tcG9zaW8uZGV2XCI7XG5cbi8qKlxuICogQ2xvdWRmbGFyZVRvb2xTZXQgcHJvdmlkZXMgaW50ZWdyYXRpb24gd2l0aCBDbG91ZGZsYXJlIFdvcmtlcnMgQUlcbiAqIGZvciBleGVjdXRpbmcgQUkgdG9vbCBjYWxscyBhbmQgaGFuZGxpbmcgcmVzcG9uc2VzXG4gKi9cbmNsYXNzIENsb3VkZmxhcmVUb29sU2V0IGV4dGVuZHMgQ29tcG9zaW9Ub29sU2V0IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgbmV3IENsb3VkZmxhcmVUb29sU2V0IGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBpbmNsdWRpbmcgQVBJIGtleSwgYmFzZSBVUkwsIGVudGl0eSBJRCBhbmQgd29ya3NwYWNlIGNvbmZpZ1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSB8fCBudWxsLFxuICAgICAgICAgICAgYmFzZVVybDogY29uZmlnLmJhc2VVcmwgfHwgQ09NUE9TSU9fQkFTRV9VUkwsXG4gICAgICAgICAgICBydW50aW1lOiBudWxsLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGNvbmZpZy5lbnRpdHlJZCB8fCBDbG91ZGZsYXJlVG9vbFNldC5ERUZBVUxUX0VOVElUWV9JRCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBjb25maWcuYWxsb3dUcmFjaW5nIHx8IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL2ZyYW1ld29ya3MvY2xvdWRmbGFyZS50c1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhdmFpbGFibGUgdG9vbHMgYmFzZWQgb24gcHJvdmlkZWQgZmlsdGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIGZpbHRlcnMgT3B0aW9uYWwgZmlsdGVycyBmb3IgYWN0aW9ucywgYXBwcywgdGFncyBhbmQgdXNlIGNhc2VzXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgQUkgdGV4dCBnZW5lcmF0aW9uIHRvb2xzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VG9vbHMoZmlsdGVycykge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFRvb2xzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0VG9vbHNTY2hlbWEoZmlsdGVycyk7XG4gICAgICAgIHJldHVybiAoYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSBhY3Rpb24gc2NoZW1hIGZvciBDbG91ZGZsYXJlIFdvcmtlcnMgQUlcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGFjdGlvbi5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmb3JtYXR0ZWRTY2hlbWEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIHNpbmdsZSB0b29sIGNhbGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b29sIFRoZSB0b29sIHRvIGV4ZWN1dGUgd2l0aCBuYW1lIGFuZCBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gZW50aXR5SWQgT3B0aW9uYWwgZW50aXR5IElEIHRvIGV4ZWN1dGUgdGhlIHRvb2wgZm9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc3RyaW5naWZpZWQgdG9vbCBleGVjdXRpb24gcmVzdWx0XG4gICAgICovXG4gICAgYXN5bmMgZXhlY3V0ZVRvb2xDYWxsKHRvb2wsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJleGVjdXRlVG9vbENhbGxcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgdG9vbCwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvb2xTY2hlbWEgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKHtcbiAgICAgICAgICAgIGFjdGlvbnM6IFt0b29sLm5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBwTmFtZSA9IChfYiA9IChfYSA9IHRvb2xTY2hlbWFbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBOYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudElkID0gYXBwTmFtZSAmJiAoKF9jID0gdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbYXBwTmFtZV0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgdGhpcy5leGVjdXRlQWN0aW9uKHtcbiAgICAgICAgICAgIGFjdGlvbjogdG9vbC5uYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB0eXBlb2YgdG9vbC5hcmd1bWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IEpTT04ucGFyc2UodG9vbC5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiB0b29sLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkLFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBjb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRvb2wgY2FsbHMgZnJvbSBBSSB0ZXh0IGdlbmVyYXRpb24gb3V0cHV0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzdWx0IFRoZSBBSSB0ZXh0IGdlbmVyYXRpb24gb3V0cHV0IGNvbnRhaW5pbmcgdG9vbCBjYWxsc1xuICAgICAqIEBwYXJhbSBlbnRpdHlJZCBPcHRpb25hbCBlbnRpdHkgSUQgdG8gZXhlY3V0ZSB0aGUgdG9vbHMgZm9yXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYXJyYXkgb2YgdG9vbCBleGVjdXRpb24gcmVzdWx0c1xuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZVRvb2xDYWxsKHJlc3VsdCwgZW50aXR5SWQgPSBudWxsKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiaGFuZGxlVG9vbENhbGxcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgcmVzdWx0LCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgICAgICBpZiAoXCJ0b29sX2NhbGxzXCIgaW4gcmVzdWx0ICYmIEFycmF5LmlzQXJyYXkocmVzdWx0LnRvb2xfY2FsbHMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xfY2FsbCBvZiByZXN1bHQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGlmICh0b29sX2NhbGwubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2goYXdhaXQgdGhpcy5leGVjdXRlVG9vbENhbGwodG9vbF9jYWxsLCBlbnRpdHlJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG59XG4vLyBDbGFzcyBjb25zdGFudHNcbkNsb3VkZmxhcmVUb29sU2V0LkZSQU1FV09SS19OQU1FID0gXCJjbG91ZGZsYXJlXCI7XG5DbG91ZGZsYXJlVG9vbFNldC5ERUZBVUxUX0VOVElUWV9JRCA9IFwiZGVmYXVsdFwiO1xuXG5jbGFzcyBMYW5nY2hhaW5Ub29sU2V0IGV4dGVuZHMgQ29tcG9zaW9Ub29sU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsIHx8IENPTVBPU0lPX0JBU0VfVVJMLFxuICAgICAgICAgICAgcnVudGltZTogKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5ydW50aW1lKSB8fCBMYW5nY2hhaW5Ub29sU2V0LkZSQU1FV09SS19OQU1FLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGNvbmZpZy5lbnRpdHlJZCB8fCBMYW5nY2hhaW5Ub29sU2V0LkRFRkFVTFRfRU5USVRZX0lELFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkczogY29uZmlnLmNvbm5lY3RlZEFjY291bnRJZHMsXG4gICAgICAgICAgICBhbGxvd1RyYWNpbmc6IGNvbmZpZy5hbGxvd1RyYWNpbmcgfHwgZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvZnJhbWV3b3Jrcy9sYW5nY2hhaW4udHNcIjtcbiAgICB9XG4gICAgX3dyYXBUb29sKHNjaGVtYSwgZW50aXR5SWQgPSBudWxsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gc2NoZW1hW1wibmFtZVwiXTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY2hlbWFbXCJkZXNjcmlwdGlvblwiXTtcbiAgICAgICAgY29uc3QgYXBwTmFtZSA9IChfYSA9IHNjaGVtYVtcImFwcE5hbWVcIl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBmdW5jID0gYXN5bmMgKC4uLmt3YXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudElkID0gYXBwTmFtZSAmJiAoKF9hID0gdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYXBwTmFtZV0pO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IHRoaXMuZXhlY3V0ZUFjdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtczoga3dhcmdzWzBdLFxuICAgICAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0ganNvblNjaGVtYVRvTW9kZWwoc2NoZW1hW1wicGFyYW1ldGVyc1wiXSk7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgZXNjcmlpcHRpb24gYW4gb3RoZXIgc3R1ZmYgaGVyZVxuICAgICAgICByZXR1cm4gbmV3IHRvb2xzLkR5bmFtaWNTdHJ1Y3R1cmVkVG9vbCh7XG4gICAgICAgICAgICBuYW1lOiBhY3Rpb24sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNjaGVtYTogcGFyYW1ldGVycyxcbiAgICAgICAgICAgIGZ1bmM6IGZ1bmMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb29scyhmaWx0ZXJzID0ge30sIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFRvb2xzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGZpbHRlcnMsIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b29scyA9IGF3YWl0IHRoaXMuZ2V0VG9vbHNTY2hlbWEoZmlsdGVycywgZW50aXR5SWQsIGZpbHRlcnMuaW50ZWdyYXRpb25JZCk7XG4gICAgICAgIHJldHVybiB0b29scy5tYXAoKHRvb2wpID0+IHRoaXMuX3dyYXBUb29sKHRvb2wsIGVudGl0eUlkIHx8IHRoaXMuZW50aXR5SWQpKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBvc2lvIHRvb2xzZXQgZm9yIExhbmdjaGFpbiBmcmFtZXdvcmsuXG4gKlxuICovXG5MYW5nY2hhaW5Ub29sU2V0LkZSQU1FV09SS19OQU1FID0gXCJsYW5nY2hhaW5cIjtcbkxhbmdjaGFpblRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQgPSBcImRlZmF1bHRcIjtcblxuY2xhc3MgTGFuZ0dyYXBoVG9vbFNldCBleHRlbmRzIExhbmdjaGFpblRvb2xTZXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGFwaUtleTogY29uZmlnLmFwaUtleSB8fCBudWxsLFxuICAgICAgICAgICAgYmFzZVVybDogY29uZmlnLmJhc2VVcmwgfHwgQ09NUE9TSU9fQkFTRV9VUkwsXG4gICAgICAgICAgICBlbnRpdHlJZDogY29uZmlnLmVudGl0eUlkIHx8IExhbmdHcmFwaFRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQsXG4gICAgICAgICAgICBydW50aW1lOiBMYW5nR3JhcGhUb29sU2V0LkZSQU1FV09SS19OQU1FLFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkczogY29uZmlnLmNvbm5lY3RlZEFjY291bnRJZHMsXG4gICAgICAgICAgICBhbGxvd1RyYWNpbmc6IGNvbmZpZy5hbGxvd1RyYWNpbmcgfHwgZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcG9zaW8gdG9vbHNldCBmb3IgTGFuZ2dyYXBoIGZyYW1ld29yay5cbiAqXG4gKi9cbkxhbmdHcmFwaFRvb2xTZXQuRlJBTUVXT1JLX05BTUUgPSBcImxhbmdHcmFwaFwiO1xuTGFuZ0dyYXBoVG9vbFNldC5ERUZBVUxUX0VOVElUWV9JRCA9IFwiZGVmYXVsdFwiO1xuXG5jbGFzcyBPcGVuQUlUb29sU2V0IGV4dGVuZHMgQ29tcG9zaW9Ub29sU2V0IHtcbiAgICAvKipcbiAgICAgKiBDb21wb3NpbyB0b29sc2V0IGZvciBPcGVuQUkgZnJhbWV3b3JrLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsIHx8IENPTVBPU0lPX0JBU0VfVVJMLFxuICAgICAgICAgICAgcnVudGltZTogT3BlbkFJVG9vbFNldC5GUkFNRVdPUktfTkFNRSxcbiAgICAgICAgICAgIGVudGl0eUlkOiBjb25maWcuZW50aXR5SWQgfHwgT3BlbkFJVG9vbFNldC5ERUZBVUxUX0VOVElUWV9JRCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBjb25maWcuYWxsb3dUcmFjaW5nIHx8IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL2ZyYW1ld29ya3Mvb3BlbmFpLnRzXCI7XG4gICAgfVxuICAgIGFzeW5jIGdldFRvb2xzKGZpbHRlcnMsIGVudGl0eUlkKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0VG9vbHNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IGZpbHRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYWluQWN0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0VG9vbHNTY2hlbWEoZmlsdGVycywgZW50aXR5SWQsIGZpbHRlcnMuaW50ZWdyYXRpb25JZCk7XG4gICAgICAgIHJldHVybiAobWFpbkFjdGlvbnMubWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYWN0aW9uLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGFjdGlvbi5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmb3JtYXR0ZWRTY2hlbWEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pIHx8IFtdKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVRvb2xDYWxsKHRvb2wsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJleGVjdXRlVG9vbENhbGxcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgdG9vbCwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvb2xTY2hlbWEgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKHtcbiAgICAgICAgICAgIGFjdGlvbnM6IFt0b29sLmZ1bmN0aW9uLm5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBwTmFtZSA9IChfYiA9IChfYSA9IHRvb2xTY2hlbWFbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBOYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudElkID0gYXBwTmFtZSAmJiAoKF9jID0gdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbYXBwTmFtZV0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgdGhpcy5leGVjdXRlQWN0aW9uKHtcbiAgICAgICAgICAgIGFjdGlvbjogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkLFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBjb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbENhbGwoY2hhdENvbXBsZXRpb24sIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImhhbmRsZVRvb2xDYWxsXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGNoYXRDb21wbGV0aW9uLCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgY2hhdENvbXBsZXRpb24uY2hvaWNlcykge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKGF3YWl0IHRoaXMuZXhlY3V0ZVRvb2xDYWxsKG1lc3NhZ2UubWVzc2FnZS50b29sX2NhbGxzWzBdLCBlbnRpdHlJZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBc3Npc3RhbnRNZXNzYWdlKHJ1biwgZW50aXR5SWQgPSBudWxsKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiaGFuZGxlQXNzaXN0YW50TWVzc2FnZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBydW4sIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b29sX2NhbGxzID0gKChfYiA9IChfYSA9IHJ1bi5yZXF1aXJlZF9hY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJtaXRfdG9vbF9vdXRwdXRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9vbF9jYWxscykgfHwgW107XG4gICAgICAgIGNvbnN0IHRvb2xfb3V0cHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRvb2xfY2FsbHMubWFwKGFzeW5jICh0b29sX2NhbGwpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRXhlY3V0aW5nIHRvb2wgY2FsbCB3aXRoIElEOiAke3Rvb2xfY2FsbC5mdW5jdGlvbi5uYW1lfSBhbmQgcGFyYW1ldGVyczogJHtKU09OLnN0cmluZ2lmeSh0b29sX2NhbGwuZnVuY3Rpb24uYXJndW1lbnRzKX1gKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xfcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmV4ZWN1dGVUb29sQ2FsbCh0b29sX2NhbGwsIGVudGl0eUlkIHx8IHRoaXMuZW50aXR5SWQpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBSZWNlaXZlZCB0b29sIHJlc3BvbnNlOiAke0pTT04uc3RyaW5naWZ5KHRvb2xfcmVzcG9uc2UpfWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xfY2FsbC5pZCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdG9vbF9vdXRwdXRzO1xuICAgIH1cbiAgICBhc3luYyAqd2FpdEFuZEhhbmRsZUFzc2lzdGFudFN0cmVhbVRvb2xDYWxscyhjbGllbnQsIHJ1blN0cmVhbSwgdGhyZWFkLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJ3YWl0QW5kSGFuZGxlQXNzaXN0YW50U3RyZWFtVG9vbENhbGxzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGNsaWVudCwgcnVuU3RyZWFtLCB0aHJlYWQsIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcnVuSWQgPSBudWxsO1xuICAgICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIHRoZSBydW5TdHJlYW0gZXZlbnRzXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2YgcnVuU3RyZWFtKSB7XG4gICAgICAgICAgICB5aWVsZCBldmVudDsgLy8gWWllbGQgZWFjaCBldmVudCBmcm9tIHRoZSBzdHJlYW0gYXMgaXQgYXJyaXZlc1xuICAgICAgICAgICAgaWYgKGV2ZW50LmV2ZW50ID09PSBcInRocmVhZC5ydW4uY3JlYXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBydW5JZCA9IGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFydW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHRoZSAncmVxdWlyZXNfYWN0aW9uJyBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50LmV2ZW50ID09PSBcInRocmVhZC5ydW4ucmVxdWlyZXNfYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sT3V0cHV0cyA9IGF3YWl0IHRoaXMuaGFuZGxlQXNzaXN0YW50TWVzc2FnZShldmVudC5kYXRhLCBlbnRpdHlJZCk7XG4gICAgICAgICAgICAgICAgLy8gU3VibWl0IHRoZSB0b29sIG91dHB1dHNcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkLmlkLCBydW5JZCwge1xuICAgICAgICAgICAgICAgICAgICB0b29sX291dHB1dHM6IHRvb2xPdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnJlYWsgaWYgdGhlIHJ1biBzdGF0dXMgYmVjb21lcyBpbmFjdGl2ZVxuICAgICAgICAgICAgaWYgKFtcbiAgICAgICAgICAgICAgICBcInRocmVhZC5ydW4uY29tcGxldGVkXCIsXG4gICAgICAgICAgICAgICAgXCJ0aHJlYWQucnVuLmZhaWxlZFwiLFxuICAgICAgICAgICAgICAgIFwidGhyZWFkLnJ1bi5jYW5jZWxsZWRcIixcbiAgICAgICAgICAgICAgICBcInRocmVhZC5ydW4uZXhwaXJlZFwiLFxuICAgICAgICAgICAgXS5pbmNsdWRlcyhldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ1bklkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBydW4gSUQgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGFueSBmaW5hbCBhY3Rpb25zIGFmdGVyIHRoZSBzdHJlYW0gZW5kc1xuICAgICAgICBsZXQgZmluYWxSdW4gPSBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMucmV0cmlldmUodGhyZWFkLmlkLCBydW5JZCk7XG4gICAgICAgIHdoaWxlIChbXCJxdWV1ZWRcIiwgXCJpbl9wcm9ncmVzc1wiLCBcInJlcXVpcmVzX2FjdGlvblwiXS5pbmNsdWRlcyhmaW5hbFJ1bi5zdGF0dXMpKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxSdW4uc3RhdHVzID09PSBcInJlcXVpcmVzX2FjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbE91dHB1dHMgPSBhd2FpdCB0aGlzLmhhbmRsZUFzc2lzdGFudE1lc3NhZ2UoZmluYWxSdW4sIGVudGl0eUlkKTtcbiAgICAgICAgICAgICAgICAvLyBTdWJtaXQgdG9vbCBvdXRwdXRzXG4gICAgICAgICAgICAgICAgZmluYWxSdW4gPSBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkLmlkLCBydW5JZCwge1xuICAgICAgICAgICAgICAgICAgICB0b29sX291dHB1dHM6IHRvb2xPdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBydW4gc3RhdHVzXG4gICAgICAgICAgICAgICAgZmluYWxSdW4gPSBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMucmV0cmlldmUodGhyZWFkLmlkLCBydW5JZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7IC8vIFdhaXQgYmVmb3JlIHJlY2hlY2tpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB3YWl0QW5kSGFuZGxlQXNzaXN0YW50VG9vbENhbGxzKGNsaWVudCwgcnVuLCB0aHJlYWQsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIndhaXRBbmRIYW5kbGVBc3Npc3RhbnRUb29sQ2FsbHNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgY2xpZW50LCBydW4sIHRocmVhZCwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChbXCJxdWV1ZWRcIiwgXCJpbl9wcm9ncmVzc1wiLCBcInJlcXVpcmVzX2FjdGlvblwiXS5pbmNsdWRlcyhydW4uc3RhdHVzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBDdXJyZW50IHJ1biBzdGF0dXM6ICR7cnVuLnN0YXR1c31gKTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xfb3V0cHV0cyA9IGF3YWl0IHRoaXMuaGFuZGxlQXNzaXN0YW50TWVzc2FnZShydW4sIGVudGl0eUlkIHx8IHRoaXMuZW50aXR5SWQpO1xuICAgICAgICAgICAgaWYgKHJ1bi5zdGF0dXMgPT09IFwicmVxdWlyZXNfYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFN1Ym1pdHRpbmcgdG9vbCBvdXRwdXRzIGZvciBydW4gSUQ6ICR7cnVuLmlkfSBpbiB0aHJlYWQgSUQ6ICR7dGhyZWFkLmlkfWApO1xuICAgICAgICAgICAgICAgIHJ1biA9IGF3YWl0IGNsaWVudC5iZXRhLnRocmVhZHMucnVucy5zdWJtaXRUb29sT3V0cHV0cyh0aHJlYWQuaWQsIHJ1bi5pZCwge1xuICAgICAgICAgICAgICAgICAgICB0b29sX291dHB1dHM6IHRvb2xfb3V0cHV0cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1biA9IGF3YWl0IGNsaWVudC5iZXRhLnRocmVhZHMucnVucy5yZXRyaWV2ZSh0aHJlYWQuaWQsIHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG59XG5PcGVuQUlUb29sU2V0LkZSQU1FV09SS19OQU1FID0gXCJvcGVuYWlcIjtcbk9wZW5BSVRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQgPSBcImRlZmF1bHRcIjtcblxuY29uc3QgWkV4ZWN1dGVUb29sQ2FsbFBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFjdGlvbnM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgYXBwczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBwYXJhbXM6IHouei5yZWNvcmQoei56LmFueSgpKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB1c2VDYXNlOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB1c2VjYXNlTGltaXQ6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdGFnczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICBmaWx0ZXJCeUF2YWlsYWJsZUFwcHM6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZWZhdWx0KGZhbHNlKSxcbn0pO1xuY2xhc3MgVmVyY2VsQUlUb29sU2V0IGV4dGVuZHMgQ29tcG9zaW9Ub29sU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsIHx8IG51bGwsXG4gICAgICAgICAgICBydW50aW1lOiBcInZlcmNlbC1haVwiLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGNvbmZpZy5lbnRpdHlJZCB8fCBcImRlZmF1bHRcIixcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBjb25maWcuYWxsb3dUcmFjaW5nIHx8IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL2ZyYW1ld29ya3MvdmVyY2VsLnRzXCI7XG4gICAgfVxuICAgIGdlbmVyYXRlVmVyY2VsVG9vbChzY2hlbWEsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYWkudG9vbCh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGUgdHlwZSBhcmUgSlNPTlNjaGVtVjcuIEludGVybmFsbHkgaXQncyByZXNvbHZlZFxuICAgICAgICAgICAgcGFyYW1ldGVyczogYWkuanNvblNjaGVtYShzY2hlbWEucGFyYW1ldGVycyksXG4gICAgICAgICAgICBleGVjdXRlOiBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocGFyYW1zKSxcbiAgICAgICAgICAgICAgICB9LCBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjaGFuZ2UgdGhpcyBpbXBsZW1lbnRhdGlvblxuICAgIGFzeW5jIGdldFRvb2xzKGZpbHRlcnMsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFRvb2xzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBhcHBzLCB0YWdzLCB1c2VDYXNlLCB1c2VjYXNlTGltaXQsIGZpbHRlckJ5QXZhaWxhYmxlQXBwcywgYWN0aW9ucywgfSA9IFpFeGVjdXRlVG9vbENhbGxQYXJhbXMucGFyc2UoZmlsdGVycyk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnNMaXN0ID0gYXdhaXQgdGhpcy5nZXRUb29sc1NjaGVtYSh7XG4gICAgICAgICAgICBhcHBzLFxuICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgICB1c2VDYXNlLFxuICAgICAgICAgICAgdXNlQ2FzZUxpbWl0OiB1c2VjYXNlTGltaXQsXG4gICAgICAgICAgICBmaWx0ZXJCeUF2YWlsYWJsZUFwcHMsXG4gICAgICAgIH0sIGVudGl0eUlkLCBmaWx0ZXJzLmludGVncmF0aW9uSWQpO1xuICAgICAgICBjb25zdCB0b29scyA9IHt9O1xuICAgICAgICBhY3Rpb25zTGlzdC5mb3JFYWNoKChhY3Rpb25TY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHRvb2xzW2FjdGlvblNjaGVtYS5uYW1lXSA9IHRoaXMuZ2VuZXJhdGVWZXJjZWxUb29sKGFjdGlvblNjaGVtYSwgZW50aXR5SWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvb2xzO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlVG9vbENhbGwodG9vbCwgZW50aXR5SWQgPSBudWxsKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImV4ZWN1dGVUb29sQ2FsbFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyB0b29sLCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbFNjaGVtYSA9IGF3YWl0IHRoaXMuZ2V0VG9vbHNTY2hlbWEoe1xuICAgICAgICAgICAgYWN0aW9uczogW3Rvb2wubmFtZV0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcHBOYW1lID0gKF9iID0gKF9hID0gdG9vbFNjaGVtYVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcE5hbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50SWQgPSBhcHBOYW1lICYmICgoX2MgPSB0aGlzLmNvbm5lY3RlZEFjY291bnRJZHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1thcHBOYW1lXSk7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCB0aGlzLmV4ZWN1dGVBY3Rpb24oe1xuICAgICAgICAgICAgYWN0aW9uOiB0b29sLm5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHR5cGVvZiB0b29sLmFyZ3VtZW50cyA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gSlNPTi5wYXJzZSh0b29sLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICA6IHRvb2wuYXJndW1lbnRzLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGVudGl0eUlkIHx8IHRoaXMuZW50aXR5SWQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmNvbnN0IHsgQVBQUywgQUNUSU9OUyB9ID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5leHBvcnRzLkFDVElPTlMgPSBBQ1RJT05TO1xuZXhwb3J0cy5BUFBTID0gQVBQUztcbmV4cG9ydHMuQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTID0gQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTO1xuZXhwb3J0cy5DbG91ZGZsYXJlVG9vbFNldCA9IENsb3VkZmxhcmVUb29sU2V0O1xuZXhwb3J0cy5Db21wb3NpbyA9IENvbXBvc2lvO1xuZXhwb3J0cy5Db21wb3Npb0Vycm9yID0gQ29tcG9zaW9FcnJvcjtcbmV4cG9ydHMuQ29tcG9zaW9Ub29sU2V0ID0gQ29tcG9zaW9Ub29sU2V0O1xuZXhwb3J0cy5Db25uZWN0aW9uUmVxdWVzdCA9IENvbm5lY3Rpb25SZXF1ZXN0O1xuZXhwb3J0cy5MYW5nR3JhcGhUb29sU2V0ID0gTGFuZ0dyYXBoVG9vbFNldDtcbmV4cG9ydHMuTGFuZ2NoYWluVG9vbFNldCA9IExhbmdjaGFpblRvb2xTZXQ7XG5leHBvcnRzLk9wZW5BSVRvb2xTZXQgPSBPcGVuQUlUb29sU2V0O1xuZXhwb3J0cy5WZXJjZWxBSVRvb2xTZXQgPSBWZXJjZWxBSVRvb2xTZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAX: () => (/* reexport safe */ _max_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   v1ToV6: () => (/* reexport safe */ _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   v6: () => (/* reexport safe */ _v6_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]),\n/* harmony export */   v6ToV1: () => (/* reexport safe */ _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]),\n/* harmony export */   v7: () => (/* reexport safe */ _v7_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./max.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/max.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nil.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./v1.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./v1ToV6.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./v3.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./v4.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./v5.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _v6_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./v6.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6.js\");\n/* harmony import */ var _v6ToV1_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./v6ToV1.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6ToV1.js\");\n/* harmony import */ var _v7_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./v7.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./validate.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./version.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/version.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNBO0FBQ0k7QUFDUTtBQUNkO0FBQ1E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNRO0FBQ1I7QUFDWSIsInNvdXJjZXMiOlsid2VicGFjazovL29yYml0YWwtYWktYWdlbnQvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzP2I2MzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyBNQVggfSBmcm9tICcuL21heC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MVRvVjYgfSBmcm9tICcuL3YxVG9WNi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2IH0gZnJvbSAnLi92Ni5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY2VG9WMSB9IGZyb20gJy4vdjZUb1YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjcgfSBmcm9tICcuL3Y3LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/max.js":
/*!***************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/max.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('ffffffff-ffff-ffff-ffff-ffffffffffff');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWF4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tYXguanM/YjlkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/max.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/md5.js":
/*!***************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/md5.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFNBQVMsNkRBQWlCO0FBQzFCO0FBQ0EsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL29yYml0YWwtYWktYWdlbnQvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcz9hOWY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/native.js":
/*!******************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/native.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtBQUNmLGNBQWMsK0RBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uYXRpdmUuanM/OWI4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/nil.js":
/*!***************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/nil.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uaWwuanM/MGVjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7QUFDckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcz84OWU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTtcblxuICAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmO1xuXG4gIC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7XG5cbiAgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjtcblxuICAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/regex.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/regex.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyw4RUFBOEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcz9jODc5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtOF1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js":
/*!***************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyx1Q0FBdUM7QUFDdkM7QUFDZTtBQUNmO0FBQ0EsSUFBSSxpRUFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanM/OGE2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ25vZGU6Y3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/sha1.js":
/*!****************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/sha1.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return node_crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLDZEQUFpQjtBQUMxQjtBQUNBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzPzAwN2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js\");\n\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JiaXRhbC1haS1hZ2VudC8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzPzBmODMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIC8vXG4gIC8vIE5vdGUgdG8gZnV0dXJlLXNlbGY6IE5vLCB5b3UgY2FuJ3QgcmVtb3ZlIHRoZSBgdG9Mb3dlckNhc2UoKWAgY2FsbC5cbiAgLy8gUkVGOiBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC82NzcjaXNzdWVjb21tZW50LTE3NTczNTEzNTFcbiAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgdXVpZCA9IHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCk7XG4gIC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgcmV0dXJuIHV1aWQ7XG59XG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0EsZ0JBQWdCLDhEQUFlO0FBQy9CO0FBQ0EsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL29yYml0YWwtYWktYWdlbnQvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzPzhjMDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxubGV0IF9ub2RlSWQ7XG5sZXQgX2Nsb2Nrc2VxO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbmxldCBfbGFzdE1TZWNzID0gMDtcbmxldCBfbGFzdE5TZWNzID0gMDtcblxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZTtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcTtcblxuICAvLyB2MSBvbmx5OiBVc2UgY2FjaGVkIGBub2RlYCBhbmQgYGNsb2Nrc2VxYCB2YWx1ZXNcbiAgaWYgKCFvcHRpb25zLl92Nikge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbm9kZSA9IF9ub2RlSWQ7XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgd2UgbmVlZCBlbnRyb3B5LiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzXG4gIC8vIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50IHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIC8vIFJhbmRvbWl6ZSBub2RlXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IFtzZWVkQnl0ZXNbMF0sIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcblxuICAgICAgLy8gdjEgb25seTogY2FjaGUgbm9kZSB2YWx1ZSBmb3IgcmV1c2VcbiAgICAgIGlmICghX25vZGVJZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgLy8gcGVyIFJGQzQxMjIgNC41OiBTZXQgTUFDIG11bHRpY2FzdCBiaXQgKHYxIG9ubHkpXG4gICAgICAgIG5vZGVbMF0gfD0gMHgwMTsgLy8gU2V0IG11bHRpY2FzdCBiaXRcblxuICAgICAgICBfbm9kZUlkID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSYW5kb21pemUgY2xvY2tzZXFcbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICAgIGlmIChfY2xvY2tzZXEgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5fdjYpIHtcbiAgICAgICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdjEgJiB2NiB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc28gdGltZSBpc1xuICAvLyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1ToV6.js":
/*!******************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1ToV6.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v1ToV6)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JiaXRhbC1haS1hZ2VudC8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjFUb1Y2LmpzP2NkOTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2MSBVVUlEIHRvIGEgdjYgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjEgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2NiBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjFUb1Y2KHV1aWQpIHtcbiAgY29uc3QgdjFCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjZCeXRlcyA9IF92MVRvVjYodjFCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjZCeXRlcykgOiB2NkJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2MSAtPiB2NlxuZnVuY3Rpb24gX3YxVG9WNih2MUJ5dGVzLCByYW5kb21pemUgPSBmYWxzZSkge1xuICByZXR1cm4gVWludDhBcnJheS5vZigodjFCeXRlc1s2XSAmIDB4MGYpIDw8IDQgfCB2MUJ5dGVzWzddID4+IDQgJiAweDBmLCAodjFCeXRlc1s3XSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1s0XSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHYxQnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgKHYxQnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjFCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjFCeXRlc1sxXSAmIDB4ZjApID4+IDQsICh2MUJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2MUJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgMHg2MCB8IHYxQnl0ZXNbMl0gJiAweDBmLCB2MUJ5dGVzWzNdLCB2MUJ5dGVzWzhdLCB2MUJ5dGVzWzldLCB2MUJ5dGVzWzEwXSwgdjFCeXRlc1sxMV0sIHYxQnl0ZXNbMTJdLCB2MUJ5dGVzWzEzXSwgdjFCeXRlc1sxNF0sIHYxQnl0ZXNbMTVdKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1ToV6.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v3.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v3.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92My5qcz80YTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v35.js":
/*!***************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v35.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js\");\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1E7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBZTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanM/NTk2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIF9uYW1lc3BhY2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShieXRlcyk7XG4gIH1cblxuICAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7XG4gIH0gY2F0Y2ggKGVycikge31cblxuICAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v4.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v4.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pEO0FBQ0EsTUFBTSw2REFBaUI7QUFDdkIsV0FBVyw2REFBaUI7QUFDNUI7QUFDQTtBQUNBLGlEQUFpRCwrQ0FBRzs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NC5qcz84YjcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v5.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v5.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcz8xZmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v1ToV6.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v1ToV6.js\");\n\n\n\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nfunction v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = (0,_v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = (0,_v1ToV6_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(bytes);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUN4QjtBQUNROztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsVUFBVSxzREFBTTs7QUFFaEI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBZTtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL29yYml0YWwtYWktYWdlbnQvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y2LmpzP2ZhZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHYxIGZyb20gJy4vdjEuanMnO1xuaW1wb3J0IHYxVG9WNiBmcm9tICcuL3YxVG9WNi5qcyc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXk9fSBidWZcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2NihvcHRpb25zID0ge30sIGJ1Ziwgb2Zmc2V0ID0gMCkge1xuICAvLyB2NiBpcyB2MSB3aXRoIGRpZmZlcmVudCBmaWVsZCBsYXlvdXQsIHNvIHdlIHN0YXJ0IHdpdGggYSB2MSBVVUlELCBhbGJlaXRcbiAgLy8gd2l0aCBzbGlnaHRseSBkaWZmZXJlbnQgYmVoYXZpb3IgYXJvdW5kIGhvdyB0aGUgY2xvY2tfc2VxIGFuZCBub2RlIGZpZWxkc1xuICAvLyBhcmUgcmFuZG9taXplZCwgd2hpY2ggaXMgd2h5IHdlIGNhbGwgdjEgd2l0aCBfdjY6IHRydWUuXG4gIGxldCBieXRlcyA9IHYxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIF92NjogdHJ1ZVxuICB9LCBuZXcgVWludDhBcnJheSgxNikpO1xuXG4gIC8vIFJlb3JkZXIgdGhlIGZpZWxkcyB0byB2NiBsYXlvdXQuXG4gIGJ5dGVzID0gdjFUb1Y2KGJ5dGVzKTtcblxuICAvLyBSZXR1cm4gYXMgYSBieXRlIGFycmF5IGlmIHJlcXVlc3RlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6ToV1.js":
/*!******************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6ToV1.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ v6ToV1)\n/* harmony export */ });\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/parse.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * Convert a v6 UUID to a v1 UUID\n *\n * @param {string|Uint8Array} uuid - The v6 UUID to convert to v6\n * @returns {string|Uint8Array} The v1 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nfunction v6ToV1(uuid) {\n  const v6Bytes = typeof uuid === 'string' ? (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid) : uuid;\n  const v1Bytes = _v6ToV1(v6Bytes);\n  return typeof uuid === 'string' ? (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(v1Bytes) : v1Bytes;\n}\n\n// Do the field transformation needed for v6 -> v1\nfunction _v6ToV1(v6Bytes) {\n  return Uint8Array.of((v6Bytes[3] & 0x0f) << 4 | v6Bytes[4] >> 4 & 0x0f, (v6Bytes[4] & 0x0f) << 4 | (v6Bytes[5] & 0xf0) >> 4, (v6Bytes[5] & 0x0f) << 4 | v6Bytes[6] & 0x0f, v6Bytes[7], (v6Bytes[1] & 0x0f) << 4 | (v6Bytes[2] & 0xf0) >> 4, (v6Bytes[2] & 0x0f) << 4 | (v6Bytes[3] & 0xf0) >> 4, 0x10 | (v6Bytes[0] & 0xf0) >> 4, (v6Bytes[0] & 0x0f) << 4 | (v6Bytes[1] & 0xf0) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNlO0FBQ2YsNkNBQTZDLHFEQUFLO0FBQ2xEO0FBQ0Esb0NBQW9DLDhEQUFlO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JiaXRhbC1haS1hZ2VudC8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjZUb1YxLmpzPzRjNzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2NiBVVUlEIHRvIGEgdjEgVVVJRFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHV1aWQgLSBUaGUgdjYgVVVJRCB0byBjb252ZXJ0IHRvIHY2XG4gKiBAcmV0dXJucyB7c3RyaW5nfFVpbnQ4QXJyYXl9IFRoZSB2MSBVVUlEIGFzIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGB1dWlkYCBhcmdcbiAqIChzdHJpbmcgb3IgVWludDhBcnJheSlcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdjZUb1YxKHV1aWQpIHtcbiAgY29uc3QgdjZCeXRlcyA9IHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyA/IHBhcnNlKHV1aWQpIDogdXVpZDtcbiAgY29uc3QgdjFCeXRlcyA9IF92NlRvVjEodjZCeXRlcyk7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgPyB1bnNhZmVTdHJpbmdpZnkodjFCeXRlcykgOiB2MUJ5dGVzO1xufVxuXG4vLyBEbyB0aGUgZmllbGQgdHJhbnNmb3JtYXRpb24gbmVlZGVkIGZvciB2NiAtPiB2MVxuZnVuY3Rpb24gX3Y2VG9WMSh2NkJ5dGVzKSB7XG4gIHJldHVybiBVaW50OEFycmF5Lm9mKCh2NkJ5dGVzWzNdICYgMHgwZikgPDwgNCB8IHY2Qnl0ZXNbNF0gPj4gNCAmIDB4MGYsICh2NkJ5dGVzWzRdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzVdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbNV0gJiAweDBmKSA8PCA0IHwgdjZCeXRlc1s2XSAmIDB4MGYsIHY2Qnl0ZXNbN10sICh2NkJ5dGVzWzFdICYgMHgwZikgPDwgNCB8ICh2NkJ5dGVzWzJdICYgMHhmMCkgPj4gNCwgKHY2Qnl0ZXNbMl0gJiAweDBmKSA8PCA0IHwgKHY2Qnl0ZXNbM10gJiAweGYwKSA+PiA0LCAweDEwIHwgKHY2Qnl0ZXNbMF0gJiAweGYwKSA+PiA0LCAodjZCeXRlc1swXSAmIDB4MGYpIDw8IDQgfCAodjZCeXRlc1sxXSAmIDB4ZjApID4+IDQsIHY2Qnl0ZXNbOF0sIHY2Qnl0ZXNbOV0sIHY2Qnl0ZXNbMTBdLCB2NkJ5dGVzWzExXSwgdjZCeXRlc1sxMl0sIHY2Qnl0ZXNbMTNdLCB2NkJ5dGVzWzE0XSwgdjZCeXRlc1sxNV0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v6ToV1.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v7.js":
/*!**************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/v7.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v7);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsK0NBQUc7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBZTtBQUMvQjtBQUNBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92Ny5qcz9hMzllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG4vKipcbiAqIFVVSUQgVjcgLSBVbml4IEVwb2NoIHRpbWUtYmFzZWQgVVVJRFxuICpcbiAqIFRoZSBJRVRGIGhhcyBwdWJsaXNoZWQgUkZDOTU2MiwgaW50cm9kdWNpbmcgMyBuZXcgVVVJRCB2ZXJzaW9ucyAoNiw3LDgpLiBUaGlzXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBWNyBpcyBiYXNlZCBvbiB0aGUgYWNjZXB0ZWQsIHRob3VnaCBub3QgeWV0IGFwcHJvdmVkLFxuICogcmV2aXNpb25zLlxuICpcbiAqIFJGQyA5NTYyOmh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwgVW5pdmVyc2FsbHkgVW5pcXVlXG4gKiBJRGVudGlmaWVycyAoVVVJRHMpXG5cbiAqXG4gKiBTYW1wbGUgVjcgdmFsdWU6XG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTU2Mi5odG1sI25hbWUtZXhhbXBsZS1vZi1hLXV1aWR2Ny12YWx1ZVxuICpcbiAqIE1vbm90b25pYyBCaXQgTGF5b3V0OiBSRkMgcmZjOTU2Mi42LjIgTWV0aG9kIDEsIERlZGljYXRlZCBDb3VudGVyIEJpdHMgcmVmOlxuICogICAgIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5NTYyLmh0bWwjc2VjdGlvbi02LjItNS4xXG4gKlxuICogICAwICAgICAgICAgICAgICAgICAgIDEgICAgICAgICAgICAgICAgICAgMiAgICAgICAgICAgICAgICAgICAzIDAgMSAyIDMgNCA1IDZcbiAqICAgNyA4IDkgMCAxIDIgMyA0IDUgNiA3IDggOSAwIDEgMiAzIDQgNSA2IDcgOCA5IDAgMVxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICogIHwgICAgICAgICAgdW5peF90c19tcyAgICAgICAgICAgfCAgdmVyICB8ICAgICAgICBzZXFfaGkgICAgICAgICB8XG4gKiAgKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLStcbiAqICB8dmFyfCAgICAgICAgICAgICAgIHNlcV9sb3cgICAgICAgICAgICAgICB8ICAgICAgICByYW5kICAgICAgICAgfFxuICogICstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICArLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstKy0rLSstK1xuICpcbiAqIHNlcSBpcyBhIDMxIGJpdCBzZXJpYWxpemVkIGNvdW50ZXI7IGNvbXByaXNlZCBvZiAxMiBiaXQgc2VxX2hpIGFuZCAxOSBiaXRcbiAqIHNlcV9sb3csIGFuZCByYW5kb21seSBpbml0aWFsaXplZCB1cG9uIHRpbWVzdGFtcCBjaGFuZ2UuIDMxIGJpdCBjb3VudGVyIHNpemVcbiAqIHdhcyBzZWxlY3RlZCBhcyBhbnkgYml0d2lzZSBvcGVyYXRpb25zIGluIG5vZGUgYXJlIGRvbmUgYXMgX3NpZ25lZF8gMzIgYml0XG4gKiBpbnRzLiB3ZSBleGNsdWRlIHRoZSBzaWduIGJpdC5cbiAqL1xuXG5sZXQgX3NlcUxvdyA9IG51bGw7XG5sZXQgX3NlcUhpZ2ggPSBudWxsO1xubGV0IF9tc2VjcyA9IDA7XG5mdW5jdGlvbiB2NyhvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBpbml0aWFsaXplIGJ1ZmZlciBhbmQgcG9pbnRlclxuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgVWludDhBcnJheSgxNik7XG5cbiAgLy8gcm5kcyBpcyBVaW50OEFycmF5KDE2KSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXNcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gbWlsbGlzZWNvbmRzIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDBcbiAgY29uc3QgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTtcblxuICAvLyBzZXEgaXMgdXNlciBwcm92aWRlZCAzMSBiaXQgY291bnRlclxuICBsZXQgc2VxID0gb3B0aW9ucy5zZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2VxIDogbnVsbDtcblxuICAvLyBpbml0aWFsaXplIGxvY2FsIHNlcSBoaWdoL2xvdyBwYXJ0c1xuICBsZXQgc2VxSGlnaCA9IF9zZXFIaWdoO1xuICBsZXQgc2VxTG93ID0gX3NlcUxvdztcblxuICAvLyBjaGVjayBpZiBjbG9jayBoYXMgYWR2YW5jZWQgYW5kIHVzZXIgaGFzIG5vdCBwcm92aWRlZCBtc2Vjc1xuICBpZiAobXNlY3MgPiBfbXNlY3MgJiYgb3B0aW9ucy5tc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgX21zZWNzID0gbXNlY3M7XG5cbiAgICAvLyB1bmxlc3MgdXNlciBwcm92aWRlZCBzZXEsIHJlc2V0IHNlcSBwYXJ0c1xuICAgIGlmIChzZXEgIT09IG51bGwpIHtcbiAgICAgIHNlcUhpZ2ggPSBudWxsO1xuICAgICAgc2VxTG93ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgdXNlciBwcm92aWRlZCBzZXFcbiAgaWYgKHNlcSAhPT0gbnVsbCkge1xuICAgIC8vIHRyaW0gcHJvdmlkZWQgc2VxIHRvIDMxIGJpdHMgb2YgdmFsdWUsIGF2b2lkaW5nIG92ZXJmbG93XG4gICAgaWYgKHNlcSA+IDB4N2ZmZmZmZmYpIHtcbiAgICAgIHNlcSA9IDB4N2ZmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gc3BsaXQgcHJvdmlkZWQgc2VxIGludG8gaGlnaC9sb3cgcGFydHNcbiAgICBzZXFIaWdoID0gc2VxID4+PiAxOSAmIDB4ZmZmO1xuICAgIHNlcUxvdyA9IHNlcSAmIDB4N2ZmZmY7XG4gIH1cblxuICAvLyByYW5kb21seSBpbml0aWFsaXplIHNlcVxuICBpZiAoc2VxSGlnaCA9PT0gbnVsbCB8fCBzZXFMb3cgPT09IG51bGwpIHtcbiAgICBzZXFIaWdoID0gcm5kc1s2XSAmIDB4N2Y7XG4gICAgc2VxSGlnaCA9IHNlcUhpZ2ggPDwgOCB8IHJuZHNbN107XG4gICAgc2VxTG93ID0gcm5kc1s4XSAmIDB4M2Y7IC8vIHBhZCBmb3IgdmFyXG4gICAgc2VxTG93ID0gc2VxTG93IDw8IDggfCBybmRzWzldO1xuICAgIHNlcUxvdyA9IHNlcUxvdyA8PCA1IHwgcm5kc1sxMF0gPj4+IDM7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgc2VxIGlmIHdpdGhpbiBtc2VjcyB3aW5kb3dcbiAgaWYgKG1zZWNzICsgMTAwMDAgPiBfbXNlY3MgJiYgc2VxID09PSBudWxsKSB7XG4gICAgaWYgKCsrc2VxTG93ID4gMHg3ZmZmZikge1xuICAgICAgc2VxTG93ID0gMDtcbiAgICAgIGlmICgrK3NlcUhpZ2ggPiAweGZmZikge1xuICAgICAgICBzZXFIaWdoID0gMDtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgaW50ZXJuYWwgX21zZWNzLiB0aGlzIGFsbG93cyB1cyB0byBjb250aW51ZSBpbmNyZW1lbnRpbmdcbiAgICAgICAgLy8gd2hpbGUgc3RheWluZyBtb25vdG9uaWMuIE5vdGUsIG9uY2Ugd2UgaGl0IDEwayBtaWxsaXNlY29uZHMgYmV5b25kIHN5c3RlbVxuICAgICAgICAvLyBjbG9jaywgd2Ugd2lsbCByZXNldCBicmVha2luZyBtb25vdG9uaWNpdHkgKGFmdGVyICgyXjMxKSoxMDAwMCBnZW5lcmF0aW9ucylcbiAgICAgICAgX21zZWNzKys7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0dGluZzsgd2UgaGF2ZSBhZHZhbmNlZCBtb3JlIHRoYW5cbiAgICAvLyAxMGsgbWlsbGlzZWNvbmRzIGJleW9uZCBzeXN0ZW0gY2xvY2tcbiAgICBfbXNlY3MgPSBtc2VjcztcbiAgfVxuICBfc2VxSGlnaCA9IHNlcUhpZ2g7XG4gIF9zZXFMb3cgPSBzZXFMb3c7XG5cbiAgLy8gW2J5dGVzIDAtNV0gNDggYml0cyBvZiBsb2NhbCB0aW1lc3RhbXBcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMDAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzIC8gMHgxMDAwMCAmIDB4ZmY7XG4gIGJbaSsrXSA9IF9tc2VjcyAvIDB4MTAwICYgMHhmZjtcbiAgYltpKytdID0gX21zZWNzICYgMHhmZjtcblxuICAvLyBbYnl0ZSA2XSAtIHNldCA0IGJpdHMgb2YgdmVyc2lvbiAoNykgd2l0aCBmaXJzdCA0IGJpdHMgc2VxX2hpXG4gIGJbaSsrXSA9IHNlcUhpZ2ggPj4+IDQgJiAweDBmIHwgMHg3MDtcblxuICAvLyBbYnl0ZSA3XSByZW1haW5pbmcgOCBiaXRzIG9mIHNlcV9oaVxuICBiW2krK10gPSBzZXFIaWdoICYgMHhmZjtcblxuICAvLyBbYnl0ZSA4XSAtIHZhcmlhbnQgKDIgYml0cyksIGZpcnN0IDYgYml0cyBzZXFfbG93XG4gIGJbaSsrXSA9IHNlcUxvdyA+Pj4gMTMgJiAweDNmIHwgMHg4MDtcblxuICAvLyBbYnl0ZSA5XSA4IGJpdHMgc2VxX2xvd1xuICBiW2krK10gPSBzZXFMb3cgPj4+IDUgJiAweGZmO1xuXG4gIC8vIFtieXRlIDEwXSByZW1haW5pbmcgNSBiaXRzIHNlcV9sb3csIDMgYml0cyByYW5kb21cbiAgYltpKytdID0gc2VxTG93IDw8IDMgJiAweGZmIHwgcm5kc1sxMF0gJiAweDA3O1xuXG4gIC8vIFtieXRlcyAxMS0xNV0gYWx3YXlzIHJhbmRvbVxuICBiW2krK10gPSBybmRzWzExXTtcbiAgYltpKytdID0gcm5kc1sxMl07XG4gIGJbaSsrXSA9IHJuZHNbMTNdO1xuICBiW2krK10gPSBybmRzWzE0XTtcbiAgYltpKytdID0gcm5kc1sxNV07XG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/v7.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0I7QUFDQSxxQ0FBcUMsc0RBQVU7QUFDL0M7QUFDQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3JiaXRhbC1haS1hZ2VudC8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanM/YjY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/composio-core/node_modules/uuid/dist/esm-node/version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  return parseInt(uuid.slice(14, 15), 16);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jb21wb3Npby1jb3JlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcmJpdGFsLWFpLWFnZW50Ly4vbm9kZV9tb2R1bGVzL2NvbXBvc2lvLWNvcmUvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92ZXJzaW9uLmpzPzEyZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/composio-core/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;